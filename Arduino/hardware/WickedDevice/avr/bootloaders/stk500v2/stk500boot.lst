   1               		.file	"stk500boot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  97               		.section	.init9,"ax",@progbits
  99               	.global	__jumpMain
 101               	__jumpMain:
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  **** License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  **** Date:      17 October 2007
  12:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  13:stk500boot.c  **** Compiler:  WINAVR20060421
  14:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  **** DESCRIPTION:
  17:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****     "reset" vector in Application area.
  22:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  23:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  24:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  **** USAGE:
  27:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****     - AVRISP will detect the bootloader
  38:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  **** Note:
  41:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****     Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  **** 	AVRdude:
  46:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  **** NOTES:
  51:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  **** LICENSE:
  55:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****     any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****     GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  **** *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM testLDogle.com/p/arduino/issues/detail?id=505
  79:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  80:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence
  81:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).
  82:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  83:stk500boot.c  **** #define	_FIX_ISSUE_505_
  84:stk500boot.c  **** //************************************************************************
  85:stk500boot.c  **** //*	Issue 181: added watch dog timer support
  86:stk500boot.c  **** #define	_FIX_ISSUE_181_
  87:stk500boot.c  **** 
  88:stk500boot.c  **** #define BAUDRATE 38400
  89:stk500boot.c  **** 
  90:stk500boot.c  **** #include	<inttypes.h>
  91:stk500boot.c  **** #include	<avr/io.h>
  92:stk500boot.c  **** #include	<avr/interrupt.h>
  93:stk500boot.c  **** #include	<avr/boot.h>
  94:stk500boot.c  **** #include	<avr/pgmspace.h>
  95:stk500boot.c  **** #include	<util/delay.h>
  96:stk500boot.c  **** #include	<avr/eeprom.h>
  97:stk500boot.c  **** #include	<avr/common.h>
  98:stk500boot.c  **** #include	<stdlib.h>
  99:stk500boot.c  **** #include	"command.h"
 100:stk500boot.c  **** #include	"avr_cpunames.h"
 101:stk500boot.c  **** #include	"avrinterruptnames.h"
 102:stk500boot.c  **** 
 103:stk500boot.c  **** 
 104:stk500boot.c  **** #if defined(_WILDFIRE_BOARD_) || defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AV
 105:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 106:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 107:stk500boot.c  **** 	#define		ENABLE_MONITOR
 108:stk500boot.c  **** 	static void	RunMonitor(void);
 109:stk500boot.c  **** #endif
 110:stk500boot.c  **** 
 111:stk500boot.c  **** #ifndef EEWE
 112:stk500boot.c  **** 	#define EEWE    1
 113:stk500boot.c  **** #endif
 114:stk500boot.c  **** #ifndef EEMWE
 115:stk500boot.c  **** 	#define EEMWE   2
 116:stk500boot.c  **** #endif
 117:stk500boot.c  **** 
 118:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 119:stk500boot.c  **** //#define _DEBUG_SERIAL1_ // use USART1 to avoid disturbing the stk500v2 protocol on USART0
 120:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 121:stk500boot.c  **** 
 122:stk500boot.c  **** 
 123:stk500boot.c  **** /*
 124:stk500boot.c  ****  * Uncomment the following lines to save code space
 125:stk500boot.c  ****  */
 126:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT	// disable program lock bits
 127:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED			// no LED to show active bootloader
 128:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI			// disable processing of SPI_MULTI commands, Remark this line for 
 129:stk500boot.c  **** //
 130:stk500boot.c  **** 
 131:stk500boot.c  **** 
 132:stk500boot.c  **** 
 133:stk500boot.c  **** //************************************************************************
 134:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 135:stk500boot.c  **** //*	indicates that bootloader is active
 136:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 137:stk500boot.c  **** //************************************************************************
 138:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 139:stk500boot.c  **** 
 140:stk500boot.c  **** #if defined ( _WILDFIRE_BOARD_ )
 141:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 142:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 143:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 144:stk500boot.c  **** 
 145:stk500boot.c  **** #elif defined ( _MEGA_BOARD_ )
 146:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 147:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 148:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 149:stk500boot.c  **** 
 150:stk500boot.c  **** #elif defined( _UNO_BOARD_ )
 151:stk500boot.c  **** 	//*	onboard led is PORTB5
 152:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 153:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 154:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 155:stk500boot.c  **** 
 156:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 157:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 158:stk500boot.c  **** 	//*	onboard led is PORTE4
 159:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 160:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 161:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 162:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 163:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 164:stk500boot.c  **** 	//*	onboard leds are on PORTE4-7
 165:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 166:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 167:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 168:stk500boot.c  **** #elif defined( _PENGUINO_ )
 169:stk500boot.c  **** 	//*	this is for the Penguino
 170:stk500boot.c  **** 	//*	onboard led is PORTE4
 171:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 172:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 173:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 174:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 175:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 176:stk500boot.c  **** 	//*	onboard led is PORTE4
 177:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 178:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 179:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 180:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 181:stk500boot.c  **** 	//*	onboard led is PORTA7
 182:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 183:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 184:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 185:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 186:stk500boot.c  **** 
 187:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 188:stk500boot.c  **** 	//*	doesn't have an onboard LED but this is what will probably be added to this port
 189:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 190:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 191:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 192:stk500boot.c  **** 
 193:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 194:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 195:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 196:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 197:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 198:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 199:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 200:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 201:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 202:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 203:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 204:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 205:stk500boot.c  **** #elif defined( _AVRLIP_ )
 206:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 207:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 208:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 209:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 210:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 211:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 212:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 213:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 214:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 215:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 216:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 217:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 218:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 219:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 220:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 221:stk500boot.c  **** #else
 222:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 223:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 224:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 225:stk500boot.c  **** #endif
 226:stk500boot.c  **** 
 227:stk500boot.c  **** 
 228:stk500boot.c  **** 
 229:stk500boot.c  **** /*
 230:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 231:stk500boot.c  ****  */
 232:stk500boot.c  **** #ifndef F_CPU
 233:stk500boot.c  **** 	#define F_CPU 16000000UL
 234:stk500boot.c  **** #endif
 235:stk500boot.c  **** 
 236:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 237:stk500boot.c  **** 
 238:stk500boot.c  **** /*
 239:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 240:stk500boot.c  ****  */
 241:stk500boot.c  **** #ifndef BAUDRATE
 242:stk500boot.c  **** 	#define BAUDRATE 115200
 243:stk500boot.c  **** #endif
 244:stk500boot.c  **** 
 245:stk500boot.c  **** /*
 246:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 247:stk500boot.c  ****  */
 248:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 249:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 250:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 251:stk500boot.c  **** 	#else
 252:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 253:stk500boot.c  **** 	#endif
 254:stk500boot.c  **** #endif
 255:stk500boot.c  **** 
 256:stk500boot.c  **** /*
 257:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 258:stk500boot.c  ****  */
 259:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 260:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 261:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 262:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 263:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 264:stk500boot.c  **** 
 265:stk500boot.c  **** /*
 266:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 267:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 268:stk500boot.c  ****  */
 269:stk500boot.c  **** //#define BOOTSIZE 1024
 270:stk500boot.c  **** #if FLASHEND > 0x0F000
 271:stk500boot.c  **** 	#define BOOTSIZE 8192
 272:stk500boot.c  **** #elif FLASHEND < 0x08000
 273:stk500boot.c  **** 	#define BOOTSIZE 1024
 274:stk500boot.c  **** #elif FLASHEND <= 0x0F000
 275:stk500boot.c  **** 	#define BOOTSIZE 2048
 276:stk500boot.c  **** #endif
 277:stk500boot.c  **** 
 278:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 279:stk500boot.c  **** 
 280:stk500boot.c  **** /*
 281:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 282:stk500boot.c  ****  */
 283:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 285:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 287:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 289:stk500boot.c  **** #elif defined (__AVR_ATmega328P__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E950F
 291:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 293:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 295:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 297:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 301:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 303:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 305:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 307:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 309:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 310:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 311:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 312:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 313:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 314:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 315:stk500boot.c  **** #else
 316:stk500boot.c  **** 	#error "no signature definition for MCU available"
 317:stk500boot.c  **** #endif
 318:stk500boot.c  **** 
 319:stk500boot.c  **** 
 320:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 321:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 322:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 323:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 324:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 325:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 326:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 327:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 328:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 329:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 330:stk500boot.c  **** 
 331:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 332:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 333:stk500boot.c  **** 	/* ATMega8 with one USART */
 334:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 335:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 336:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 337:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 338:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 339:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 340:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 341:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 342:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 343:stk500boot.c  **** 
 344:stk500boot.c  **** #elif  defined(__AVR_ATmega328P__)
 345:stk500boot.c  **** 	/* ATMega328p with one USART */
 346:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 347:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 348:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 349:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 350:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 351:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 352:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 353:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 354:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 355:stk500boot.c  **** 
 356:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 357:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) \
 358:stk500boot.c  **** 	 || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__)
 359:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 360:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 361:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 362:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 363:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 364:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 365:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 366:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 367:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 368:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 369:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 370:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 371:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 372:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 373:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 374:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 375:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 376:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 377:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 378:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 379:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 380:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 381:stk500boot.c  **** 	//* catch all
 382:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 383:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 384:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 385:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 386:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 387:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 388:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 389:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 390:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 391:stk500boot.c  **** #else
 392:stk500boot.c  **** 	#error "no UART definition for MCU available"
 393:stk500boot.c  **** #endif
 394:stk500boot.c  **** 
 395:stk500boot.c  **** #if defined(_DEBUG_SERIAL1_)
 396:stk500boot.c  **** 	#define	UART1_BAUD_RATE_LOW			UBRR1L
 397:stk500boot.c  **** 	#define	UART1_STATUS_REG			UCSR1A
 398:stk500boot.c  **** 	#define	UART1_CONTROL_REG			UCSR1B
 399:stk500boot.c  **** 	#define	UART1_ENABLE_TRANSMITTER	TXEN1
 400:stk500boot.c  **** 	#define	UART1_ENABLE_RECEIVER		RXEN1
 401:stk500boot.c  **** 	#define	UART1_TRANSMIT_COMPLETE		TXC1
 402:stk500boot.c  **** 	#define	UART1_RECEIVE_COMPLETE		RXC1
 403:stk500boot.c  **** 	#define	UART1_DATA_REG				UDR1
 404:stk500boot.c  **** 	#define	UART1_DOUBLE_SPEED			U2X1
 405:stk500boot.c  **** #endif
 406:stk500boot.c  **** 
 407:stk500boot.c  **** /*
 408:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 409:stk500boot.c  ****  */
 410:stk500boot.c  **** // for Arduino at 16MHz; above data sheet calculation is wrong. Need below from <util/setbaud.h>
 411:stk500boot.c  **** // This provides correct rounding truncation to get closest to correct speed.
 412:stk500boot.c  **** // Normal mode gives 3.7% error, which is too much. Use 2x mode gives 2.1% error.
 413:stk500boot.c  **** 
 414:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 415:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 416:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 417:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 418:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 419:stk500boot.c  **** //	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5
 420:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu + baudRate / 4) / (baudRate * 8) - 1)
 421:stk500boot.c  **** #else
 422:stk500boot.c  **** //	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.
 423:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu + baudRate / 8) / (baudRate * 16) - 1)
 424:stk500boot.c  **** #endif
 425:stk500boot.c  **** 
 426:stk500boot.c  **** /*
 427:stk500boot.c  ****  * States used in the receive state machine
 428:stk500boot.c  ****  */
 429:stk500boot.c  **** #define	ST_START		0
 430:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 431:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 432:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 433:stk500boot.c  **** #define ST_GET_TOKEN	4
 434:stk500boot.c  **** #define ST_GET_DATA		5
 435:stk500boot.c  **** #define	ST_GET_CHECK	6
 436:stk500boot.c  **** #define	ST_PROCESS		7
 437:stk500boot.c  **** 
 438:stk500boot.c  **** /*
 439:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 440:stk500boot.c  ****  */
 441:stk500boot.c  **** #if defined(RAMPZ)
 442:stk500boot.c  **** 	typedef uint32_t address_t;
 443:stk500boot.c  **** #else
 444:stk500boot.c  **** 	typedef uint16_t address_t;
 445:stk500boot.c  **** #endif
 446:stk500boot.c  **** 
 447:stk500boot.c  **** /*
 448:stk500boot.c  ****  * function prototypes
 449:stk500boot.c  ****  */
 450:stk500boot.c  **** static void sendchar(uint8_t c);
 451:stk500boot.c  **** static uint8_t recchar(void);
 452:stk500boot.c  **** static uint8_t recchar_timeout(void);
 453:stk500boot.c  **** 
 454:stk500boot.c  **** /*
 455:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 456:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 457:stk500boot.c  ****  */
 458:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 459:stk500boot.c  **** #include <avr/sfr_defs.h>
 460:stk500boot.c  **** 
 461:stk500boot.c  **** //#define	SPH_REG	0x3E
 462:stk500boot.c  **** //#define	SPL_REG	0x3D
 463:stk500boot.c  **** 
 464:stk500boot.c  **** //*****************************************************************************
 465:stk500boot.c  **** void __jumpMain(void)
 466:stk500boot.c  **** {
 103               	.LM0:
 104               	.LFBB1:
 105               	/* prologue: naked */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
 467:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 468:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 469:stk500boot.c  **** 
 470:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 110               	.LM1:
 111               	/* #APP */
 112               	 ;  470 "stk500boot.c" 1
 113               		.set __stack, 16639
 114               	 ;  0 "" 2
 471:stk500boot.c  **** 
 472:stk500boot.c  **** //*	set stack pointer to top of RAM
 473:stk500boot.c  **** 
 474:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 116               	.LM2:
 117               	 ;  474 "stk500boot.c" 1
 118 0000 00E4      		ldi	16, 64
 119               	 ;  0 "" 2
 475:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 121               	.LM3:
 122               	 ;  475 "stk500boot.c" 1
 123 0002 0EBF      		out 62,16
 124               	 ;  0 "" 2
 476:stk500boot.c  **** 
 477:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 126               	.LM4:
 127               	 ;  477 "stk500boot.c" 1
 128 0004 0FEF      		ldi	16, 255
 129               	 ;  0 "" 2
 478:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 131               	.LM5:
 132               	 ;  478 "stk500boot.c" 1
 133 0006 0DBF      		out 61,16
 134               	 ;  0 "" 2
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 136               	.LM6:
 137               	 ;  480 "stk500boot.c" 1
 138 0008 1124      		clr __zero_reg__
 139               	 ;  0 "" 2
 481:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 141               	.LM7:
 142               	 ;  481 "stk500boot.c" 1
 143 000a 1FBE      		out 63, __zero_reg__
 144               	 ;  0 "" 2
 482:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 146               	.LM8:
 147               	 ;  482 "stk500boot.c" 1
 148 000c 0C94 0000 		jmp main
 149               	 ;  0 "" 2
 150               	/* epilogue start */
 483:stk500boot.c  **** }
 152               	.LM9:
 153               	/* #NOAPP */
 155               	.Lscope1:
 156               		.text
 160               	.global	PrintFromPROGMEM
 162               	PrintFromPROGMEM:
 484:stk500boot.c  **** 
 485:stk500boot.c  **** 
 486:stk500boot.c  **** //*****************************************************************************
 487:stk500boot.c  **** /*
 488:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 489:stk500boot.c  ****  */
 490:stk500boot.c  **** static void sendchar(uint8_t c)
 491:stk500boot.c  **** {
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 495:stk500boot.c  **** }
 496:stk500boot.c  **** 
 497:stk500boot.c  **** 
 498:stk500boot.c  **** //************************************************************************
 499:stk500boot.c  **** static int	Serial_Available(void)
 500:stk500boot.c  **** {
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 502:stk500boot.c  **** }
 503:stk500boot.c  **** 
 504:stk500boot.c  **** 
 505:stk500boot.c  **** #if defined(_DEBUG_SERIAL1_)
 506:stk500boot.c  **** //*****************************************************************************
 507:stk500boot.c  **** /*
 508:stk500boot.c  ****  * wait until transmission is completed,send single byte to USART
 509:stk500boot.c  ****  */
 510:stk500boot.c  **** static void sendchar1(uint8_t c)
 511:stk500boot.c  **** {
 512:stk500boot.c  **** 	UART1_DATA_REG	=	c;										// prepare transmission
 513:stk500boot.c  **** 	while (!(UART1_STATUS_REG & _BV(UART1_TRANSMIT_COMPLETE)));	// wait until byte sent
 514:stk500boot.c  **** 	UART1_STATUS_REG |= _BV(UART1_TRANSMIT_COMPLETE);			// delete TX1Cflag
 515:stk500boot.c  **** }
 516:stk500boot.c  **** #endif
 517:stk500boot.c  **** 
 518:stk500boot.c  **** //*****************************************************************************
 519:stk500boot.c  **** /*
 520:stk500boot.c  ****  * Read single byte from USART, block if no data available
 521:stk500boot.c  ****  */
 522:stk500boot.c  **** static uint8_t recchar(void)
 523:stk500boot.c  **** {
 524:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 525:stk500boot.c  **** 	{
 526:stk500boot.c  **** 		// wait for data
 527:stk500boot.c  **** 	}
 528:stk500boot.c  **** 	return UART_DATA_REG;
 529:stk500boot.c  **** }
 530:stk500boot.c  **** 
 531:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 532:stk500boot.c  **** 
 533:stk500boot.c  **** //*****************************************************************************
 534:stk500boot.c  **** static uint8_t recchar_timeout(void)
 535:stk500boot.c  **** {
 536:stk500boot.c  **** uint32_t count = 0;
 537:stk500boot.c  **** 
 538:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 539:stk500boot.c  **** 	{
 540:stk500boot.c  **** 		// wait for data
 541:stk500boot.c  **** 		count++;
 542:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 543:stk500boot.c  **** 		{
 544:stk500boot.c  **** 		uint16_t	data;
 545:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 546:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 547:stk500boot.c  **** 		#else
 548:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 549:stk500boot.c  **** 		#endif
 550:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 551:stk500boot.c  **** 			{
 552:stk500boot.c  **** 				asm volatile(
 553:stk500boot.c  **** 						"clr	r30		\n\t"
 554:stk500boot.c  **** 						"clr	r31		\n\t"
 555:stk500boot.c  **** 						"ijmp	\n\t"
 556:stk500boot.c  **** 						);
 557:stk500boot.c  **** 			}
 558:stk500boot.c  **** 			count	=	0;
 559:stk500boot.c  **** 		}
 560:stk500boot.c  **** 	}
 561:stk500boot.c  **** 	return UART_DATA_REG;
 562:stk500boot.c  **** }
 563:stk500boot.c  **** 
 564:stk500boot.c  **** //*	for watchdog timer startup
 565:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 566:stk500boot.c  **** 
 567:stk500boot.c  **** /* Main program loop */
 568:stk500boot.c  **** int main(void) __attribute__ ((OS_main));
 569:stk500boot.c  **** 
 570:stk500boot.c  **** //*****************************************************************************
 571:stk500boot.c  **** int main(void)
 572:stk500boot.c  **** {
 573:stk500boot.c  **** 	address_t		address			=	0;
 574:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 575:stk500boot.c  **** 	uint8_t	msgParseState;
 576:stk500boot.c  **** 	uint16_t	ii				=	0;
 577:stk500boot.c  **** 	uint8_t	checksum		=	0;
 578:stk500boot.c  **** 	uint8_t	seqNum			=	0;
 579:stk500boot.c  **** 	uint16_t	msgLength		=	0;
 580:stk500boot.c  **** 	uint8_t	msgBuffer[285];
 581:stk500boot.c  **** 	uint8_t	c;
 582:stk500boot.c  **** 	uint8_t   *p;
 583:stk500boot.c  **** 	uint8_t   isLeave = 0;
 584:stk500boot.c  **** 
 585:stk500boot.c  **** 	uint32_t	boot_timeout;
 586:stk500boot.c  **** 	uint32_t	boot_timer;
 587:stk500boot.c  **** 	uint16_t	boot_state;
 588:stk500boot.c  **** #ifdef ENABLE_MONITOR
 589:stk500boot.c  **** 	uint16_t	exPointCntr		=	0;
 590:stk500boot.c  **** 	uint16_t	rcvdCharCntr	=	0;
 591:stk500boot.c  **** #endif
 592:stk500boot.c  **** 
 593:stk500boot.c  **** 	//*	some chips don't set the stack properly
 594:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 595:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 596:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 597:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 598:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 599:stk500boot.c  **** 
 600:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 601:stk500boot.c  **** 	//************************************************************************
 602:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watchdog timer support
 603:stk500boot.c  **** 	//*	handle the watchdog timer
 604:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 605:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 606:stk500boot.c  **** 
 607:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 608:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 609:stk500boot.c  **** 	MCUSR	=	0;
 610:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 611:stk500boot.c  **** 	WDTCSR	=	0;
 612:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 613:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 614:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 615:stk500boot.c  **** 	{
 616:stk500boot.c  **** 		app_start();
 617:stk500boot.c  **** 	}
 618:stk500boot.c  **** 	//************************************************************************
 619:stk500boot.c  **** #endif
 620:stk500boot.c  **** 
 621:stk500boot.c  **** 
 622:stk500boot.c  **** 	boot_timer	=	0;
 623:stk500boot.c  **** 	boot_state	=	0;
 624:stk500boot.c  **** 
 625:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 626:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 627:stk500boot.c  **** //	boot_timeout	=	170000;
 628:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 629:stk500boot.c  **** #else
 630:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 631:stk500boot.c  **** #endif
 632:stk500boot.c  **** 	/*
 633:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 634:stk500boot.c  **** 	 */
 635:stk500boot.c  **** 
 636:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 637:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 638:stk500boot.c  **** 	PROGLED_DDR		|=	_BV(PROGLED_PIN);
 639:stk500boot.c  **** //	PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// active low LED ON
 640:stk500boot.c  **** 	PROGLED_PORT	|=	_BV(PROGLED_PIN);	// active high LED ON
 641:stk500boot.c  **** 
 642:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 643:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 644:stk500boot.c  **** 	{
 645:stk500boot.c  **** 		PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// turn LED off
 646:stk500boot.c  **** 		_delay_ms(50);
 647:stk500boot.c  **** 		PROGLED_PORT	|=	_BV(PROGLED_PIN);	// turn LED on
 648:stk500boot.c  **** 		_delay_ms(50);
 649:stk500boot.c  **** 	}
 650:stk500boot.c  **** #endif
 651:stk500boot.c  **** 
 652:stk500boot.c  **** #endif
 653:stk500boot.c  **** 	/*
 654:stk500boot.c  **** 	 * Init UART
 655:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmitter without interrupts
 656:stk500boot.c  **** 	 */
 657:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 658:stk500boot.c  **** 	UART_STATUS_REG		|=	_BV(UART_DOUBLE_SPEED);
 659:stk500boot.c  **** #endif
 660:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE, F_CPU);
 661:stk500boot.c  **** 	UART_CONTROL_REG	=	_BV(UART_ENABLE_RECEIVER) | _BV(UART_ENABLE_TRANSMITTER);
 662:stk500boot.c  **** 
 663:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 664:stk500boot.c  **** 
 665:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 666:stk500boot.c  **** //	_delay_ms(50);
 667:stk500boot.c  **** 
 668:stk500boot.c  **** 	sendchar('s');
 669:stk500boot.c  **** 	sendchar('t');
 670:stk500boot.c  **** 	sendchar('k');
 671:stk500boot.c  **** 	sendchar('5');
 672:stk500boot.c  **** 	sendchar('0');
 673:stk500boot.c  **** 	sendchar('0');
 674:stk500boot.c  **** 	sendchar('v');
 675:stk500boot.c  **** 	sendchar('2');
 676:stk500boot.c  **** 	sendchar(0x0d);
 677:stk500boot.c  **** 	sendchar(0x0a);
 678:stk500boot.c  **** #endif
 679:stk500boot.c  **** 
 680:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 681:stk500boot.c  **** 	UART1_STATUS_REG	|=	_BV(UART1_DOUBLE_SPEED);
 682:stk500boot.c  **** 	UART1_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE, F_CPU);
 683:stk500boot.c  **** 	UART1_CONTROL_REG	=	_BV(UART1_ENABLE_TRANSMITTER);
 684:stk500boot.c  **** 
 685:stk500boot.c  **** 	sendchar1('s');
 686:stk500boot.c  **** 	sendchar1('t');
 687:stk500boot.c  **** 	sendchar1('k');
 688:stk500boot.c  **** 	sendchar1('5');
 689:stk500boot.c  **** 	sendchar1('0');
 690:stk500boot.c  **** 	sendchar1('0');
 691:stk500boot.c  **** 	sendchar1('v');
 692:stk500boot.c  **** 	sendchar1('2');
 693:stk500boot.c  **** 	sendchar1(0x0d);
 694:stk500boot.c  **** 	sendchar1(0x0a);
 695:stk500boot.c  **** 
 696:stk500boot.c  **** 	sendchar1(boot_state + 0x30);
 697:stk500boot.c  **** #endif
 698:stk500boot.c  **** 
 699:stk500boot.c  **** 
 700:stk500boot.c  **** 	while (boot_state==0)
 701:stk500boot.c  **** 	{
 702:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 703:stk500boot.c  **** 		{
 704:stk500boot.c  **** 			_delay_ms(0.001);
 705:stk500boot.c  **** 			boot_timer++;
 706:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 707:stk500boot.c  **** 			{
 708:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 709:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 710:stk500boot.c  **** 				sendchar1(boot_state);
 711:stk500boot.c  **** #endif
 712:stk500boot.c  **** 			}
 713:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 714:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 715:stk500boot.c  **** 			{
 716:stk500boot.c  **** 				//*	toggle the LED
 717:stk500boot.c  **** 				PROGLED_PORT	^=	_BV(PROGLED_PIN);	// turn LED ON
 718:stk500boot.c  **** 			}
 719:stk500boot.c  **** 		#endif
 720:stk500boot.c  **** 		}
 721:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 722:stk500boot.c  **** 	}
 723:stk500boot.c  **** 
 724:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 725:stk500boot.c  **** 		sendchar1(boot_state + 0x30);
 726:stk500boot.c  **** #endif
 727:stk500boot.c  **** 
 728:stk500boot.c  **** 	if (boot_state==1)
 729:stk500boot.c  **** 	{
 730:stk500boot.c  **** 		//*	main loop
 731:stk500boot.c  **** 		while (!isLeave)
 732:stk500boot.c  **** 		{
 733:stk500boot.c  **** 			/*
 734:stk500boot.c  **** 			 * Collect received bytes to a complete message
 735:stk500boot.c  **** 			 */
 736:stk500boot.c  **** 			msgParseState	=	ST_START;
 737:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 738:stk500boot.c  **** 			{
 739:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 740:stk500boot.c  **** //				sendchar1(msgParseState + 0x40);
 741:stk500boot.c  **** #endif
 742:stk500boot.c  **** 
 743:stk500boot.c  **** 				if (boot_state==1)
 744:stk500boot.c  **** 				{
 745:stk500boot.c  **** 					boot_state	=	0;
 746:stk500boot.c  **** 					c			=	UART_DATA_REG;
 747:stk500boot.c  **** 				}
 748:stk500boot.c  **** 				else
 749:stk500boot.c  **** 				{
 750:stk500boot.c  **** 				//	c	=	recchar();
 751:stk500boot.c  **** 					c	=	recchar_timeout();
 752:stk500boot.c  **** 
 753:stk500boot.c  **** 				}
 754:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 755:stk500boot.c  **** //				sendchar1(c);
 756:stk500boot.c  **** #endif
 757:stk500boot.c  **** 
 758:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 759:stk500boot.c  **** 				rcvdCharCntr++;
 760:stk500boot.c  **** 
 761:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 762:stk500boot.c  **** 				{
 763:stk500boot.c  **** 					exPointCntr++;
 764:stk500boot.c  **** 					if (exPointCntr == 3)
 765:stk500boot.c  **** 					{
 766:stk500boot.c  **** 						RunMonitor();
 767:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we don't get in an endless loop
 768:stk500boot.c  **** 						isLeave			=	1;
 769:stk500boot.c  **** 						msgParseState	=	99;	//	we don't want it do anything
 770:stk500boot.c  **** 						break;
 771:stk500boot.c  **** 					}
 772:stk500boot.c  **** 				}
 773:stk500boot.c  **** 				else
 774:stk500boot.c  **** 				{
 775:stk500boot.c  **** 					exPointCntr	=	0;
 776:stk500boot.c  **** 				}
 777:stk500boot.c  **** 			#endif
 778:stk500boot.c  **** 
 779:stk500boot.c  **** 				switch (msgParseState)
 780:stk500boot.c  **** 				{
 781:stk500boot.c  **** 					case ST_START:
 782:stk500boot.c  **** 						if ( c == MESSAGE_START )
 783:stk500boot.c  **** 						{
 784:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 785:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 786:stk500boot.c  **** 						}
 787:stk500boot.c  **** 						break;
 788:stk500boot.c  **** 
 789:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 790:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 791:stk500boot.c  **** 						seqNum			=	c;
 792:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 793:stk500boot.c  **** 						checksum		^=	c;
 794:stk500boot.c  **** 					#else
 795:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 796:stk500boot.c  **** 						{
 797:stk500boot.c  **** 							seqNum			=	c;
 798:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 799:stk500boot.c  **** 							checksum		^=	c;
 800:stk500boot.c  **** 						}
 801:stk500boot.c  **** 						else
 802:stk500boot.c  **** 						{
 803:stk500boot.c  **** 							msgParseState	=	ST_START;
 804:stk500boot.c  **** 						}
 805:stk500boot.c  **** 					#endif
 806:stk500boot.c  **** 						break;
 807:stk500boot.c  **** 
 808:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 809:stk500boot.c  **** 						msgLength		=	c<<8;
 810:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 811:stk500boot.c  **** 						checksum		^=	c;
 812:stk500boot.c  **** 						break;
 813:stk500boot.c  **** 
 814:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 815:stk500boot.c  **** 						msgLength		|=	c;
 816:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 817:stk500boot.c  **** 						checksum		^=	c;
 818:stk500boot.c  **** 						break;
 819:stk500boot.c  **** 
 820:stk500boot.c  **** 					case ST_GET_TOKEN:
 821:stk500boot.c  **** 						if ( c == TOKEN )
 822:stk500boot.c  **** 						{
 823:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 824:stk500boot.c  **** 							checksum		^=	c;
 825:stk500boot.c  **** 							ii				=	0;
 826:stk500boot.c  **** 						}
 827:stk500boot.c  **** 						else
 828:stk500boot.c  **** 						{
 829:stk500boot.c  **** 							msgParseState	=	ST_START;
 830:stk500boot.c  **** 						}
 831:stk500boot.c  **** 						break;
 832:stk500boot.c  **** 
 833:stk500boot.c  **** 					case ST_GET_DATA:
 834:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 835:stk500boot.c  **** 						checksum		^=	c;
 836:stk500boot.c  **** 						if (ii == msgLength )
 837:stk500boot.c  **** 						{
 838:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 839:stk500boot.c  **** 						}
 840:stk500boot.c  **** 						break;
 841:stk500boot.c  **** 
 842:stk500boot.c  **** 					case ST_GET_CHECK:
 843:stk500boot.c  **** 						if ( c == checksum )
 844:stk500boot.c  **** 						{
 845:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 846:stk500boot.c  **** 						}
 847:stk500boot.c  **** 						else
 848:stk500boot.c  **** 						{
 849:stk500boot.c  **** 							msgParseState	=	ST_START;
 850:stk500boot.c  **** 						}
 851:stk500boot.c  **** 						break;
 852:stk500boot.c  **** 				}	//	switch
 853:stk500boot.c  **** 			}	//	while(msgParseState)
 854:stk500boot.c  **** 
 855:stk500boot.c  **** 			/*
 856:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 857:stk500boot.c  **** 			 */
 858:stk500boot.c  **** 
 859:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 860:stk500boot.c  **** 			sendchar1(checksum);
 861:stk500boot.c  **** 
 862:stk500boot.c  **** 			sendchar1(msgBuffer[0]);
 863:stk500boot.c  **** 			sendchar1(msgBuffer[1]);
 864:stk500boot.c  **** 			sendchar1(msgBuffer[2]);
 865:stk500boot.c  **** 			sendchar1(msgBuffer[3]);
 866:stk500boot.c  **** 			sendchar1(msgBuffer[4]);
 867:stk500boot.c  **** 			sendchar1(msgBuffer[5]);
 868:stk500boot.c  **** 			sendchar1(msgBuffer[6]);
 869:stk500boot.c  **** 			sendchar1(msgBuffer[7]);
 870:stk500boot.c  **** #endif
 871:stk500boot.c  **** 
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 873:stk500boot.c  **** 			{
 874:stk500boot.c  **** 
 875:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
 876:stk500boot.c  **** 				sendchar1(msgBuffer[0]);
 877:stk500boot.c  **** #endif
 878:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 879:stk500boot.c  **** 				case CMD_SPI_MULTI:
 880:stk500boot.c  **** 					{
 881:stk500boot.c  **** 						uint8_t answerByte;
 882:stk500boot.c  **** 						uint8_t flag=0;
 883:stk500boot.c  **** 
 884:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 885:stk500boot.c  **** 						{
 886:stk500boot.c  **** 							uint8_t signatureIndex	=	msgBuffer[6];
 887:stk500boot.c  **** 
 888:stk500boot.c  **** 							if ( signatureIndex == 0 )
 889:stk500boot.c  **** 							{
 890:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 891:stk500boot.c  **** 							}
 892:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 893:stk500boot.c  **** 							{
 894:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 895:stk500boot.c  **** 							}
 896:stk500boot.c  **** 							else
 897:stk500boot.c  **** 							{
 898:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 899:stk500boot.c  **** 							}
 900:stk500boot.c  **** 						}
 901:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 902:stk500boot.c  **** 						{
 903:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 904:stk500boot.c  **** 						//*	I can't find the docs that say what these are supposed to be but this was figured out by 
 905:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 906:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 907:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 908:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 909:stk500boot.c  **** 							{
 910:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 911:stk500boot.c  **** 							}
 912:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 913:stk500boot.c  **** 							{
 914:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 915:stk500boot.c  **** 							}
 916:stk500boot.c  **** 							else
 917:stk500boot.c  **** 							{
 918:stk500boot.c  **** 								answerByte	=	0;
 919:stk500boot.c  **** 							}
 920:stk500boot.c  **** 						}
 921:stk500boot.c  **** 						else
 922:stk500boot.c  **** 						{
 923:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 924:stk500boot.c  **** 						}
 925:stk500boot.c  **** 						if ( !flag )
 926:stk500boot.c  **** 						{
 927:stk500boot.c  **** 							msgLength		=	7;
 928:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 929:stk500boot.c  **** 							msgBuffer[2]	=	0;
 930:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 931:stk500boot.c  **** 							msgBuffer[4]	=	0;
 932:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 933:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 934:stk500boot.c  **** 						}
 935:stk500boot.c  **** 					}
 936:stk500boot.c  **** 					break;
 937:stk500boot.c  **** 	#endif
 938:stk500boot.c  **** 				case CMD_SIGN_ON:
 939:stk500boot.c  **** 					msgLength		=	11;
 940:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 941:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 942:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 943:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 944:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 945:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 946:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 947:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 948:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 949:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 950:stk500boot.c  **** 					break;
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 953:stk500boot.c  **** 					{
 954:stk500boot.c  **** 						uint8_t value;
 955:stk500boot.c  **** 
 956:stk500boot.c  **** 						switch(msgBuffer[1])
 957:stk500boot.c  **** 						{
 958:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 959:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 960:stk500boot.c  **** 							break;
 961:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 962:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 963:stk500boot.c  **** 							break;
 964:stk500boot.c  **** 						case PARAM_HW_VER:
 965:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 966:stk500boot.c  **** 							break;
 967:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 968:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 969:stk500boot.c  **** 							break;
 970:stk500boot.c  **** 						case PARAM_SW_MINOR:
 971:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 972:stk500boot.c  **** 							break;
 973:stk500boot.c  **** 						default:
 974:stk500boot.c  **** 							value	=	0;
 975:stk500boot.c  **** 							break;
 976:stk500boot.c  **** 						}
 977:stk500boot.c  **** 						msgLength		=	3;
 978:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 979:stk500boot.c  **** 						msgBuffer[2]	=	value;
 980:stk500boot.c  **** 					}
 981:stk500boot.c  **** 					break;
 982:stk500boot.c  **** 
 983:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 984:stk500boot.c  **** 					isLeave	=	1;
 985:stk500boot.c  **** 					//*	fall through
 986:stk500boot.c  **** 
 987:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 988:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 989:stk500boot.c  **** 					msgLength		=	2;
 990:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 991:stk500boot.c  **** 					break;
 992:stk500boot.c  **** 
 993:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 994:stk500boot.c  **** 					{
 995:stk500boot.c  **** 						uint8_t signatureIndex	=	msgBuffer[4];
 996:stk500boot.c  **** 						uint8_t signature;
 997:stk500boot.c  **** 
 998:stk500boot.c  **** 						if ( signatureIndex == 0 )
 999:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
1000:stk500boot.c  **** 						else if ( signatureIndex == 1 )
1001:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
1002:stk500boot.c  **** 						else
1003:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
1004:stk500boot.c  **** 
1005:stk500boot.c  **** 						msgLength		=	4;
1006:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1007:stk500boot.c  **** 						msgBuffer[2]	=	signature;
1008:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1009:stk500boot.c  **** 					}
1010:stk500boot.c  **** 					break;
1011:stk500boot.c  **** 
1012:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
1013:stk500boot.c  **** 					msgLength		=	4;
1014:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1015:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
1016:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
1017:stk500boot.c  **** 					break;
1018:stk500boot.c  **** 
1019:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
1020:stk500boot.c  **** 					{
1021:stk500boot.c  **** 						uint8_t fuseBits;
1022:stk500boot.c  **** 
1023:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
1024:stk500boot.c  **** 						{
1025:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
1026:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
1027:stk500boot.c  **** 							else
1028:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
1029:stk500boot.c  **** 						}
1030:stk500boot.c  **** 						else
1031:stk500boot.c  **** 						{
1032:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
1033:stk500boot.c  **** 						}
1034:stk500boot.c  **** 						msgLength		=	4;
1035:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1036:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
1037:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1038:stk500boot.c  **** 					}
1039:stk500boot.c  **** 					break;
1040:stk500boot.c  **** 
1041:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1042:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
1043:stk500boot.c  **** 					{
1044:stk500boot.c  **** 						uint8_t lockBits	=	msgBuffer[4];
1045:stk500boot.c  **** 
1046:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
1047:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
1048:stk500boot.c  **** 						boot_spm_busy_wait();
1049:stk500boot.c  **** 
1050:stk500boot.c  **** 						msgLength		=	3;
1051:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1052:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
1053:stk500boot.c  **** 					}
1054:stk500boot.c  **** 					break;
1055:stk500boot.c  **** 	#endif
1056:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
1057:stk500boot.c  **** 					eraseAddress	=	0;
1058:stk500boot.c  **** 					msgLength		=	2;
1059:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1060:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	issue 543, return FAILED instead of OK
1061:stk500boot.c  **** 					break;
1062:stk500boot.c  **** 
1063:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
1064:stk500boot.c  **** 	#if defined(RAMPZ)
1065:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1066:stk500boot.c  **** 	#else
1067:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1068:stk500boot.c  **** 	#endif
1069:stk500boot.c  **** 					msgLength		=	2;
1070:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1071:stk500boot.c  **** 					break;
1072:stk500boot.c  **** 
1073:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1074:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1075:stk500boot.c  **** 					{
1076:stk500boot.c  **** 						uint16_t	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1077:stk500boot.c  **** 						uint8_t	*p	=	msgBuffer+10;
1078:stk500boot.c  **** 						uint16_t	data;
1079:stk500boot.c  **** 						uint8_t	highByte, lowByte;
1080:stk500boot.c  **** 						address_t		tempaddress	=	address;
1081:stk500boot.c  **** 
1082:stk500boot.c  **** 
1083:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1084:stk500boot.c  **** 						{
1085:stk500boot.c  **** 							// erase only main section (bootloader protection)
1086:stk500boot.c  **** 							if (eraseAddress < APP_END )
1087:stk500boot.c  **** 							{
1088:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1089:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1090:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1091:stk500boot.c  **** 							}
1092:stk500boot.c  **** 
1093:stk500boot.c  **** 							/* Write FLASH */
1094:stk500boot.c  **** 							do {
1095:stk500boot.c  **** 								lowByte		=	*p++;
1096:stk500boot.c  **** 								highByte 	=	*p++;
1097:stk500boot.c  **** 
1098:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1099:stk500boot.c  **** 								boot_page_fill(address,data);
1100:stk500boot.c  **** 
1101:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1102:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1103:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 							boot_page_write(tempaddress);
1106:stk500boot.c  **** 							boot_spm_busy_wait();
1107:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1108:stk500boot.c  **** 						}
1109:stk500boot.c  **** 						else
1110:stk500boot.c  **** 						{
1111:stk500boot.c  **** 						//*	issue 543, this should work, It has not been tested.
1112:stk500boot.c  **** 					//	#if (!defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)  && !defined(__AVR_ATmega
1113:stk500boot.c  **** 						#if (defined(EEARL) && defined(EEARH)  && defined(EEMWE)  && defined(EEWE)  && defined(EEDR))
1114:stk500boot.c  **** 							/* write EEPROM */
1115:stk500boot.c  **** 							do {
1116:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1117:stk500boot.c  **** 								EEARH	=	(address >> 8);
1118:stk500boot.c  **** 								address++;						// Select next EEPROM byte
1119:stk500boot.c  **** 
1120:stk500boot.c  **** 								EEDR	=	*p++;				// get byte from buffer
1121:stk500boot.c  **** 								EECR	|=	_BV(EEMWE);			// Write data into EEPROM
1122:stk500boot.c  **** 								EECR	|=	_BV(EEWE);
1123:stk500boot.c  **** 
1124:stk500boot.c  **** 								while (EECR & _BV(EEWE));	// Wait for write operation to finish
1125:stk500boot.c  **** 								size--;						// Decrease number of bytes to write
1126:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1127:stk500boot.c  **** 						#endif
1128:stk500boot.c  **** 						}
1129:stk500boot.c  **** 						msgLength		=	2;
1130:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1131:stk500boot.c  **** 					}
1132:stk500boot.c  **** 					break;
1133:stk500boot.c  **** 
1134:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1135:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1136:stk500boot.c  **** 					{
1137:stk500boot.c  **** 						uint16_t	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1138:stk500boot.c  **** 						uint8_t	*p		=	msgBuffer+1;
1139:stk500boot.c  **** 						msgLength				=	size+3;
1140:stk500boot.c  **** 
1141:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1142:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1143:stk500boot.c  **** 						{
1144:stk500boot.c  **** 							uint16_t data;
1145:stk500boot.c  **** 
1146:stk500boot.c  **** 							// Read FLASH
1147:stk500boot.c  **** 							do {
1148:stk500boot.c  **** 						//#if defined(RAMPZ)
1149:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1150:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1151:stk500boot.c  **** 						#else
1152:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1153:stk500boot.c  **** 						#endif
1154:stk500boot.c  **** 								*p++	=	(uint8_t)data;		//LSB
1155:stk500boot.c  **** 								*p++	=	(uint8_t)(data >> 8);	//MSB
1156:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1157:stk500boot.c  **** 								size	-=	2;
1158:stk500boot.c  **** 							}while (size);
1159:stk500boot.c  **** 						}
1160:stk500boot.c  **** 						else
1161:stk500boot.c  **** 						{
1162:stk500boot.c  **** 							/* Read EEPROM */
1163:stk500boot.c  **** 							do {
1164:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1165:stk500boot.c  **** 								EEARH	=	((address >> 8));
1166:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1167:stk500boot.c  **** 								EECR	|=	_BV(EERE);			// Read EEPROM
1168:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1169:stk500boot.c  **** 								size--;
1170:stk500boot.c  **** 							} while (size);
1171:stk500boot.c  **** 						}
1172:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1173:stk500boot.c  **** 					}
1174:stk500boot.c  **** 					break;
1175:stk500boot.c  **** 
1176:stk500boot.c  **** 				default:
1177:stk500boot.c  **** 					msgLength		=	2;
1178:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1179:stk500boot.c  **** 					break;
1180:stk500boot.c  **** 			}
1181:stk500boot.c  **** 
1182:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
1183:stk500boot.c  **** 			sendchar1(msgBuffer[0]);
1184:stk500boot.c  **** 			sendchar1(msgBuffer[1]);
1185:stk500boot.c  **** 			sendchar1(msgBuffer[2]);
1186:stk500boot.c  **** 			sendchar1(msgBuffer[3]);
1187:stk500boot.c  **** 			sendchar1(msgBuffer[4]);
1188:stk500boot.c  **** 			sendchar1(msgBuffer[5]);
1189:stk500boot.c  **** 			sendchar1(msgBuffer[6]);
1190:stk500boot.c  **** 			sendchar1(msgBuffer[7]);
1191:stk500boot.c  **** #endif
1192:stk500boot.c  **** 			/*
1193:stk500boot.c  **** 			 * Now send answer message back
1194:stk500boot.c  **** 			 */
1195:stk500boot.c  **** 			sendchar(MESSAGE_START);
1196:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1197:stk500boot.c  **** 
1198:stk500boot.c  **** 			sendchar(seqNum);
1199:stk500boot.c  **** 			checksum	^=	seqNum;
1200:stk500boot.c  **** 
1201:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1202:stk500boot.c  **** 			sendchar(c);
1203:stk500boot.c  **** 			checksum	^=	c;
1204:stk500boot.c  **** 
1205:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1206:stk500boot.c  **** 			sendchar(c);
1207:stk500boot.c  **** 			checksum ^= c;
1208:stk500boot.c  **** 
1209:stk500boot.c  **** 			sendchar(TOKEN);
1210:stk500boot.c  **** 			checksum ^= TOKEN;
1211:stk500boot.c  **** 
1212:stk500boot.c  **** 			p	=	msgBuffer;
1213:stk500boot.c  **** 			while ( msgLength )
1214:stk500boot.c  **** 			{
1215:stk500boot.c  **** 				c	=	*p++;
1216:stk500boot.c  **** 				sendchar(c);
1217:stk500boot.c  **** 				checksum ^=c;
1218:stk500boot.c  **** 				msgLength--;
1219:stk500boot.c  **** 			}
1220:stk500boot.c  **** 			sendchar(checksum);
1221:stk500boot.c  **** 			seqNum++;
1222:stk500boot.c  **** 
1223:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1224:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1225:stk500boot.c  **** 			PROGLED_PORT	^=	_BV(PROGLED_PIN);	// active high LED ON
1226:stk500boot.c  **** 		#endif
1227:stk500boot.c  **** 
1228:stk500boot.c  **** 		}
1229:stk500boot.c  **** 	}
1230:stk500boot.c  **** 
1231:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1232:stk500boot.c  **** 	//*	this is for debugging it can be removed
1233:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1234:stk500boot.c  **** 	{
1235:stk500boot.c  **** 		PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// turn LED off
1236:stk500boot.c  **** 		_delay_ms(50);
1237:stk500boot.c  **** 		PROGLED_PORT	|=	_BV(PROGLED_PIN);	// turn LED on
1238:stk500boot.c  **** 		_delay_ms(50);
1239:stk500boot.c  **** 	}
1240:stk500boot.c  **** 	PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// turn LED off
1241:stk500boot.c  **** #endif
1242:stk500boot.c  **** 
1243:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
1244:stk500boot.c  **** 	sendchar1('j');
1245:stk500boot.c  **** 	sendchar1('u');
1246:stk500boot.c  **** 	sendchar1('m');
1247:stk500boot.c  **** 	sendchar1('p');
1248:stk500boot.c  **** 	sendchar1(' ');
1249:stk500boot.c  **** 	sendchar1('u');
1250:stk500boot.c  **** 	sendchar1('s');
1251:stk500boot.c  **** 	sendchar1('r');
1252:stk500boot.c  **** 	sendchar1(0x0d);
1253:stk500boot.c  **** 	sendchar1(0x0a);
1254:stk500boot.c  **** #endif
1255:stk500boot.c  **** 
1256:stk500boot.c  **** 
1257:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1258:stk500boot.c  **** 	PROGLED_DDR		&=	~_BV(PROGLED_PIN);	// set to default
1259:stk500boot.c  **** 	PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// active low LED OFF
1260:stk500boot.c  **** //	PROGLED_PORT	|=	_BV(PROGLED_PIN);	// active high LED OFF
1261:stk500boot.c  **** 	_delay_ms(50);							// delay after exit
1262:stk500boot.c  **** #endif
1263:stk500boot.c  **** 
1264:stk500boot.c  **** 
1265:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1266:stk500boot.c  **** 
1267:stk500boot.c  **** 	/*
1268:stk500boot.c  **** 	 * Now leave bootloader
1269:stk500boot.c  **** 	 */
1270:stk500boot.c  **** 
1271:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1272:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1273:stk500boot.c  **** 
1274:stk500boot.c  **** 
1275:stk500boot.c  **** 	asm volatile(
1276:stk500boot.c  **** 			"clr	r30		\n\t"
1277:stk500boot.c  **** 			"clr	r31		\n\t"
1278:stk500boot.c  **** 			"ijmp	\n\t"
1279:stk500boot.c  **** 			);
1280:stk500boot.c  **** 
1281:stk500boot.c  **** }
1282:stk500boot.c  **** 
1283:stk500boot.c  **** /*
1284:stk500boot.c  **** base address = f800
1285:stk500boot.c  **** 
1286:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1287:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1288:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1289:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1290:stk500boot.c  **** avrdude>
1291:stk500boot.c  **** 
1292:stk500boot.c  **** 
1293:stk500boot.c  **** base address = f000
1294:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1295:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1296:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1297:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1298:stk500boot.c  **** avrdude>
1299:stk500boot.c  **** */
1300:stk500boot.c  **** 
1301:stk500boot.c  **** //************************************************************************
1302:stk500boot.c  **** #ifdef ENABLE_MONITOR
1303:stk500boot.c  **** #include	<math.h>
1304:stk500boot.c  **** 
1305:stk500boot.c  **** uint32_t	gRamIndex;
1306:stk500boot.c  **** uint32_t	gFlashIndex;
1307:stk500boot.c  **** uint32_t	gEepromIndex;
1308:stk500boot.c  **** 
1309:stk500boot.c  **** 
1310:stk500boot.c  **** #define	true	1
1311:stk500boot.c  **** #define	false	0
1312:stk500boot.c  **** 
1313:stk500boot.c  **** #include	"avr_cpunames.h"
1314:stk500boot.c  **** 
1315:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1316:stk500boot.c  **** 	#error cpu name not defined
1317:stk500boot.c  **** #endif
1318:stk500boot.c  **** 
1319:stk500boot.c  **** #ifdef _VECTORS_SIZE
1320:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1321:stk500boot.c  **** #else
1322:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1323:stk500boot.c  **** #endif
1324:stk500boot.c  **** 
1325:stk500boot.c  **** 
1326:stk500boot.c  **** void	PrintDecInt(int16_t theNumber, int16_t digitCnt);
1327:stk500boot.c  **** 
1328:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1329:stk500boot.c  **** 	const uint8_t	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1330:stk500boot.c  **** #else
1331:stk500boot.c  **** 	const uint8_t	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1332:stk500boot.c  **** #endif
1333:stk500boot.c  **** 
1334:stk500boot.c  **** 	const uint8_t	gTextMsg_Explorer[]			PROGMEM	=	"Wildfire explorer stk500v2";
1335:stk500boot.c  **** 	const uint8_t	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1336:stk500boot.c  **** 	const uint8_t	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1337:stk500boot.c  **** 	const uint8_t	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1338:stk500boot.c  **** 	const uint8_t	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1339:stk500boot.c  **** 	const uint8_t	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1340:stk500boot.c  **** 	const uint8_t	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1341:stk500boot.c  **** 	const uint8_t	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1342:stk500boot.c  **** 	const uint8_t	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1343:stk500boot.c  **** 	const uint8_t	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1344:stk500boot.c  **** 	const uint8_t	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1345:stk500boot.c  **** 	const uint8_t	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1346:stk500boot.c  **** 	const uint8_t	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1347:stk500boot.c  **** 	const uint8_t	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1348:stk500boot.c  **** 	const uint8_t	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1349:stk500boot.c  **** 	const uint8_t	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1350:stk500boot.c  **** 	const uint8_t	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Inter
1351:stk500boot.c  **** 	const uint8_t	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1352:stk500boot.c  **** 	const uint8_t	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1353:stk500boot.c  **** 	const uint8_t	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1354:stk500boot.c  **** 	const uint8_t	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1355:stk500boot.c  **** 	const uint8_t	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1356:stk500boot.c  **** 	const uint8_t	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1357:stk500boot.c  **** 	const uint8_t	gTextMsg_SPACE[]			PROGMEM	=	" ";
1358:stk500boot.c  **** 	const uint8_t	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writing EE";
1359:stk500boot.c  **** 	const uint8_t	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1360:stk500boot.c  **** 	const uint8_t	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1361:stk500boot.c  **** 	const uint8_t	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1362:stk500boot.c  **** 
1363:stk500boot.c  **** 
1364:stk500boot.c  **** //************************************************************************
1365:stk500boot.c  **** //*	Help messages
1366:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1367:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1368:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1369:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1370:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1371:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1372:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1373:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1374:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1375:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1376:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1377:stk500boot.c  **** 	const uint8_t	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1378:stk500boot.c  **** 
1379:stk500boot.c  **** 	const uint8_t	gTextMsg_END[]				PROGMEM	=	"*";
1380:stk500boot.c  **** 
1381:stk500boot.c  **** 
1382:stk500boot.c  **** //************************************************************************
1383:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, uint8_t offset)
1384:stk500boot.c  **** {
 164               	.LM10:
 165               	.LFBB2:
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
1385:stk500boot.c  **** 	uint8_t	theChar;
1386:stk500boot.c  **** 
1387:stk500boot.c  **** 	dataPtr    +=  offset;
 171               	.LM11:
 172 0000 9C01      		movw r18,r24
 173 0002 260F      		add r18,r22
 174 0004 311D      		adc r19,__zero_reg__
 175               	.LBB189:
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 	do {
1390:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1391:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint32_t)dataPtr++);
 177               	.LM12:
 178 0006 C901      		movw r24,r18
 179 0008 AA27      		clr r26
 180 000a 97FD      		sbrc r25,7
 181 000c A095      		com r26
 182 000e BA2F      		mov r27,r26
 183               	/* #APP */
 184               	 ;  1391 "stk500boot.c" 1
 185 0010 ABBF      		out 59, r26
 186 0012 FC01      		movw r30, r24
 187 0014 8791      		elpm r24, Z+
 188               		
 189               	 ;  0 "" 2
 190               	/* #NOAPP */
 191               	.LBE189:
1392:stk500boot.c  **** 	#else
1393:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1394:stk500boot.c  **** 	#endif
1395:stk500boot.c  **** 		if (theChar != 0)
 193               	.LM13:
 194 0016 8823      		tst r24
 195 0018 01F0      		breq .L2
 196               	.L7:
 197               	.LBB190:
1391:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint32_t)dataPtr++);
 199               	.LM14:
 200 001a 2F5F      		subi r18,lo8(-(1))
 201 001c 3F4F      		sbci r19,hi8(-(1))
 202               	.LBE190:
 203               	.LBB191:
 204               	.LBB192:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 206               	.LM15:
 207 001e 8093 C600 		sts 198,r24
 208               	.L4:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 210               	.LM16:
 211 0022 8091 C000 		lds r24,192
 212 0026 86FF      		sbrs r24,6
 213 0028 00C0      		rjmp .L4
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 215               	.LM17:
 216 002a 8091 C000 		lds r24,192
 217 002e 8064      		ori r24,lo8(64)
 218 0030 8093 C000 		sts 192,r24
 219               	.LBE192:
 220               	.LBE191:
 221               	.LBB193:
1391:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint32_t)dataPtr++);
 223               	.LM18:
 224 0034 C901      		movw r24,r18
 225 0036 AA27      		clr r26
 226 0038 97FD      		sbrc r25,7
 227 003a A095      		com r26
 228 003c BA2F      		mov r27,r26
 229               	/* #APP */
 230               	 ;  1391 "stk500boot.c" 1
 231 003e ABBF      		out 59, r26
 232 0040 FC01      		movw r30, r24
 233 0042 8791      		elpm r24, Z+
 234               		
 235               	 ;  0 "" 2
 236               	/* #NOAPP */
 237               	.LBE193:
 239               	.LM19:
 240 0044 8823      		tst r24
 241 0046 01F4      		brne .L7
 242               	.L2:
 243 0048 0895      		ret
 254               	.Lscope2:
 256               	.global	PrintNewLine
 258               	PrintNewLine:
1396:stk500boot.c  **** 		{
1397:stk500boot.c  **** 			sendchar(theChar);
1398:stk500boot.c  **** 		}
1399:stk500boot.c  **** 
1400:stk500boot.c  **** 	} while (theChar != 0);
1401:stk500boot.c  **** }
1402:stk500boot.c  **** 
1403:stk500boot.c  **** //************************************************************************
1404:stk500boot.c  **** void	PrintNewLine(void)
1405:stk500boot.c  **** {
 260               	.LM20:
 261               	.LFBB3:
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 266               	.LBB194:
 267               	.LBB195:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 269               	.LM21:
 270 004a 8DE0      		ldi r24,lo8(13)
 271 004c 8093 C600 		sts 198,r24
 272               	.L10:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 274               	.LM22:
 275 0050 2091 C000 		lds r18,192
 276 0054 26FF      		sbrs r18,6
 277 0056 00C0      		rjmp .L10
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 279               	.LM23:
 280 0058 4091 C000 		lds r20,192
 281 005c 4064      		ori r20,lo8(64)
 282 005e 4093 C000 		sts 192,r20
 283               	.LBE195:
 284               	.LBE194:
 285               	.LBB196:
 286               	.LBB197:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 288               	.LM24:
 289 0062 3AE0      		ldi r19,lo8(10)
 290 0064 3093 C600 		sts 198,r19
 291               	.L11:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 293               	.LM25:
 294 0068 5091 C000 		lds r21,192
 295 006c 56FF      		sbrs r21,6
 296 006e 00C0      		rjmp .L11
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 298               	.LM26:
 299 0070 6091 C000 		lds r22,192
 300 0074 6064      		ori r22,lo8(64)
 301 0076 6093 C000 		sts 192,r22
 302               	/* epilogue start */
 303               	.LBE197:
 304               	.LBE196:
1406:stk500boot.c  **** 	sendchar(0x0d);
1407:stk500boot.c  **** 	sendchar(0x0a);
1408:stk500boot.c  **** }
 306               	.LM27:
 307 007a 0895      		ret
 309               	.Lscope3:
 313               	PrintAvailablePort:
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 
1411:stk500boot.c  **** //************************************************************************
1412:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, uint8_t offset)
1413:stk500boot.c  **** {
1414:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1415:stk500boot.c  **** 
1416:stk500boot.c  **** 	PrintNewLine();
1417:stk500boot.c  **** }
1418:stk500boot.c  **** 
1419:stk500boot.c  **** 
1420:stk500boot.c  **** //************************************************************************
1421:stk500boot.c  **** void	PrintString(uint8_t* textString)
1422:stk500boot.c  **** {
1423:stk500boot.c  **** uint8_t	theChar;
1424:stk500boot.c  **** uint16_t ii = 0;
1425:stk500boot.c  **** 
1426:stk500boot.c  **** 	do{
1427:stk500boot.c  **** 		theChar	=	textString[ii++];
1428:stk500boot.c  **** 		if (theChar != 0)
1429:stk500boot.c  **** 		{
1430:stk500boot.c  **** 			sendchar(theChar);
1431:stk500boot.c  **** 		}
1432:stk500boot.c  **** 	} while (theChar != 0);
1433:stk500boot.c  **** }
1434:stk500boot.c  **** 
1435:stk500boot.c  **** //************************************************************************
1436:stk500boot.c  **** void	PrintHexByte(uint8_t theByte)
1437:stk500boot.c  **** {
1438:stk500boot.c  **** uint8_t	theChar;
1439:stk500boot.c  **** 
1440:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1441:stk500boot.c  **** 	if (theChar > 0x39)
1442:stk500boot.c  **** 	{
1443:stk500boot.c  **** 		theChar	+=	7;
1444:stk500boot.c  **** 	}
1445:stk500boot.c  **** 	sendchar(theChar );
1446:stk500boot.c  **** 
1447:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1448:stk500boot.c  **** 	if (theChar > 0x39)
1449:stk500boot.c  **** 	{
1450:stk500boot.c  **** 		theChar	+=	7;
1451:stk500boot.c  **** 	}
1452:stk500boot.c  **** 	sendchar(theChar );
1453:stk500boot.c  **** }
1454:stk500boot.c  **** 
1455:stk500boot.c  **** //************************************************************************
1456:stk500boot.c  **** void	PrintDecInt(int16_t theNumber, int16_t digitCnt)
1457:stk500boot.c  **** {
1458:stk500boot.c  **** uint8_t	theChar;
1459:stk500boot.c  **** int16_t	myNumber;
1460:stk500boot.c  **** 
1461:stk500boot.c  **** 	myNumber	=	theNumber;
1462:stk500boot.c  **** 
1463:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1464:stk500boot.c  **** 	{
1465:stk500boot.c  **** 		theChar		=	(uint8_t)(0x30 + myNumber / 100);
1466:stk500boot.c  **** 		sendchar(theChar );
1467:stk500boot.c  **** 	}
1468:stk500boot.c  **** 
1469:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1470:stk500boot.c  **** 	{
1471:stk500boot.c  **** 		theChar	=	(uint8_t)(0x30  + ((myNumber % 100) / 10 ));
1472:stk500boot.c  **** 		sendchar(theChar );
1473:stk500boot.c  **** 	}
1474:stk500boot.c  **** 	theChar	=	(uint8_t)(0x30 + (myNumber % 10));
1475:stk500boot.c  **** 	sendchar(theChar );
1476:stk500boot.c  **** }
1477:stk500boot.c  **** 
1478:stk500boot.c  **** 
1479:stk500boot.c  **** 
1480:stk500boot.c  **** 
1481:stk500boot.c  **** //************************************************************************
1482:stk500boot.c  **** static void	PrintCPUstats(void)
1483:stk500boot.c  **** {
1484:stk500boot.c  **** uint8_t fuseByte;
1485:stk500boot.c  **** 
1486:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1487:stk500boot.c  **** 
1488:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1489:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1490:stk500boot.c  **** 
1491:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1492:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1493:stk500boot.c  **** 
1494:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1495:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1496:stk500boot.c  **** 	PrintNewLine();
1497:stk500boot.c  **** 
1498:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1499:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1500:stk500boot.c  **** 
1501:stk500boot.c  **** 	//*	these can be found in avr/version.h
1502:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1503:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1504:stk500boot.c  **** 
1505:stk500boot.c  **** #if defined(SIGNATURE_0)
1506:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1507:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1508:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1509:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1510:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1511:stk500boot.c  **** 	PrintNewLine();
1512:stk500boot.c  **** #endif
1513:stk500boot.c  **** 
1514:stk500boot.c  **** 
1515:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1516:stk500boot.c  **** 	//*	fuse settings
1517:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1518:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1519:stk500boot.c  **** 	PrintHexByte(fuseByte);
1520:stk500boot.c  **** 	PrintNewLine();
1521:stk500boot.c  **** 
1522:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1523:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1524:stk500boot.c  **** 	PrintHexByte(fuseByte);
1525:stk500boot.c  **** 	PrintNewLine();
1526:stk500boot.c  **** 
1527:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1528:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1529:stk500boot.c  **** 	PrintHexByte(fuseByte);
1530:stk500boot.c  **** 	PrintNewLine();
1531:stk500boot.c  **** 
1532:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1533:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1534:stk500boot.c  **** 	PrintHexByte(fuseByte);
1535:stk500boot.c  **** 	PrintNewLine();
1536:stk500boot.c  **** 
1537:stk500boot.c  **** #endif
1538:stk500boot.c  **** 
1539:stk500boot.c  **** }
1540:stk500boot.c  **** 
1541:stk500boot.c  **** 
1542:stk500boot.c  **** //************************************************************************
1543:stk500boot.c  **** static void BlinkLED(void)
1544:stk500boot.c  **** {
1545:stk500boot.c  **** 	PROGLED_DDR		|=	_BV(PROGLED_PIN);
1546:stk500boot.c  **** 	PROGLED_PORT	|=	_BV(PROGLED_PIN);	// active high LED ON
1547:stk500boot.c  **** 
1548:stk500boot.c  **** 	while (!Serial_Available())
1549:stk500boot.c  **** 	{
1550:stk500boot.c  **** 		PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// turn LED off
1551:stk500boot.c  **** 		_delay_ms(100);
1552:stk500boot.c  **** 		PROGLED_PORT	|=	_BV(PROGLED_PIN);	// turn LED on
1553:stk500boot.c  **** 		_delay_ms(100);
1554:stk500boot.c  **** 	}
1555:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1556:stk500boot.c  **** }
1557:stk500boot.c  **** 
1558:stk500boot.c  **** enum
1559:stk500boot.c  **** {
1560:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1561:stk500boot.c  **** 	kDUMP_EEPROM,
1562:stk500boot.c  **** 	kDUMP_RAM
1563:stk500boot.c  **** };
1564:stk500boot.c  **** 
1565:stk500boot.c  **** //************************************************************************
1566:stk500boot.c  **** static void	DumpHex(uint8_t dumpWhat, uint32_t startAddress, uint8_t numRows)
1567:stk500boot.c  **** {
1568:stk500boot.c  **** 	uint32_t myAddressPointer;
1569:stk500boot.c  **** 	uint8_t	theValue;
1570:stk500boot.c  **** 	uint8_t	asciiDump[18];
1571:stk500boot.c  **** 	uint8_t	*ramPtr;
1572:stk500boot.c  **** 
1573:stk500boot.c  **** 
1574:stk500boot.c  **** 	ramPtr				=	0;
1575:stk500boot.c  **** 	theValue			=	0;
1576:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1577:stk500boot.c  **** 	while (numRows > 0)
1578:stk500boot.c  **** 	{
1579:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1580:stk500boot.c  **** 		{
1581:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1582:stk500boot.c  **** 		}
1583:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1584:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1585:stk500boot.c  **** 		sendchar(0x20);
1586:stk500boot.c  **** 		sendchar('-');
1587:stk500boot.c  **** 		sendchar(0x20);
1588:stk500boot.c  **** 
1589:stk500boot.c  **** 		asciiDump[0]		=	0;
1590:stk500boot.c  **** 		for (uint8_t ii=0; ii<16; ii++)
1591:stk500boot.c  **** 		{
1592:stk500boot.c  **** 			switch(dumpWhat)
1593:stk500boot.c  **** 			{
1594:stk500boot.c  **** 				case kDUMP_FLASH:
1595:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1596:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1597:stk500boot.c  **** 				#else
1598:stk500boot.c  **** 					theValue	=	pgm_read_byte_near((uint16_t)myAddressPointer);
1599:stk500boot.c  **** 				#endif
1600:stk500boot.c  **** 					break;
1601:stk500boot.c  **** 
1602:stk500boot.c  **** 				case kDUMP_EEPROM:
1603:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1604:stk500boot.c  **** 					break;
1605:stk500boot.c  **** 
1606:stk500boot.c  **** 				case kDUMP_RAM:
1607:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1608:stk500boot.c  **** 					break;
1609:stk500boot.c  **** 
1610:stk500boot.c  **** 			}
1611:stk500boot.c  **** 			PrintHexByte(theValue);
1612:stk500boot.c  **** 			sendchar(0x20);
1613:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1614:stk500boot.c  **** 			{
1615:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1616:stk500boot.c  **** 			}
1617:stk500boot.c  **** 			else
1618:stk500boot.c  **** 			{
1619:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1620:stk500boot.c  **** 			}
1621:stk500boot.c  **** 
1622:stk500boot.c  **** 			myAddressPointer++;
1623:stk500boot.c  **** 		}
1624:stk500boot.c  **** 		asciiDump[16]	=	0;
1625:stk500boot.c  **** 		PrintString(asciiDump);
1626:stk500boot.c  **** 		PrintNewLine();
1627:stk500boot.c  **** 
1628:stk500boot.c  **** 		numRows--;
1629:stk500boot.c  **** 	}
1630:stk500boot.c  **** }
1631:stk500boot.c  **** 
1632:stk500boot.c  **** 
1633:stk500boot.c  **** 
1634:stk500boot.c  **** //************************************************************************
1635:stk500boot.c  **** static void	EEPROMtest(void)
1636:stk500boot.c  **** {
1637:stk500boot.c  **** uint16_t ii;
1638:stk500boot.c  **** uint8_t theChar;
1639:stk500boot.c  **** uint8_t	theEEPROMchar;
1640:stk500boot.c  **** uint16_t errorCount;
1641:stk500boot.c  **** 
1642:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1643:stk500boot.c  **** 	PrintNewLine();
1644:stk500boot.c  **** 	ii			=	0;
1645:stk500boot.c  **** #if (FLASHEND > 0x10000)
1646:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
1647:stk500boot.c  **** #else
1648:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
1649:stk500boot.c  **** #endif
1650:stk500boot.c  **** 	{
1651:stk500boot.c  **** 		eeprom_busy_wait();
1652:stk500boot.c  **** 		eeprom_update_byte((uint8_t *)ii, theChar);
1653:stk500boot.c  **** 		if (theChar == 0)
1654:stk500boot.c  **** 		{
1655:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1656:stk500boot.c  **** 		}
1657:stk500boot.c  **** 		else
1658:stk500boot.c  **** 		{
1659:stk500boot.c  **** 			sendchar(theChar);
1660:stk500boot.c  **** 		}
1661:stk500boot.c  **** 		ii++;
1662:stk500boot.c  **** 	}
1663:stk500boot.c  **** 
1664:stk500boot.c  **** 	//*	now go back through and test
1665:stk500boot.c  **** 	PrintNewLine();
1666:stk500boot.c  **** 	PrintNewLine();
1667:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1668:stk500boot.c  **** 	PrintNewLine();
1669:stk500boot.c  **** 	errorCount	=	0;
1670:stk500boot.c  **** 	ii			=	0;
1671:stk500boot.c  **** #if (FLASHEND > 0x10000)
1672:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
1673:stk500boot.c  **** #else
1674:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
1675:stk500boot.c  **** #endif
1676:stk500boot.c  **** 	{
1677:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((const uint8_t *)ii);
1678:stk500boot.c  **** 		if (theEEPROMchar == 0)
1679:stk500boot.c  **** 		{
1680:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1681:stk500boot.c  **** 		}
1682:stk500boot.c  **** 		else
1683:stk500boot.c  **** 		{
1684:stk500boot.c  **** 			sendchar(theEEPROMchar);
1685:stk500boot.c  **** 		}
1686:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1687:stk500boot.c  **** 		{
1688:stk500boot.c  **** 			errorCount++;
1689:stk500boot.c  **** 		}
1690:stk500boot.c  **** 		ii++;
1691:stk500boot.c  **** 	}
1692:stk500boot.c  **** 	PrintNewLine();
1693:stk500boot.c  **** 	PrintNewLine();
1694:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1695:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1696:stk500boot.c  **** 	PrintNewLine();
1697:stk500boot.c  **** 	PrintNewLine();
1698:stk500boot.c  **** 
1699:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1700:stk500boot.c  **** 
1701:stk500boot.c  **** }
1702:stk500boot.c  **** 
1703:stk500boot.c  **** 
1704:stk500boot.c  **** 
1705:stk500boot.c  **** #if (FLASHEND > 0x08000)
1706:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough
1707:stk500boot.c  **** //*	memory to include this
1708:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1709:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1710:stk500boot.c  **** //		#warning Interrupt vectors not defined
1711:stk500boot.c  **** //	#endif
1712:stk500boot.c  **** #endif
1713:stk500boot.c  **** 
1714:stk500boot.c  **** //************************************************************************
1715:stk500boot.c  **** static void	VectorDisplay(void)
1716:stk500boot.c  **** {
1717:stk500boot.c  **** 	uint32_t	byte1;
1718:stk500boot.c  **** 	uint32_t	byte2;
1719:stk500boot.c  **** 	uint32_t	byte3;
1720:stk500boot.c  **** 	uint32_t	byte4;
1721:stk500boot.c  **** 	uint32_t	word1;
1722:stk500boot.c  **** 	uint32_t	word2;
1723:stk500boot.c  **** 	uint16_t	vectorIndex;
1724:stk500boot.c  **** 	uint32_t	myMemoryPtr;
1725:stk500boot.c  **** 	uint32_t	wordMemoryAddress;
1726:stk500boot.c  **** 	uint32_t	relativeAddr;
1727:stk500boot.c  **** 	uint32_t	myFullAddress;
1728:stk500boot.c  **** 	uint32_t	absoluteAddr;
1729:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1730:stk500boot.c  **** 	uint16_t	stringPointer;
1731:stk500boot.c  **** #endif
1732:stk500boot.c  **** 
1733:stk500boot.c  **** 	myMemoryPtr		=	0;
1734:stk500boot.c  **** 	vectorIndex		=	0;
1735:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1736:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1737:stk500boot.c  **** 	//					 V#   ADDR   op code
1738:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1739:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1740:stk500boot.c  **** 	{
1741:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1742:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1743:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1744:stk500boot.c  **** 		sendchar(0x20);
1745:stk500boot.c  **** 		sendchar('-');
1746:stk500boot.c  **** 		sendchar(0x20);
1747:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1748:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1749:stk500boot.c  **** 		sendchar(0x20);
1750:stk500boot.c  **** 		sendchar('=');
1751:stk500boot.c  **** 		sendchar(0x20);
1752:stk500boot.c  **** 
1753:stk500boot.c  **** 
1754:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1755:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1756:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1757:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1758:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1759:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1760:stk500boot.c  **** 	#else
1761:stk500boot.c  **** 		byte1	=	pgm_read_byte_near((uint16_t)myMemoryPtr++);
1762:stk500boot.c  **** 		byte2	=	pgm_read_byte_near((uint16_t)myMemoryPtr++);
1763:stk500boot.c  **** 		byte3	=	pgm_read_byte_near((uint16_t)myMemoryPtr++);
1764:stk500boot.c  **** 		byte4	=	pgm_read_byte_near((uint16_t)myMemoryPtr++);
1765:stk500boot.c  **** 	#endif
1766:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1767:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1768:stk500boot.c  **** 
1769:stk500boot.c  **** 
1770:stk500boot.c  **** 		PrintHexByte(byte2);
1771:stk500boot.c  **** 		sendchar(0x20);
1772:stk500boot.c  **** 		PrintHexByte(byte1);
1773:stk500boot.c  **** 		sendchar(0x20);
1774:stk500boot.c  **** 		PrintHexByte(byte4);
1775:stk500boot.c  **** 		sendchar(0x20);
1776:stk500boot.c  **** 		PrintHexByte(byte3);
1777:stk500boot.c  **** 		sendchar(0x20);
1778:stk500boot.c  **** 
1779:stk500boot.c  **** 		if (word1 == 0xffff)
1780:stk500boot.c  **** 		{
1781:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1782:stk500boot.c  **** 		}
1783:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1784:stk500boot.c  **** 		{
1785:stk500boot.c  **** 			//*	rjmp instruction
1786:stk500boot.c  **** 			relativeAddr	=	word1 & 0x3FFF;
1787:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + relativeAddr;	//*	add the offset to the current address
1788:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1789:stk500boot.c  **** 
1790:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1791:stk500boot.c  **** 			PrintHexByte((relativeAddr >> 8) & 0x00ff);
1792:stk500boot.c  **** 			PrintHexByte((relativeAddr) & 0x00ff);
1793:stk500boot.c  **** 			sendchar(0x20);
1794:stk500boot.c  **** 			sendchar('>');
1795:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1796:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1797:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1798:stk500boot.c  **** 
1799:stk500boot.c  **** 		}
1800:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1801:stk500boot.c  **** 		{
1802:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1803:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1804:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1805:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1806:stk500boot.c  **** 								word2;
1807:stk500boot.c  **** 
1808:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1809:stk500boot.c  **** 
1810:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1811:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1812:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1813:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1814:stk500boot.c  **** 			sendchar(0x20);
1815:stk500boot.c  **** 			sendchar('>');
1816:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1817:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1818:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1819:stk500boot.c  **** 		}
1820:stk500boot.c  **** 
1821:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1822:stk500boot.c  **** 		sendchar(0x20);
1823:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1824:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1825:stk500boot.c  **** 	#else
1826:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1827:stk500boot.c  **** 	#endif
1828:stk500boot.c  **** 		PrintFromPROGMEM((void *)stringPointer, 0);
1829:stk500boot.c  **** 	#endif
1830:stk500boot.c  **** 		PrintNewLine();
1831:stk500boot.c  **** 
1832:stk500boot.c  **** 		vectorIndex++;
1833:stk500boot.c  **** 	}
1834:stk500boot.c  **** }
1835:stk500boot.c  **** 
1836:stk500boot.c  **** //************************************************************************
1837:stk500boot.c  **** static void	PrintAvailablePort(uint8_t thePortLetter)
1838:stk500boot.c  **** {
 315               	.LM28:
 316               	.LFBB4:
 317 007c 1F93      		push r17
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 1 */
 321               	.L__stack_usage = 1
 322 007e 182F      		mov r17,r24
1839:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 324               	.LM29:
 325 0080 80E0      		ldi r24,lo8(gTextMsg_PORT)
 326 0082 90E0      		ldi r25,hi8(gTextMsg_PORT)
 327 0084 60E0      		ldi r22,lo8(0)
 328 0086 0E94 0000 		call PrintFromPROGMEM
 329               	.LBB198:
 330               	.LBB199:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 332               	.LM30:
 333 008a 1093 C600 		sts 198,r17
 334               	.L15:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 336               	.LM31:
 337 008e 8091 C000 		lds r24,192
 338 0092 86FF      		sbrs r24,6
 339 0094 00C0      		rjmp .L15
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 341               	.LM32:
 342 0096 2091 C000 		lds r18,192
 343 009a 2064      		ori r18,lo8(64)
 344 009c 2093 C000 		sts 192,r18
 345               	.LBE199:
 346               	.LBE198:
1840:stk500boot.c  **** 	sendchar(thePortLetter);
1841:stk500boot.c  **** 	PrintNewLine();
 348               	.LM33:
 349 00a0 0E94 0000 		call PrintNewLine
 350               	/* epilogue start */
1842:stk500boot.c  **** }
 352               	.LM34:
 353 00a4 1F91      		pop r17
 354 00a6 0895      		ret
 356               	.Lscope4:
 360               	.global	PrintFromPROGMEMln
 362               	PrintFromPROGMEMln:
1413:stk500boot.c  **** {
 364               	.LM35:
 365               	.LFBB5:
 366               	/* prologue: function */
 367               	/* frame size = 0 */
 368               	/* stack size = 0 */
 369               	.L__stack_usage = 0
1414:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 371               	.LM36:
 372 00a8 0E94 0000 		call PrintFromPROGMEM
1416:stk500boot.c  **** 	PrintNewLine();
 374               	.LM37:
 375 00ac 0E94 0000 		call PrintNewLine
 376               	/* epilogue start */
1417:stk500boot.c  **** }
 378               	.LM38:
 379 00b0 0895      		ret
 381               	.Lscope5:
 384               	.global	PrintString
 386               	PrintString:
1422:stk500boot.c  **** {
 388               	.LM39:
 389               	.LFBB6:
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 0 */
 393               	.L__stack_usage = 0
 394 00b2 FC01      		movw r30,r24
1427:stk500boot.c  **** 		theChar	=	textString[ii++];
 396               	.LM40:
 397 00b4 8081      		ld r24,Z
1428:stk500boot.c  **** 		if (theChar != 0)
 399               	.LM41:
 400 00b6 8823      		tst r24
 401 00b8 01F0      		breq .L18
1421:stk500boot.c  **** void	PrintString(uint8_t* textString)
 403               	.LM42:
 404 00ba 3196      		adiw r30,1
 405               	.L21:
 406               	.LBB200:
 407               	.LBB201:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 409               	.LM43:
 410 00bc 8093 C600 		sts 198,r24
 411               	.L20:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 413               	.LM44:
 414 00c0 8091 C000 		lds r24,192
 415 00c4 86FF      		sbrs r24,6
 416 00c6 00C0      		rjmp .L20
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 418               	.LM45:
 419 00c8 2091 C000 		lds r18,192
 420 00cc 2064      		ori r18,lo8(64)
 421 00ce 2093 C000 		sts 192,r18
 422               	.LBE201:
 423               	.LBE200:
1427:stk500boot.c  **** 		theChar	=	textString[ii++];
 425               	.LM46:
 426 00d2 8191      		ld r24,Z+
1428:stk500boot.c  **** 		if (theChar != 0)
 428               	.LM47:
 429 00d4 8823      		tst r24
 430 00d6 01F4      		brne .L21
 431               	.L18:
 432 00d8 0895      		ret
 437               	.Lscope6:
 440               	.global	PrintHexByte
 442               	PrintHexByte:
1437:stk500boot.c  **** {
 444               	.LM48:
 445               	.LFBB7:
 446               	/* prologue: function */
 447               	/* frame size = 0 */
 448               	/* stack size = 0 */
 449               	.L__stack_usage = 0
1440:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
 451               	.LM49:
 452 00da 282F      		mov r18,r24
 453 00dc 2295      		swap r18
 454 00de 2F70      		andi r18,lo8(15)
 455 00e0 922F      		mov r25,r18
 456 00e2 905D      		subi r25,lo8(-(48))
1441:stk500boot.c  **** 	if (theChar > 0x39)
 458               	.LM50:
 459 00e4 9A33      		cpi r25,lo8(58)
 460 00e6 00F0      		brlo .L25
1443:stk500boot.c  **** 		theChar	+=	7;
 462               	.LM51:
 463 00e8 995F      		subi r25,lo8(-(7))
 464               	.L25:
 465               	.LBB202:
 466               	.LBB203:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 468               	.LM52:
 469 00ea 9093 C600 		sts 198,r25
 470               	.L26:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 472               	.LM53:
 473 00ee 9091 C000 		lds r25,192
 474 00f2 96FF      		sbrs r25,6
 475 00f4 00C0      		rjmp .L26
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 477               	.LM54:
 478 00f6 3091 C000 		lds r19,192
 479 00fa 3064      		ori r19,lo8(64)
 480 00fc 3093 C000 		sts 192,r19
 481               	.LBE203:
 482               	.LBE202:
1447:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
 484               	.LM55:
 485 0100 8F70      		andi r24,lo8(15)
 486 0102 982F      		mov r25,r24
 487 0104 905D      		subi r25,lo8(-(48))
1448:stk500boot.c  **** 	if (theChar > 0x39)
 489               	.LM56:
 490 0106 9A33      		cpi r25,lo8(58)
 491 0108 00F0      		brlo .L27
1450:stk500boot.c  **** 		theChar	+=	7;
 493               	.LM57:
 494 010a 995F      		subi r25,lo8(-(7))
 495               	.L27:
 496               	.LBB204:
 497               	.LBB205:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 499               	.LM58:
 500 010c 9093 C600 		sts 198,r25
 501               	.L28:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 503               	.LM59:
 504 0110 8091 C000 		lds r24,192
 505 0114 86FF      		sbrs r24,6
 506 0116 00C0      		rjmp .L28
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 508               	.LM60:
 509 0118 4091 C000 		lds r20,192
 510 011c 4064      		ori r20,lo8(64)
 511 011e 4093 C000 		sts 192,r20
 512               	/* epilogue start */
 513               	.LBE205:
 514               	.LBE204:
1453:stk500boot.c  **** }
 516               	.LM61:
 517 0122 0895      		ret
 519               	.Lscope7:
 524               	DumpHex.clone.0:
1566:stk500boot.c  **** static void	DumpHex(uint8_t dumpWhat, uint32_t startAddress, uint8_t numRows)
 526               	.LM62:
 527               	.LFBB8:
 528 0124 2F92      		push r2
 529 0126 3F92      		push r3
 530 0128 4F92      		push r4
 531 012a 5F92      		push r5
 532 012c 6F92      		push r6
 533 012e 7F92      		push r7
 534 0130 8F92      		push r8
 535 0132 9F92      		push r9
 536 0134 AF92      		push r10
 537 0136 BF92      		push r11
 538 0138 CF92      		push r12
 539 013a DF92      		push r13
 540 013c EF92      		push r14
 541 013e FF92      		push r15
 542 0140 0F93      		push r16
 543 0142 1F93      		push r17
 544 0144 DF93      		push r29
 545 0146 CF93      		push r28
 546 0148 CDB7      		in r28,__SP_L__
 547 014a DEB7      		in r29,__SP_H__
 548 014c 6797      		sbiw r28,23
 549 014e 0FB6      		in __tmp_reg__,__SREG__
 550 0150 F894      		cli
 551 0152 DEBF      		out __SP_H__,r29
 552 0154 0FBE      		out __SREG__,__tmp_reg__
 553 0156 CDBF      		out __SP_L__,r28
 554               	/* prologue: function */
 555               	/* frame size = 23 */
 556               	/* stack size = 41 */
 557               	.L__stack_usage = 41
 558 0158 8B8B      		std Y+19,r24
 559 015a 1A01      		movw r2,r20
 560 015c 2B01      		movw r4,r22
1566:stk500boot.c  **** static void	DumpHex(uint8_t dumpWhat, uint32_t startAddress, uint8_t numRows)
 562               	.LM63:
 563 015e DB01      		movw r26,r22
 564 0160 CA01      		movw r24,r20
 565 0162 8050      		subi r24,lo8(-(256))
 566 0164 9F4F      		sbci r25,hi8(-(256))
 567 0166 AF4F      		sbci r26,hlo8(-(256))
 568 0168 BF4F      		sbci r27,hhi8(-(256))
 569 016a 8C8B      		std Y+20,r24
 570 016c 9D8B      		std Y+21,r25
 571 016e AE8B      		std Y+22,r26
 572 0170 BF8B      		std Y+23,r27
1575:stk500boot.c  **** 	theValue			=	0;
 574               	.LM64:
 575 0172 9924      		clr r9
 576 0174 5E01      		movw r10,r28
 577 0176 0894      		sec
 578 0178 A11C      		adc r10,__zero_reg__
 579 017a B11C      		adc r11,__zero_reg__
 580               	.LBB206:
 581               	.LBB207:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 583               	.LM65:
 584 017c 20E2      		ldi r18,lo8(32)
 585 017e 822E      		mov r8,r18
 586               	.LBE207:
 587               	.LBE206:
 588               	.LBB209:
 589               	.LBB210:
 590 0180 9DE2      		ldi r25,lo8(45)
 591 0182 692E      		mov r6,r25
 592               	.LBE210:
 593               	.LBE209:
 594               	.LBB212:
1619:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 596               	.LM66:
 597 0184 8EE2      		ldi r24,lo8(46)
 598 0186 782E      		mov r7,r24
 599               	.L44:
 600               	.LBE212:
1579:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
 602               	.LM67:
 603 0188 91E0      		ldi r25,lo8(65537)
 604 018a 2916      		cp r2,r25
 605 018c 90E0      		ldi r25,hi8(65537)
 606 018e 3906      		cpc r3,r25
 607 0190 91E0      		ldi r25,hlo8(65537)
 608 0192 4906      		cpc r4,r25
 609 0194 90E0      		ldi r25,hhi8(65537)
 610 0196 5906      		cpc r5,r25
 611 0198 00F0      		brlo .+2
 612 019a 00C0      		rjmp .L51
 613               	.L32:
1583:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
 615               	.LM68:
 616 019c 832D      		mov r24,r3
 617 019e 0E94 0000 		call PrintHexByte
1584:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 619               	.LM69:
 620 01a2 822D      		mov r24,r2
 621 01a4 0E94 0000 		call PrintHexByte
 622               	.LBB216:
 623               	.LBB208:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 625               	.LM70:
 626 01a8 8092 C600 		sts 198,r8
 627               	.L33:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 629               	.LM71:
 630 01ac 8091 C000 		lds r24,192
 631 01b0 86FF      		sbrs r24,6
 632 01b2 00C0      		rjmp .L33
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 634               	.LM72:
 635 01b4 0091 C000 		lds r16,192
 636 01b8 0064      		ori r16,lo8(64)
 637 01ba 0093 C000 		sts 192,r16
 638               	.LBE208:
 639               	.LBE216:
 640               	.LBB217:
 641               	.LBB211:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 643               	.LM73:
 644 01be 6092 C600 		sts 198,r6
 645               	.L34:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 647               	.LM74:
 648 01c2 C090 C000 		lds r12,192
 649 01c6 C6FE      		sbrs r12,6
 650 01c8 00C0      		rjmp .L34
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 652               	.LM75:
 653 01ca 1091 C000 		lds r17,192
 654 01ce 1064      		ori r17,lo8(64)
 655 01d0 1093 C000 		sts 192,r17
 656               	.LBE211:
 657               	.LBE217:
 658               	.LBB218:
 659               	.LBB219:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 661               	.LM76:
 662 01d4 8092 C600 		sts 198,r8
 663               	.L35:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 665               	.LM77:
 666 01d8 D090 C000 		lds r13,192
 667 01dc D6FE      		sbrs r13,6
 668 01de 00C0      		rjmp .L35
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 670               	.LM78:
 671 01e0 2091 C000 		lds r18,192
 672 01e4 2064      		ori r18,lo8(64)
 673 01e6 2093 C000 		sts 192,r18
 674               	.LBE219:
 675               	.LBE218:
1589:stk500boot.c  **** 		asciiDump[0]		=	0;
 677               	.LM79:
 678 01ea 1982      		std Y+1,__zero_reg__
 679 01ec 7201      		movw r14,r4
 680 01ee 6101      		movw r12,r2
 681 01f0 00E0      		ldi r16,lo8(0)
 682 01f2 10E0      		ldi r17,hi8(0)
 683               	.L43:
 684               	.LBB220:
1592:stk500boot.c  **** 			switch(dumpWhat)
 686               	.LM80:
 687 01f4 AB89      		ldd r26,Y+19
 688 01f6 A130      		cpi r26,lo8(1)
 689 01f8 01F4      		brne .+2
 690 01fa 00C0      		rjmp .L38
 691 01fc A130      		cpi r26,lo8(1)
 692 01fe 00F0      		brlo .+2
 693 0200 00C0      		rjmp .L52
 694               	.LBB215:
1596:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
 696               	.LM81:
 697               	/* #APP */
 698               	 ;  1596 "stk500boot.c" 1
 699 0202 EBBE      		out 59, r14
 700 0204 F601      		movw r30, r12
 701 0206 9790      		elpm r9, Z+
 702               		
 703               	 ;  0 "" 2
 704               	/* #NOAPP */
 705               	.L36:
 706               	.LBE215:
1611:stk500boot.c  **** 			PrintHexByte(theValue);
 708               	.LM82:
 709 0208 892D      		mov r24,r9
 710 020a 0E94 0000 		call PrintHexByte
 711               	.LBB213:
 712               	.LBB214:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 714               	.LM83:
 715 020e 8092 C600 		sts 198,r8
 716               	.L40:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 718               	.LM84:
 719 0212 3091 C000 		lds r19,192
 720 0216 36FF      		sbrs r19,6
 721 0218 00C0      		rjmp .L40
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 723               	.LM85:
 724 021a 5091 C000 		lds r21,192
 725 021e 5064      		ori r21,lo8(64)
 726 0220 5093 C000 		sts 192,r21
 727               	.LBE214:
 728               	.LBE213:
1613:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 730               	.LM86:
 731 0224 492D      		mov r20,r9
 732 0226 4052      		subi r20,lo8(-(-32))
 733 0228 4F35      		cpi r20,lo8(95)
 734 022a 00F0      		brlo .+2
 735 022c 00C0      		rjmp .L41
1615:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
 737               	.LM87:
 738 022e F801      		movw r30,r16
 739 0230 EF70      		andi r30,lo8(15)
 740 0232 F070      		andi r31,hi8(15)
 741 0234 EA0D      		add r30,r10
 742 0236 FB1D      		adc r31,r11
 743 0238 9082      		st Z,r9
 744               	.L42:
1622:stk500boot.c  **** 			myAddressPointer++;
 746               	.LM88:
 747 023a 0894      		sec
 748 023c C11C      		adc r12,__zero_reg__
 749 023e D11C      		adc r13,__zero_reg__
 750 0240 E11C      		adc r14,__zero_reg__
 751 0242 F11C      		adc r15,__zero_reg__
 752 0244 0F5F      		subi r16,lo8(-(1))
 753 0246 1F4F      		sbci r17,hi8(-(1))
1590:stk500boot.c  **** 		for (uint8_t ii=0; ii<16; ii++)
 755               	.LM89:
 756 0248 0031      		cpi r16,16
 757 024a 1105      		cpc r17,__zero_reg__
 758 024c 01F4      		brne .L43
 759 024e 80E1      		ldi r24,lo8(16)
 760 0250 90E0      		ldi r25,hi8(16)
 761 0252 A0E0      		ldi r26,hlo8(16)
 762 0254 B0E0      		ldi r27,hhi8(16)
 763 0256 280E      		add r2,r24
 764 0258 391E      		adc r3,r25
 765 025a 4A1E      		adc r4,r26
 766 025c 5B1E      		adc r5,r27
 767               	.LBE220:
1624:stk500boot.c  **** 		asciiDump[16]	=	0;
 769               	.LM90:
 770 025e 198A      		std Y+17,__zero_reg__
1625:stk500boot.c  **** 		PrintString(asciiDump);
 772               	.LM91:
 773 0260 C501      		movw r24,r10
 774 0262 0E94 0000 		call PrintString
1626:stk500boot.c  **** 		PrintNewLine();
 776               	.LM92:
 777 0266 0E94 0000 		call PrintNewLine
1577:stk500boot.c  **** 	while (numRows > 0)
 779               	.LM93:
 780 026a 8C89      		ldd r24,Y+20
 781 026c 9D89      		ldd r25,Y+21
 782 026e AE89      		ldd r26,Y+22
 783 0270 BF89      		ldd r27,Y+23
 784 0272 2816      		cp r2,r24
 785 0274 3906      		cpc r3,r25
 786 0276 4A06      		cpc r4,r26
 787 0278 5B06      		cpc r5,r27
 788 027a 01F0      		breq .+2
 789 027c 00C0      		rjmp .L44
 790               	/* epilogue start */
1630:stk500boot.c  **** }
 792               	.LM94:
 793 027e 6796      		adiw r28,23
 794 0280 0FB6      		in __tmp_reg__,__SREG__
 795 0282 F894      		cli
 796 0284 DEBF      		out __SP_H__,r29
 797 0286 0FBE      		out __SREG__,__tmp_reg__
 798 0288 CDBF      		out __SP_L__,r28
 799 028a CF91      		pop r28
 800 028c DF91      		pop r29
 801 028e 1F91      		pop r17
 802 0290 0F91      		pop r16
 803 0292 FF90      		pop r15
 804 0294 EF90      		pop r14
 805 0296 DF90      		pop r13
 806 0298 CF90      		pop r12
 807 029a BF90      		pop r11
 808 029c AF90      		pop r10
 809 029e 9F90      		pop r9
 810 02a0 8F90      		pop r8
 811 02a2 7F90      		pop r7
 812 02a4 6F90      		pop r6
 813 02a6 5F90      		pop r5
 814 02a8 4F90      		pop r4
 815 02aa 3F90      		pop r3
 816 02ac 2F90      		pop r2
 817 02ae 0895      		ret
 818               	.L41:
 819               	.LBB221:
1619:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 821               	.LM95:
 822 02b0 F801      		movw r30,r16
 823 02b2 EF70      		andi r30,lo8(15)
 824 02b4 F070      		andi r31,hi8(15)
 825 02b6 EA0D      		add r30,r10
 826 02b8 FB1D      		adc r31,r11
 827 02ba 7082      		st Z,r7
 828 02bc 00C0      		rjmp .L42
 829               	.L52:
1592:stk500boot.c  **** 			switch(dumpWhat)
 831               	.LM96:
 832 02be A230      		cpi r26,lo8(2)
 833 02c0 01F0      		breq .+2
 834 02c2 00C0      		rjmp .L36
1607:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
 836               	.LM97:
 837 02c4 F601      		movw r30,r12
 838 02c6 9080      		ld r9,Z
 839 02c8 00C0      		rjmp .L36
 840               	.L38:
1603:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
 842               	.LM98:
 843 02ca C601      		movw r24,r12
 844 02cc 0E94 0000 		call __eerd_byte_m1284p
 845 02d0 982E      		mov r9,r24
 846 02d2 00C0      		rjmp .L36
 847               	.L51:
 848               	.LBE221:
1581:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
 850               	.LM99:
 851 02d4 842D      		mov r24,r4
 852 02d6 0E94 0000 		call PrintHexByte
 853 02da 00C0      		rjmp .L32
 859               	.Lscope8:
 863               	.global	PrintDecInt
 865               	PrintDecInt:
1457:stk500boot.c  **** {
 867               	.LM100:
 868               	.LFBB9:
 869               	/* prologue: function */
 870               	/* frame size = 0 */
 871               	/* stack size = 0 */
 872               	.L__stack_usage = 0
 873 02dc 9C01      		movw r18,r24
 874 02de FB01      		movw r30,r22
1463:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 876               	.LM101:
 877 02e0 8536      		cpi r24,101
 878 02e2 9105      		cpc r25,__zero_reg__
 879 02e4 04F4      		brge .L54
1463:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 881               	.LM102:
 882 02e6 6330      		cpi r22,3
 883 02e8 7105      		cpc r23,__zero_reg__
 884 02ea 04F0      		brlt .L55
 885               	.L54:
1465:stk500boot.c  **** 		theChar		=	(uint8_t)(0x30 + myNumber / 100);
 887               	.LM103:
 888 02ec C901      		movw r24,r18
 889 02ee 64E6      		ldi r22,lo8(100)
 890 02f0 70E0      		ldi r23,hi8(100)
 891 02f2 0E94 0000 		call __divmodhi4
 892 02f6 605D      		subi r22,lo8(-(48))
 893               	.LBB222:
 894               	.LBB223:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 896               	.LM104:
 897 02f8 6093 C600 		sts 198,r22
 898               	.L56:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 900               	.LM105:
 901 02fc 8091 C000 		lds r24,192
 902 0300 86FF      		sbrs r24,6
 903 0302 00C0      		rjmp .L56
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 905               	.LM106:
 906 0304 4091 C000 		lds r20,192
 907 0308 4064      		ori r20,lo8(64)
 908 030a 4093 C000 		sts 192,r20
 909               	.L55:
 910               	.LBE223:
 911               	.LBE222:
1469:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 913               	.LM107:
 914 030e 2B30      		cpi r18,11
 915 0310 3105      		cpc r19,__zero_reg__
 916 0312 04F4      		brge .L57
1469:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 918               	.LM108:
 919 0314 E230      		cpi r30,2
 920 0316 F105      		cpc r31,__zero_reg__
 921 0318 04F0      		brlt .L58
 922               	.L57:
1471:stk500boot.c  **** 		theChar	=	(uint8_t)(0x30  + ((myNumber % 100) / 10 ));
 924               	.LM109:
 925 031a C901      		movw r24,r18
 926 031c 64E6      		ldi r22,lo8(100)
 927 031e 70E0      		ldi r23,hi8(100)
 928 0320 0E94 0000 		call __divmodhi4
 929 0324 6AE0      		ldi r22,lo8(10)
 930 0326 70E0      		ldi r23,hi8(10)
 931 0328 0E94 0000 		call __divmodhi4
 932 032c 605D      		subi r22,lo8(-(48))
 933               	.LBB224:
 934               	.LBB225:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 936               	.LM110:
 937 032e 6093 C600 		sts 198,r22
 938               	.L59:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 940               	.LM111:
 941 0332 5091 C000 		lds r21,192
 942 0336 56FF      		sbrs r21,6
 943 0338 00C0      		rjmp .L59
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 945               	.LM112:
 946 033a 6091 C000 		lds r22,192
 947 033e 6064      		ori r22,lo8(64)
 948 0340 6093 C000 		sts 192,r22
 949               	.L58:
 950               	.LBE225:
 951               	.LBE224:
1474:stk500boot.c  **** 	theChar	=	(uint8_t)(0x30 + (myNumber % 10));
 953               	.LM113:
 954 0344 C901      		movw r24,r18
 955 0346 6AE0      		ldi r22,lo8(10)
 956 0348 70E0      		ldi r23,hi8(10)
 957 034a 0E94 0000 		call __divmodhi4
 958 034e 805D      		subi r24,lo8(-(48))
 959               	.LBB226:
 960               	.LBB227:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 962               	.LM114:
 963 0350 8093 C600 		sts 198,r24
 964               	.L60:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 966               	.LM115:
 967 0354 2091 C000 		lds r18,192
 968 0358 26FF      		sbrs r18,6
 969 035a 00C0      		rjmp .L60
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 971               	.LM116:
 972 035c 3091 C000 		lds r19,192
 973 0360 3064      		ori r19,lo8(64)
 974 0362 3093 C000 		sts 192,r19
 975               	/* epilogue start */
 976               	.LBE227:
 977               	.LBE226:
1476:stk500boot.c  **** }
 979               	.LM117:
 980 0366 0895      		ret
 982               	.Lscope9:
 984               	.global	main
 986               	main:
 572:stk500boot.c  **** {
 988               	.LM118:
 989               	.LFBB10:
 990 0368 CDB7      		in r28,__SP_L__
 991 036a DEB7      		in r29,__SP_H__
 992 036c C054      		subi r28,lo8(-(-320))
 993 036e D140      		sbci r29,hi8(-(-320))
 994 0370 DEBF      		out __SP_H__, r29
 995 0372 CDBF      		out __SP_L__, r28
 996               	/* prologue: function */
 997               	/* frame size = 320 */
 998               	/* stack size = 320 */
 999               	.L__stack_usage = 320
 594:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 1001               	.LM119:
 1002               	/* #APP */
 1003               	 ;  594 "stk500boot.c" 1
 1004               		.set __stack, 16639
 1005               	 ;  0 "" 2
 595:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 1007               	.LM120:
 1008               	 ;  595 "stk500boot.c" 1
 1009 0374 00E4      		ldi	16, 64
 1010               	 ;  0 "" 2
 596:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 1012               	.LM121:
 1013               	 ;  596 "stk500boot.c" 1
 1014 0376 0EBF      		out 62,16
 1015               	 ;  0 "" 2
 597:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 1017               	.LM122:
 1018               	 ;  597 "stk500boot.c" 1
 1019 0378 0FEF      		ldi	16, 255
 1020               	 ;  0 "" 2
 598:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 1022               	.LM123:
 1023               	 ;  598 "stk500boot.c" 1
 1024 037a 0DBF      		out 61,16
 1025               	 ;  0 "" 2
 605:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 1027               	.LM124:
 1028               	/* #NOAPP */
 1029 037c 94B7      		in r25,84-32
 607:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 1031               	.LM125:
 1032               	/* #APP */
 1033               	 ;  607 "stk500boot.c" 1
 1034 037e F894      		cli
 1035               	 ;  0 "" 2
 608:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 1037               	.LM126:
 1038               	 ;  608 "stk500boot.c" 1
 1039 0380 A895      		wdr
 1040               	 ;  0 "" 2
 609:stk500boot.c  **** 	MCUSR	=	0;
 1042               	.LM127:
 1043               	/* #NOAPP */
 1044 0382 14BE      		out 84-32,__zero_reg__
 610:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 1046               	.LM128:
 1047 0384 8091 6000 		lds r24,96
 1048 0388 8861      		ori r24,lo8(24)
 1049 038a 8093 6000 		sts 96,r24
 611:stk500boot.c  **** 	WDTCSR	=	0;
 1051               	.LM129:
 1052 038e 1092 6000 		sts 96,__zero_reg__
 612:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 1054               	.LM130:
 1055               	/* #APP */
 1056               	 ;  612 "stk500boot.c" 1
 1057 0392 7894      		sei
 1058               	 ;  0 "" 2
 614:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 1060               	.LM131:
 1061               	/* #NOAPP */
 1062 0394 93FF      		sbrs r25,3
 1063 0396 00C0      		rjmp .L65
 616:stk500boot.c  **** 		app_start();
 1065               	.LM132:
 1066 0398 E091 0000 		lds r30,app_start
 1067 039c F091 0000 		lds r31,app_start+1
 1068 03a0 0995      		icall
 1069               	.L65:
 638:stk500boot.c  **** 	PROGLED_DDR		|=	_BV(PROGLED_PIN);
 1071               	.LM133:
 1072 03a2 279A      		sbi 36-32,7
 640:stk500boot.c  **** 	PROGLED_PORT	|=	_BV(PROGLED_PIN);	// active high LED ON
 1074               	.LM134:
 1075 03a4 2F9A      		sbi 37-32,7
 658:stk500boot.c  **** 	UART_STATUS_REG		|=	_BV(UART_DOUBLE_SPEED);
 1077               	.LM135:
 1078 03a6 2091 C000 		lds r18,192
 1079 03aa 2260      		ori r18,lo8(2)
 1080 03ac 2093 C000 		sts 192,r18
 660:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE, F_CPU);
 1082               	.LM136:
 1083 03b0 13E3      		ldi r17,lo8(51)
 1084 03b2 1093 C400 		sts 196,r17
 661:stk500boot.c  **** 	UART_CONTROL_REG	=	_BV(UART_ENABLE_RECEIVER) | _BV(UART_ENABLE_TRANSMITTER);
 1086               	.LM137:
 1087 03b6 08E1      		ldi r16,lo8(24)
 1088 03b8 0093 C100 		sts 193,r16
 663:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 1090               	.LM138:
 1091               	/* #APP */
 1092               	 ;  663 "stk500boot.c" 1
 1093 03bc 0000      		nop
 1094               	 ;  0 "" 2
 622:stk500boot.c  **** 	boot_timer	=	0;
 1096               	.LM139:
 1097               	/* #NOAPP */
 1098 03be EE24      		clr r14
 1099 03c0 FF24      		clr r15
 1100 03c2 8701      		movw r16,r14
 714:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 1102               	.LM140:
 1103 03c4 27EC      		ldi r18,lo8(7111)
 1104 03c6 822E      		mov r8,r18
 1105 03c8 2BE1      		ldi r18,hi8(7111)
 1106 03ca 922E      		mov r9,r18
 1107 03cc A12C      		mov r10,__zero_reg__
 1108 03ce B12C      		mov r11,__zero_reg__
 572:stk500boot.c  **** {
 1110               	.LM141:
 1111 03d0 CC24      		clr r12
 1112 03d2 DD24      		clr r13
 1113               	.L295:
 1114               	.LBB370:
 1115               	.LBB371:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 1117               	.LM142:
 1118 03d4 4091 C000 		lds r20,192
 1119               	.LBE371:
 1120               	.LBE370:
 702:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 1122               	.LM143:
 1123 03d8 47FD      		sbrc r20,7
 1124 03da 00C0      		rjmp .L69
 1125               	.L309:
 702:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 1127               	.LM144:
 1128 03dc C114      		cp r12,__zero_reg__
 1129 03de D104      		cpc r13,__zero_reg__
 1130 03e0 01F4      		brne .L69
 1131               	.LBB373:
 1132               	.LBB374:
 1134               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1136               	.LM145:
 1137 03e2 25E0      		 ldi r18,lo8(5)
 1138 03e4 2A95      	    1:dec r18
 1139 03e6 01F4      	    brne 1b
 1140 03e8 0000      		nop
 1141               	.LBE374:
 1142               	.LBE373:
 1144               	.Ltext2:
 705:stk500boot.c  **** 			boot_timer++;
 1146               	.LM146:
 1147 03ea 0894      		sec
 1148 03ec E11C      		adc r14,__zero_reg__
 1149 03ee F11C      		adc r15,__zero_reg__
 1150 03f0 011D      		adc r16,__zero_reg__
 1151 03f2 111D      		adc r17,__zero_reg__
 708:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 1153               	.LM147:
 1154 03f4 91E0      		ldi r25,lo8(1)
 1155 03f6 C92E      		mov r12,r25
 1156 03f8 D12C      		mov r13,__zero_reg__
 1157 03fa 31E2      		ldi r19,lo8(20001)
 1158 03fc E316      		cp r14,r19
 1159 03fe 3EE4      		ldi r19,hi8(20001)
 1160 0400 F306      		cpc r15,r19
 1161 0402 30E0      		ldi r19,hlo8(20001)
 1162 0404 0307      		cpc r16,r19
 1163 0406 30E0      		ldi r19,hhi8(20001)
 1164 0408 1307      		cpc r17,r19
 1165 040a 00F4      		brsh .L67
 1166 040c CC24      		clr r12
 1167 040e DD24      		clr r13
 1168               	.L67:
 714:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 1170               	.LM148:
 1171 0410 C801      		movw r24,r16
 1172 0412 B701      		movw r22,r14
 1173 0414 A501      		movw r20,r10
 1174 0416 9401      		movw r18,r8
 1175 0418 0E94 0000 		call __udivmodsi4
 1176 041c 6115      		cp r22,__zero_reg__
 1177 041e 7105      		cpc r23,__zero_reg__
 1178 0420 8105      		cpc r24,__zero_reg__
 1179 0422 9105      		cpc r25,__zero_reg__
 1180 0424 01F4      		brne .L295
 717:stk500boot.c  **** 				PROGLED_PORT	^=	_BV(PROGLED_PIN);	// turn LED ON
 1182               	.LM149:
 1183 0426 35B1      		in r19,37-32
 1184 0428 3058      		subi r19,lo8(-(-128))
 1185 042a 35B9      		out 37-32,r19
 1186               	.LBB375:
 1187               	.LBB372:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 1189               	.LM150:
 1190 042c 4091 C000 		lds r20,192
 1191               	.LBE372:
 1192               	.LBE375:
 702:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 1194               	.LM151:
 1195 0430 47FF      		sbrs r20,7
 1196 0432 00C0      		rjmp .L309
 1197               	.L69:
 700:stk500boot.c  **** 	while (boot_state==0)
 1199               	.LM152:
 1200 0434 9601      		movw r18,r12
 1201 0436 2F5F      		subi r18,lo8(-(1))
 1202 0438 3F4F      		sbci r19,hi8(-(1))
 728:stk500boot.c  **** 	if (boot_state==1)
 1204               	.LM153:
 1205 043a 2130      		cpi r18,1
 1206 043c 3105      		cpc r19,__zero_reg__
 1207 043e 01F0      		breq .L310
 1208               	.L73:
1258:stk500boot.c  **** 	PROGLED_DDR		&=	~_BV(PROGLED_PIN);	// set to default
 1210               	.LM154:
 1211 0440 2798      		cbi 36-32,7
1259:stk500boot.c  **** 	PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// active low LED OFF
 1213               	.LM155:
 1214 0442 2F98      		cbi 37-32,7
 1215               	.LBB376:
 1216               	.LBB377:
 1218               	.Ltext3:
 1220               	.LM156:
 1221 0444 8FEF      		 ldi r24,lo8(159999)
 1222 0446 90E7      	    ldi r25,hi8(159999)
 1223 0448 A2E0      	    ldi r26,hlo8(159999)
 1224 044a 8150      	    1:subi r24,1
 1225 044c 9040      	    sbci r25,0
 1226 044e A040      	    sbci r26,0
 1227 0450 01F4      	    brne 1b
 1228 0452 00C0      		rjmp .
 1229 0454 0000      		nop
 1230               	.LBE377:
 1231               	.LBE376:
 1233               	.Ltext4:
1265:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 1235               	.LM157:
 1236               	/* #APP */
 1237               	 ;  1265 "stk500boot.c" 1
 1238 0456 0000      		nop
 1239               	 ;  0 "" 2
1271:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 1241               	.LM158:
 1242               	/* #NOAPP */
 1243 0458 8091 C000 		lds r24,192
 1244 045c 8D7F      		andi r24,lo8(-3)
 1245 045e 8093 C000 		sts 192,r24
1272:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 1247               	.LM159:
 1248 0462 81E1      		ldi r24,lo8(17)
 1249               	/* #APP */
 1250               	 ;  1272 "stk500boot.c" 1
 1251 0464 8093 5700 		sts 87, r24
 1252 0468 E895      		spm
 1253               		
 1254               	 ;  0 "" 2
1275:stk500boot.c  **** 	asm volatile(
 1256               	.LM160:
 1257               	 ;  1275 "stk500boot.c" 1
 1258 046a EE27      		clr	r30		
 1259 046c FF27      		clr	r31		
 1260 046e 0994      		ijmp	
 1261               		
 1262               	 ;  0 "" 2
1281:stk500boot.c  **** }
 1264               	.LM161:
 1265               	/* #NOAPP */
 1266 0470 80E0      		ldi r24,lo8(0)
 1267 0472 90E0      		ldi r25,hi8(0)
 1268               	/* epilogue start */
 1269 0474 C05C      		subi r28,lo8(-(320))
 1270 0476 DE4F      		sbci r29,hi8(-(320))
 1271 0478 0FB6      		in __tmp_reg__,__SREG__
 1272 047a F894      		cli
 1273 047c DEBF      		out __SP_H__,r29
 1274 047e 0FBE      		out __SREG__,__tmp_reg__
 1275 0480 CDBF      		out __SP_L__,r28
 1276 0482 0895      		ret
 1277               	.L310:
 728:stk500boot.c  **** 	if (boot_state==1)
 1279               	.LM162:
 1280 0484 CF5C      		subi r28,lo8(-305)
 1281 0486 DE4F      		sbci r29,hi8(-305)
 1282 0488 1882      		st Y,__zero_reg__
 1283 048a 1982      		std Y+1,__zero_reg__
 1284 048c 1A82      		std Y+2,__zero_reg__
 1285 048e 1B82      		std Y+3,__zero_reg__
 1286 0490 C153      		subi r28,lo8(305)
 1287 0492 D140      		sbci r29,hi8(305)
 1288 0494 CA5D      		subi r28,lo8(-294)
 1289 0496 DE4F      		sbci r29,hi8(-294)
 1290 0498 1882      		st Y,__zero_reg__
 1291 049a 1982      		std Y+1,__zero_reg__
 1292 049c 1A82      		std Y+2,__zero_reg__
 1293 049e 1B82      		std Y+3,__zero_reg__
 1294 04a0 C652      		subi r28,lo8(294)
 1295 04a2 D140      		sbci r29,hi8(294)
 1296 04a4 EE24      		clr r14
 1297 04a6 FF24      		clr r15
 1298 04a8 40E0      		ldi r20,lo8(0)
 1299 04aa 50E0      		ldi r21,hi8(0)
 1300 04ac C25D      		subi r28,lo8(-302)
 1301 04ae DE4F      		sbci r29,hi8(-302)
 1302 04b0 1882      		st Y,__zero_reg__
 1303 04b2 CE52      		subi r28,lo8(302)
 1304 04b4 D140      		sbci r29,hi8(302)
 1305 04b6 CC24      		clr r12
 1306 04b8 C15D      		subi r28,lo8(-303)
 1307 04ba DE4F      		sbci r29,hi8(-303)
 1308 04bc 1982      		std Y+1,__zero_reg__
 1309 04be 1882      		st Y,__zero_reg__
 1310 04c0 CF52      		subi r28,lo8(303)
 1311 04c2 D140      		sbci r29,hi8(303)
 1312               	.LBB378:
 1313               	.LBB380:
 1314               	.LBB383:
 1315               	.LBB384:
 546:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 1317               	.LM163:
 1318 04c4 80E0      		ldi r24,lo8(0)
 1319 04c6 90E0      		ldi r25,hi8(0)
 1320 04c8 DC01      		movw r26,r24
 1321               	/* #APP */
 1322               	 ;  546 "stk500boot.c" 1
 1323 04ca ABBF      		out 59, r26
 1324 04cc FC01      		movw r30, r24
 1325 04ce 0791      		elpm r16, Z+
 1326 04d0 1691      		elpm r17, Z
 1327               		
 1328               	 ;  0 "" 2
 1329               	/* #NOAPP */
 1330               	.LBE384:
 1331               	.LBE383:
 1332               	.LBE380:
 1333               	.LBE378:
 1334               	.LBB387:
 1335               	.LBB392:
1843:stk500boot.c  **** 
1844:stk500boot.c  **** //************************************************************************
1845:stk500boot.c  **** static void	ListAvailablePorts(void)
1846:stk500boot.c  **** {
1847:stk500boot.c  **** 
1848:stk500boot.c  **** #ifdef DDRA
1849:stk500boot.c  **** 	PrintAvailablePort('A');
1850:stk500boot.c  **** #endif
1851:stk500boot.c  **** 
1852:stk500boot.c  **** #ifdef DDRB
1853:stk500boot.c  **** 	PrintAvailablePort('B');
1854:stk500boot.c  **** #endif
1855:stk500boot.c  **** 
1856:stk500boot.c  **** #ifdef DDRC
1857:stk500boot.c  **** 	PrintAvailablePort('C');
1858:stk500boot.c  **** #endif
1859:stk500boot.c  **** 
1860:stk500boot.c  **** #ifdef DDRD
1861:stk500boot.c  **** 	PrintAvailablePort('D');
1862:stk500boot.c  **** #endif
1863:stk500boot.c  **** 
1864:stk500boot.c  **** #ifdef DDRE
1865:stk500boot.c  **** 	PrintAvailablePort('E');
1866:stk500boot.c  **** #endif
1867:stk500boot.c  **** 
1868:stk500boot.c  **** #ifdef DDRF
1869:stk500boot.c  **** 	PrintAvailablePort('F');
1870:stk500boot.c  **** #endif
1871:stk500boot.c  **** 
1872:stk500boot.c  **** #ifdef DDRG
1873:stk500boot.c  **** 	PrintAvailablePort('G');
1874:stk500boot.c  **** #endif
1875:stk500boot.c  **** 
1876:stk500boot.c  **** #ifdef DDRH
1877:stk500boot.c  **** 	PrintAvailablePort('H');
1878:stk500boot.c  **** #endif
1879:stk500boot.c  **** 
1880:stk500boot.c  **** #ifdef DDRI
1881:stk500boot.c  **** 	PrintAvailablePort('I');
1882:stk500boot.c  **** #endif
1883:stk500boot.c  **** 
1884:stk500boot.c  **** #ifdef DDRJ
1885:stk500boot.c  **** 	PrintAvailablePort('J');
1886:stk500boot.c  **** #endif
1887:stk500boot.c  **** 
1888:stk500boot.c  **** #ifdef DDRK
1889:stk500boot.c  **** 	PrintAvailablePort('K');
1890:stk500boot.c  **** #endif
1891:stk500boot.c  **** 
1892:stk500boot.c  **** #ifdef DDRL
1893:stk500boot.c  **** 	PrintAvailablePort('L');
1894:stk500boot.c  **** #endif
1895:stk500boot.c  **** 
1896:stk500boot.c  **** }
1897:stk500boot.c  **** 
1898:stk500boot.c  **** //************************************************************************
1899:stk500boot.c  **** static void	AVR_PortOutput(void)
1900:stk500boot.c  **** {
1901:stk500boot.c  **** char	portLetter;
1902:stk500boot.c  **** char	getCharFlag;
1903:stk500boot.c  **** 
1904:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1905:stk500boot.c  **** 
1906:stk500boot.c  **** 	portLetter	=	recchar();
1907:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1908:stk500boot.c  **** 	sendchar(portLetter);
1909:stk500boot.c  **** 	PrintNewLine();
1910:stk500boot.c  **** 
1911:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1912:stk500boot.c  **** 	{
1913:stk500boot.c  **** 		getCharFlag	=	true;
1914:stk500boot.c  **** 		switch(portLetter)
1915:stk500boot.c  **** 		{
1916:stk500boot.c  **** 		#ifdef DDRA
1917:stk500boot.c  **** 			case 'A':
1918:stk500boot.c  **** 				DDRA	=	0xff;
1919:stk500boot.c  **** 				while (!Serial_Available())
1920:stk500boot.c  **** 				{
1921:stk500boot.c  **** 					PORTA	^=	0xff;
1922:stk500boot.c  **** 					_delay_ms(100);
1923:stk500boot.c  **** 				}
1924:stk500boot.c  **** 				PORTA	=	0;
1925:stk500boot.c  **** 				break;
1926:stk500boot.c  **** 		#endif
1927:stk500boot.c  **** 
1928:stk500boot.c  **** 		#ifdef DDRB
1929:stk500boot.c  **** 			case 'B':
1930:stk500boot.c  **** 				DDRB	=	0xff;
1931:stk500boot.c  **** 				while (!Serial_Available())
1932:stk500boot.c  **** 				{
1933:stk500boot.c  **** 					PORTB	^=	0xff;
1934:stk500boot.c  **** 					_delay_ms(100);
1935:stk500boot.c  **** 				}
1936:stk500boot.c  **** 				PORTB	=	0;
1937:stk500boot.c  **** 				break;
1938:stk500boot.c  **** 		#endif
1939:stk500boot.c  **** 
1940:stk500boot.c  **** 		#ifdef DDRC
1941:stk500boot.c  **** 			case 'C':
1942:stk500boot.c  **** 				DDRC	=	0xff;
1943:stk500boot.c  **** 				while (!Serial_Available())
1944:stk500boot.c  **** 				{
1945:stk500boot.c  **** 					PORTC	^=	0xff;
1946:stk500boot.c  **** 					_delay_ms(100);
1947:stk500boot.c  **** 				}
1948:stk500boot.c  **** 				PORTC	=	0;
1949:stk500boot.c  **** 				break;
1950:stk500boot.c  **** 		#endif
1951:stk500boot.c  **** 
1952:stk500boot.c  **** 		#ifdef DDRD
1953:stk500boot.c  **** 			case 'D':
1954:stk500boot.c  **** 				DDRD	=	0xff;
1955:stk500boot.c  **** 				while (!Serial_Available())
1956:stk500boot.c  **** 				{
1957:stk500boot.c  **** 					PORTD	^=	0xff;
1958:stk500boot.c  **** 					_delay_ms(100);
1959:stk500boot.c  **** 				}
1960:stk500boot.c  **** 				PORTD	=	0;
1961:stk500boot.c  **** 				break;
1962:stk500boot.c  **** 		#endif
1963:stk500boot.c  **** 
1964:stk500boot.c  **** 		#ifdef DDRE
1965:stk500boot.c  **** 			case 'E':
1966:stk500boot.c  **** 				DDRE	=	0xff;
1967:stk500boot.c  **** 				while (!Serial_Available())
1968:stk500boot.c  **** 				{
1969:stk500boot.c  **** 					PORTE	^=	0xff;
1970:stk500boot.c  **** 					_delay_ms(100);
1971:stk500boot.c  **** 				}
1972:stk500boot.c  **** 				PORTE	=	0;
1973:stk500boot.c  **** 				break;
1974:stk500boot.c  **** 		#endif
1975:stk500boot.c  **** 
1976:stk500boot.c  **** 		#ifdef DDRF
1977:stk500boot.c  **** 			case 'F':
1978:stk500boot.c  **** 				DDRF	=	0xff;
1979:stk500boot.c  **** 				while (!Serial_Available())
1980:stk500boot.c  **** 				{
1981:stk500boot.c  **** 					PORTF	^=	0xff;
1982:stk500boot.c  **** 					_delay_ms(100);
1983:stk500boot.c  **** 				}
1984:stk500boot.c  **** 				PORTF	=	0;
1985:stk500boot.c  **** 				break;
1986:stk500boot.c  **** 		#endif
1987:stk500boot.c  **** 
1988:stk500boot.c  **** 		#ifdef DDRG
1989:stk500boot.c  **** 			case 'G':
1990:stk500boot.c  **** 				DDRG	=	0xff;
1991:stk500boot.c  **** 				while (!Serial_Available())
1992:stk500boot.c  **** 				{
1993:stk500boot.c  **** 					PORTG	^=	0xff;
1994:stk500boot.c  **** 					_delay_ms(100);
1995:stk500boot.c  **** 				}
1996:stk500boot.c  **** 				PORTG	=	0;
1997:stk500boot.c  **** 				break;
1998:stk500boot.c  **** 		#endif
1999:stk500boot.c  **** 
2000:stk500boot.c  **** 		#ifdef DDRH
2001:stk500boot.c  **** 			case 'H':
2002:stk500boot.c  **** 				DDRH	=	0xff;
2003:stk500boot.c  **** 				while (!Serial_Available())
2004:stk500boot.c  **** 				{
2005:stk500boot.c  **** 					PORTH	^=	0xff;
2006:stk500boot.c  **** 					_delay_ms(100);
2007:stk500boot.c  **** 				}
2008:stk500boot.c  **** 				PORTH	=	0;
2009:stk500boot.c  **** 				break;
2010:stk500boot.c  **** 		#endif
2011:stk500boot.c  **** 
2012:stk500boot.c  **** 		#ifdef DDRI
2013:stk500boot.c  **** 			case 'I':
2014:stk500boot.c  **** 				DDRI	=	0xff;
2015:stk500boot.c  **** 				while (!Serial_Available())
2016:stk500boot.c  **** 				{
2017:stk500boot.c  **** 					PORTI	^=	0xff;
2018:stk500boot.c  **** 					_delay_ms(100);
2019:stk500boot.c  **** 				}
2020:stk500boot.c  **** 				PORTI	=	0;
2021:stk500boot.c  **** 				break;
2022:stk500boot.c  **** 		#endif
2023:stk500boot.c  **** 
2024:stk500boot.c  **** 		#ifdef DDRJ
2025:stk500boot.c  **** 			case 'J':
2026:stk500boot.c  **** 				DDRJ	=	0xff;
2027:stk500boot.c  **** 				while (!Serial_Available())
2028:stk500boot.c  **** 				{
2029:stk500boot.c  **** 					PORTJ	^=	0xff;
2030:stk500boot.c  **** 					_delay_ms(100);
2031:stk500boot.c  **** 				}
2032:stk500boot.c  **** 				PORTJ	=	0;
2033:stk500boot.c  **** 				break;
2034:stk500boot.c  **** 		#endif
2035:stk500boot.c  **** 
2036:stk500boot.c  **** 		#ifdef DDRK
2037:stk500boot.c  **** 			case 'K':
2038:stk500boot.c  **** 				DDRK	=	0xff;
2039:stk500boot.c  **** 				while (!Serial_Available())
2040:stk500boot.c  **** 				{
2041:stk500boot.c  **** 					PORTK	^=	0xff;
2042:stk500boot.c  **** 					_delay_ms(100);
2043:stk500boot.c  **** 				}
2044:stk500boot.c  **** 				PORTK	=	0;
2045:stk500boot.c  **** 				break;
2046:stk500boot.c  **** 		#endif
2047:stk500boot.c  **** 
2048:stk500boot.c  **** 		#ifdef DDRL
2049:stk500boot.c  **** 			case 'L':
2050:stk500boot.c  **** 				DDRL	=	0xff;
2051:stk500boot.c  **** 				while (!Serial_Available())
2052:stk500boot.c  **** 				{
2053:stk500boot.c  **** 					PORTL	^=	0xff;
2054:stk500boot.c  **** 					_delay_ms(100);
2055:stk500boot.c  **** 				}
2056:stk500boot.c  **** 				PORTL	=	0;
2057:stk500boot.c  **** 				break;
2058:stk500boot.c  **** 		#endif
2059:stk500boot.c  **** 
2060:stk500boot.c  **** 			default:
2061:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
2062:stk500boot.c  **** 				getCharFlag	=	false;
2063:stk500boot.c  **** 				break;
2064:stk500boot.c  **** 		}
2065:stk500boot.c  **** 		if (getCharFlag)
2066:stk500boot.c  **** 		{
2067:stk500boot.c  **** 			recchar();
2068:stk500boot.c  **** 		}
2069:stk500boot.c  **** 	}
2070:stk500boot.c  **** 	else
2071:stk500boot.c  **** 	{
2072:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
2073:stk500boot.c  **** 	}
2074:stk500boot.c  **** }
2075:stk500boot.c  **** 
2076:stk500boot.c  **** 
2077:stk500boot.c  **** //*******************************************************************
2078:stk500boot.c  **** static void PrintHelp(void)
2079:stk500boot.c  **** {
2080:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
2081:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
2082:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
2083:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
2084:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
2085:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
2086:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2087:stk500boot.c  **** 
2088:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2089:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2090:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2091:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2092:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2093:stk500boot.c  **** }
2094:stk500boot.c  **** 
2095:stk500boot.c  **** //************************************************************************
2096:stk500boot.c  **** static void	RunMonitor(void)
2097:stk500boot.c  **** {
2098:stk500boot.c  **** 	uint8_t	keepGoing;
2099:stk500boot.c  **** 	uint8_t	theChar;
2100:stk500boot.c  **** 
2101:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
2102:stk500boot.c  **** 	sendchar1('m');
2103:stk500boot.c  **** 	sendchar1('o');
2104:stk500boot.c  **** 	sendchar1('n');
2105:stk500boot.c  **** 	sendchar1('i');
2106:stk500boot.c  **** 	sendchar1('t');
2107:stk500boot.c  **** 	sendchar1('o');
2108:stk500boot.c  **** 	sendchar1('r');
2109:stk500boot.c  **** 	sendchar1(0x0d);
2110:stk500boot.c  **** 	sendchar1(0x0a);
2111:stk500boot.c  **** #endif
2112:stk500boot.c  **** 
2113:stk500boot.c  **** 	for (uint8_t ii=0; ii<5; ii++)
2114:stk500boot.c  **** 	{
2115:stk500boot.c  **** 		for (uint8_t jj=0; jj<25; jj++)
2116:stk500boot.c  **** 		{
2117:stk500boot.c  **** 			sendchar('!');
2118:stk500boot.c  **** 		}
2119:stk500boot.c  **** 		PrintNewLine();
2120:stk500boot.c  **** 	}
2121:stk500boot.c  **** 
2122:stk500boot.c  **** 	gRamIndex			=	0;
2123:stk500boot.c  **** 	gFlashIndex			=	0;
2124:stk500boot.c  **** 	gEepromIndex		=	0;
2125:stk500boot.c  **** 
2126:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1337               	.LM164:
 1338 04d2 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1339 04d4 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1340               	.LBB435:
 1341               	.LBB437:
 1342               	.LBB447:
1646:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 1344               	.LM165:
 1345 04d6 AA27      		clr r26
 1346 04d8 97FD      		sbrc r25,7
 1347 04da A095      		com r26
 1348 04dc BA2F      		mov r27,r26
 1349               	/* #APP */
 1350               	 ;  1646 "stk500boot.c" 1
 1351 04de ABBF      		out 59, r26
 1352 04e0 FC01      		movw r30, r24
 1353 04e2 4790      		elpm r4, Z+
 1354               		
 1355               	 ;  0 "" 2
 1356               	/* #NOAPP */
 1357 04e4 CB5C      		subi r28,lo8(-309)
 1358 04e6 DE4F      		sbci r29,hi8(-309)
 1359 04e8 4882      		st Y,r4
 1360 04ea C553      		subi r28,lo8(309)
 1361 04ec D140      		sbci r29,hi8(309)
 1362               	.LBE447:
 1363               	.LBB446:
1672:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 1365               	.LM166:
 1366 04ee C45C      		subi r28,lo8(-316)
 1367 04f0 DE4F      		sbci r29,hi8(-316)
 1368 04f2 4882      		st Y,r4
 1369 04f4 CC53      		subi r28,lo8(316)
 1370 04f6 D140      		sbci r29,hi8(316)
 1371               	.L74:
 1372               	.LBE446:
 1373               	.LBE437:
 1374               	.LBE435:
 1375               	.LBE392:
 1376               	.LBE387:
 728:stk500boot.c  **** 	if (boot_state==1)
 1378               	.LM167:
 1379 04f8 60E0      		ldi r22,lo8(0)
 1380 04fa 70E0      		ldi r23,hi8(0)
 1381 04fc AA24      		clr r10
 1382 04fe C25D      		subi r28,lo8(-302)
 1383 0500 DE4F      		sbci r29,hi8(-302)
 1384 0502 9880      		ld r9,Y
 1385 0504 CE52      		subi r28,lo8(302)
 1386 0506 D140      		sbci r29,hi8(302)
 1387 0508 C15D      		subi r28,lo8(-303)
 1388 050a DE4F      		sbci r29,hi8(-303)
 1389 050c E881      		ld r30,Y
 1390 050e F981      		ldd r31,Y+1
 1391 0510 CF52      		subi r28,lo8(303)
 1392 0512 D140      		sbci r29,hi8(303)
 1393               	.L222:
 743:stk500boot.c  **** 				if (boot_state==1)
 1395               	.LM168:
 1396 0514 2130      		cpi r18,1
 1397 0516 3105      		cpc r19,__zero_reg__
 1398 0518 01F0      		breq .L304
 1399               	.L223:
 1400               	.LBB522:
 1401               	.LBB379:
 1402               	.LBB382:
 550:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 1404               	.LM169:
 1405 051a 80E0      		ldi r24,lo8(0)
 1406 051c 90E0      		ldi r25,hi8(0)
 1407 051e DC01      		movw r26,r24
 1408               	.L296:
 1409               	.LBE382:
 538:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 1411               	.LM170:
 1412 0520 B090 C000 		lds r11,192
 1413 0524 B7FC      		sbrc r11,7
 1414 0526 00C0      		rjmp .L304
 1415               	.L79:
 541:stk500boot.c  **** 		count++;
 1417               	.LM171:
 1418 0528 0196      		adiw r24,1
 1419 052a A11D      		adc r26,__zero_reg__
 1420 052c B11D      		adc r27,__zero_reg__
 542:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 1422               	.LM172:
 1423 052e 8130      		cpi r24,lo8(8000001)
 1424 0530 22E1      		ldi r18,hi8(8000001)
 1425 0532 9207      		cpc r25,r18
 1426 0534 2AE7      		ldi r18,hlo8(8000001)
 1427 0536 A207      		cpc r26,r18
 1428 0538 20E0      		ldi r18,hhi8(8000001)
 1429 053a B207      		cpc r27,r18
 1430 053c 00F0      		brlo .L296
 1431               	.LBB381:
 550:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 1433               	.LM173:
 1434 053e 3FEF      		ldi r19,hi8(-1)
 1435 0540 0F3F      		cpi r16,lo8(-1)
 1436 0542 1307      		cpc r17,r19
 1437 0544 01F0      		breq .L223
 552:stk500boot.c  **** 				asm volatile(
 1439               	.LM174:
 1440               	/* #APP */
 1441               	 ;  552 "stk500boot.c" 1
 1442 0546 EE27      		clr	r30		
 1443 0548 FF27      		clr	r31		
 1444 054a 0994      		ijmp	
 1445               		
 1446               	 ;  0 "" 2
 1447               	/* #NOAPP */
 1448 054c 80E0      		ldi r24,lo8(0)
 1449 054e 90E0      		ldi r25,hi8(0)
 1450 0550 DC01      		movw r26,r24
 1451               	.LBE381:
 538:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 1453               	.LM175:
 1454 0552 B090 C000 		lds r11,192
 1455 0556 B7FE      		sbrs r11,7
 1456 0558 00C0      		rjmp .L79
 1457               	.L304:
 561:stk500boot.c  **** 	return UART_DATA_REG;
 1459               	.LM176:
 1460 055a 2091 C600 		lds r18,198
 1461               	.LBE379:
 1462               	.LBE522:
 759:stk500boot.c  **** 				rcvdCharCntr++;
 1464               	.LM177:
 1465 055e 0894      		sec
 1466 0560 E11C      		adc r14,__zero_reg__
 1467 0562 F11C      		adc r15,__zero_reg__
 761:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1469               	.LM178:
 1470 0564 2132      		cpi r18,lo8(33)
 1471 0566 01F4      		brne .+2
 1472 0568 00C0      		rjmp .L311
 1473               	.L225:
 775:stk500boot.c  **** 					exPointCntr	=	0;
 1475               	.LM179:
 1476 056a 40E0      		ldi r20,lo8(0)
 1477 056c 50E0      		ldi r21,hi8(0)
 1478               	.L80:
 779:stk500boot.c  **** 				switch (msgParseState)
 1480               	.LM180:
 1481 056e 3A2D      		mov r19,r10
 1482 0570 3330      		cpi r19,lo8(3)
 1483 0572 01F4      		brne .+2
 1484 0574 00C0      		rjmp .L167
 1485 0576 3430      		cpi r19,lo8(4)
 1486 0578 00F4      		brsh .L171
 1487 057a 3130      		cpi r19,lo8(1)
 1488 057c 01F4      		brne .+2
 1489 057e 00C0      		rjmp .L165
 1490 0580 3230      		cpi r19,lo8(2)
 1491 0582 00F4      		brsh .+2
 1492 0584 00C0      		rjmp .L312
 809:stk500boot.c  **** 						msgLength		=	c<<8;
 1494               	.LM181:
 1495 0586 722F      		mov r23,r18
 1496 0588 60E0      		ldi r22,lo8(0)
 811:stk500boot.c  **** 						checksum		^=	c;
 1498               	.LM182:
 1499 058a C226      		eor r12,r18
 810:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 1501               	.LM183:
 1502 058c 83E0      		ldi r24,lo8(3)
 1503 058e A82E      		mov r10,r24
 1504               	.L173:
 728:stk500boot.c  **** 	if (boot_state==1)
 1506               	.LM184:
 1507 0590 20E0      		ldi r18,lo8(0)
 1508 0592 30E0      		ldi r19,hi8(0)
 1509 0594 00C0      		rjmp .L222
 1510               	.L171:
 779:stk500boot.c  **** 				switch (msgParseState)
 1512               	.LM185:
 1513 0596 8A2D      		mov r24,r10
 1514 0598 8530      		cpi r24,lo8(5)
 1515 059a 01F4      		brne .+2
 1516 059c 00C0      		rjmp .L169
 1517 059e 8530      		cpi r24,lo8(5)
 1518 05a0 00F4      		brsh .+2
 1519 05a2 00C0      		rjmp .L168
 1520 05a4 8630      		cpi r24,lo8(6)
 1521 05a6 01F4      		brne .+2
 1522 05a8 00C0      		rjmp .L313
 737:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 1524               	.LM186:
 1525 05aa BA2D      		mov r27,r10
 1526 05ac B730      		cpi r27,lo8(7)
 1527 05ae 01F4      		brne .L173
 1528               	.L230:
 1529 05b0 C25D      		subi r28,lo8(-302)
 1530 05b2 DE4F      		sbci r29,hi8(-302)
 1531 05b4 9882      		st Y,r9
 1532 05b6 CE52      		subi r28,lo8(302)
 1533 05b8 D140      		sbci r29,hi8(302)
 1534 05ba C15D      		subi r28,lo8(-303)
 1535 05bc DE4F      		sbci r29,hi8(-303)
 1536 05be F983      		std Y+1,r31
 1537 05c0 E883      		st Y,r30
 1538 05c2 CF52      		subi r28,lo8(303)
 1539 05c4 D140      		sbci r29,hi8(303)
 843:stk500boot.c  **** 						if ( c == checksum )
 1541               	.LM187:
 1542 05c6 9924      		clr r9
 1543               	.L123:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 1545               	.LM188:
 1546 05c8 E981      		ldd r30,Y+1
 1547 05ca E331      		cpi r30,lo8(19)
 1548 05cc 01F4      		brne .+2
 1549 05ce 00C0      		rjmp .L181
 1550 05d0 E431      		cpi r30,lo8(20)
 1551 05d2 00F0      		brlo .+2
 1552 05d4 00C0      		rjmp .L188
 1553 05d6 E630      		cpi r30,lo8(6)
 1554 05d8 01F4      		brne .+2
 1555 05da 00C0      		rjmp .L178
 1556 05dc E730      		cpi r30,lo8(7)
 1557 05de 00F0      		brlo .+2
 1558 05e0 00C0      		rjmp .L189
 1559 05e2 E230      		cpi r30,lo8(2)
 1560 05e4 01F4      		brne .+2
 1561 05e6 00C0      		rjmp .L307
 1562 05e8 E330      		cpi r30,lo8(3)
 1563 05ea 01F4      		brne .+2
 1564 05ec 00C0      		rjmp .L177
 1565 05ee E130      		cpi r30,lo8(1)
 1566 05f0 01F4      		brne .+2
 1567 05f2 00C0      		rjmp .L314
 1568               	.L174:
1178:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1570               	.LM189:
 1571 05f4 80EC      		ldi r24,lo8(-64)
 1572 05f6 8A83      		std Y+2,r24
1177:stk500boot.c  **** 					msgLength		=	2;
 1574               	.LM190:
 1575 05f8 82E0      		ldi r24,lo8(2)
 1576 05fa 90E0      		ldi r25,hi8(2)
1179:stk500boot.c  **** 					break;
 1578               	.LM191:
 1579 05fc 00C0      		rjmp .L194
 1580               	.L311:
 761:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1582               	.LM192:
 1583 05fe 8AE0      		ldi r24,lo8(10)
 1584 0600 E816      		cp r14,r24
 1585 0602 F104      		cpc r15,__zero_reg__
 1586 0604 00F0      		brlo .+2
 1587 0606 00C0      		rjmp .L225
 763:stk500boot.c  **** 					exPointCntr++;
 1589               	.LM193:
 1590 0608 4F5F      		subi r20,lo8(-(1))
 1591 060a 5F4F      		sbci r21,hi8(-(1))
 764:stk500boot.c  **** 					if (exPointCntr == 3)
 1593               	.LM194:
 1594 060c 4330      		cpi r20,3
 1595 060e 5105      		cpc r21,__zero_reg__
 1596 0610 01F0      		breq .+2
 1597 0612 00C0      		rjmp .L80
 1598 0614 C25D      		subi r28,lo8(-302)
 1599 0616 DE4F      		sbci r29,hi8(-302)
 1600 0618 9882      		st Y,r9
 1601 061a CE52      		subi r28,lo8(302)
 1602 061c D140      		sbci r29,hi8(302)
 1603 061e C15D      		subi r28,lo8(-303)
 1604 0620 DE4F      		sbci r29,hi8(-303)
 1605 0622 F983      		std Y+1,r31
 1606 0624 E883      		st Y,r30
 1607 0626 CF52      		subi r28,lo8(303)
 1608 0628 D140      		sbci r29,hi8(303)
 1609 062a 85E0      		ldi r24,lo8(5)
 1610 062c C82E      		mov r12,r24
 1611               	.L84:
 1612               	.LBB523:
 1613               	.LBB386:
 1614               	.LBB385:
 552:stk500boot.c  **** 				asm volatile(
 1616               	.LM195:
 1617 062e 99E1      		ldi r25,lo8(25)
 1618               	.L83:
 1619               	.LBE385:
 1620               	.LBE386:
 1621               	.LBE523:
 1622               	.LBB524:
 1623               	.LBB391:
 1624               	.LBB431:
 1625               	.LBB432:
 1626               	.LBB433:
 1627               	.LBB434:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 1629               	.LM196:
 1630 0630 A1E2      		ldi r26,lo8(33)
 1631 0632 A093 C600 		sts 198,r26
 1632               	.L82:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 1634               	.LM197:
 1635 0636 9090 C000 		lds r9,192
 1636 063a 96FE      		sbrs r9,6
 1637 063c 00C0      		rjmp .L82
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 1639               	.LM198:
 1640 063e 5091 C000 		lds r21,192
 1641 0642 5064      		ori r21,lo8(64)
 1642 0644 5093 C000 		sts 192,r21
 1643 0648 9150      		subi r25,lo8(-(-1))
 1644               	.LBE434:
 1645               	.LBE433:
2115:stk500boot.c  **** 		for (uint8_t jj=0; jj<25; jj++)
 1647               	.LM199:
 1648 064a 01F4      		brne .L83
 1649               	.LBE432:
2119:stk500boot.c  **** 		PrintNewLine();
 1651               	.LM200:
 1652 064c 0E94 0000 		call PrintNewLine
 1653 0650 CA94      		dec r12
2113:stk500boot.c  **** 	for (uint8_t ii=0; ii<5; ii++)
 1655               	.LM201:
 1656 0652 01F4      		brne .L84
 1657               	.LBE431:
2122:stk500boot.c  **** 	gRamIndex			=	0;
 1659               	.LM202:
 1660 0654 1092 0000 		sts gRamIndex,__zero_reg__
 1661 0658 1092 0000 		sts gRamIndex+1,__zero_reg__
 1662 065c 1092 0000 		sts gRamIndex+2,__zero_reg__
 1663 0660 1092 0000 		sts gRamIndex+3,__zero_reg__
2123:stk500boot.c  **** 	gFlashIndex			=	0;
 1665               	.LM203:
 1666 0664 1092 0000 		sts gFlashIndex,__zero_reg__
 1667 0668 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1668 066c 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1669 0670 1092 0000 		sts gFlashIndex+3,__zero_reg__
2124:stk500boot.c  **** 	gEepromIndex		=	0;
 1671               	.LM204:
 1672 0674 1092 0000 		sts gEepromIndex,__zero_reg__
 1673 0678 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1674 067c 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1675 0680 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1677               	.LM205:
 1678 0684 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1679 0686 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1680 0688 60E0      		ldi r22,lo8(0)
 1681 068a 0E94 0000 		call PrintFromPROGMEMln
 1682 068e C35C      		subi r28,lo8(-317)
 1683 0690 DE4F      		sbci r29,hi8(-317)
 1684 0692 F982      		std Y+1,r15
 1685 0694 E882      		st Y,r14
 1686 0696 CD53      		subi r28,lo8(317)
 1687 0698 D140      		sbci r29,hi8(317)
 1688 069a C15C      		subi r28,lo8(-319)
 1689 069c DE4F      		sbci r29,hi8(-319)
 1690 069e 1983      		std Y+1,r17
 1691 06a0 0883      		st Y,r16
 1692 06a2 CF53      		subi r28,lo8(319)
 1693 06a4 D140      		sbci r29,hi8(319)
 1694               	.L298:
2127:stk500boot.c  **** 
2128:stk500boot.c  **** 	keepGoing	=	1;
2129:stk500boot.c  **** 	while (keepGoing)
2130:stk500boot.c  **** 	{
2131:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1696               	.LM206:
 1697 06a6 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1698 06a8 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1699 06aa 60E0      		ldi r22,lo8(0)
 1700 06ac 0E94 0000 		call PrintFromPROGMEM
 1701               	.L86:
 1702               	.LBB429:
 1703               	.LBB430:
 524:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 1705               	.LM207:
 1706 06b0 C090 C000 		lds r12,192
 1707 06b4 C7FE      		sbrs r12,7
 1708 06b6 00C0      		rjmp .L86
 528:stk500boot.c  **** 	return UART_DATA_REG;
 1710               	.LM208:
 1711 06b8 8091 C600 		lds r24,198
 1712               	.LBE430:
 1713               	.LBE429:
2132:stk500boot.c  **** 		theChar	=	recchar();
2133:stk500boot.c  **** 		if (theChar >= 0x60)
 1715               	.LM209:
 1716 06bc 8036      		cpi r24,lo8(96)
 1717 06be 00F0      		brlo .L87
2134:stk500boot.c  **** 		{
2135:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1719               	.LM210:
 1720 06c0 8F75      		andi r24,lo8(95)
 1721               	.L87:
2136:stk500boot.c  **** 		}
2137:stk500boot.c  **** 
2138:stk500boot.c  **** 		if (theChar >= 0x20)
 1723               	.LM211:
 1724 06c2 8032      		cpi r24,lo8(32)
 1725 06c4 00F0      		brlo .L88
 1726               	.LBB427:
 1727               	.LBB428:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 1729               	.LM212:
 1730 06c6 8093 C600 		sts 198,r24
 1731               	.L89:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 1733               	.LM213:
 1734 06ca D090 C000 		lds r13,192
 1735 06ce D6FE      		sbrs r13,6
 1736 06d0 00C0      		rjmp .L89
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 1738               	.LM214:
 1739 06d2 7091 C000 		lds r23,192
 1740 06d6 7064      		ori r23,lo8(64)
 1741 06d8 7093 C000 		sts 192,r23
 1742               	.LBE428:
 1743               	.LBE427:
 1744               	.LBB425:
 1745               	.LBB426:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 1747               	.LM215:
 1748 06dc 60E2      		ldi r22,lo8(32)
 1749 06de 6093 C600 		sts 198,r22
 1750               	.L90:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 1752               	.LM216:
 1753 06e2 E090 C000 		lds r14,192
 1754 06e6 E6FE      		sbrs r14,6
 1755 06e8 00C0      		rjmp .L90
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 1757               	.LM217:
 1758 06ea B091 C000 		lds r27,192
 1759 06ee B064      		ori r27,lo8(64)
 1760 06f0 B093 C000 		sts 192,r27
 1761               	.L88:
 1762               	.LBE426:
 1763               	.LBE425:
2139:stk500boot.c  **** 		{
2140:stk500boot.c  **** 			sendchar(theChar);
2141:stk500boot.c  **** 			sendchar(0x20);
2142:stk500boot.c  **** 
2143:stk500boot.c  **** #ifdef _DEBUG_SERIAL1_
2144:stk500boot.c  **** 			sendchar1(theChar);
2145:stk500boot.c  **** #endif
2146:stk500boot.c  **** 		}
2147:stk500boot.c  **** 
2148:stk500boot.c  **** 		switch(theChar)
 1765               	.LM218:
 1766 06f4 8834      		cpi r24,lo8(72)
 1767 06f6 01F4      		brne .+2
 1768 06f8 00C0      		rjmp .L98
 1769 06fa 8934      		cpi r24,lo8(73)
 1770 06fc 00F0      		brlo .+2
 1771 06fe 00C0      		rjmp .L104
 1772 0700 8234      		cpi r24,lo8(66)
 1773 0702 01F4      		brne .+2
 1774 0704 00C0      		rjmp .L95
 1775 0706 8334      		cpi r24,lo8(67)
 1776 0708 00F0      		brlo .+2
 1777 070a 00C0      		rjmp .L105
 1778 070c 8033      		cpi r24,lo8(48)
 1779 070e 01F4      		brne .+2
 1780 0710 00C0      		rjmp .L92
 1781 0712 8033      		cpi r24,lo8(48)
 1782 0714 00F0      		brlo .L91
 1783 0716 8F33      		cpi r24,lo8(63)
 1784 0718 01F4      		brne .+2
 1785 071a 00C0      		rjmp .L93
 1786 071c 8034      		cpi r24,lo8(64)
 1787 071e 01F4      		brne .+2
 1788 0720 00C0      		rjmp .L315
 1789               	.L91:
2149:stk500boot.c  **** 		{
2150:stk500boot.c  **** 			case '0':
2151:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2152:stk500boot.c  **** 				gFlashIndex		=	0;
2153:stk500boot.c  **** 				gRamIndex		=	0;
2154:stk500boot.c  **** 				gEepromIndex	=	0;
2155:stk500boot.c  **** 				break;
2156:stk500boot.c  **** 
2157:stk500boot.c  **** 			case '?':
2158:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
2159:stk500boot.c  **** 				PrintCPUstats();
2160:stk500boot.c  **** 				break;
2161:stk500boot.c  **** 
2162:stk500boot.c  **** 			case '@':
2163:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2164:stk500boot.c  **** 				EEPROMtest();
2165:stk500boot.c  **** 				break;
2166:stk500boot.c  **** 
2167:stk500boot.c  **** 			case 'B':
2168:stk500boot.c  **** 			case 'b':
2169:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2170:stk500boot.c  **** 				BlinkLED();
2171:stk500boot.c  **** 				break;
2172:stk500boot.c  **** 
2173:stk500boot.c  **** 			case 'E':
2174:stk500boot.c  **** 			case 'e':
2175:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
2176:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
2177:stk500boot.c  **** 				gEepromIndex	+=	256;
2178:stk500boot.c  **** 				if (gEepromIndex > E2END)
2179:stk500boot.c  **** 					gEepromIndex	=	0;
2180:stk500boot.c  **** 
2181:stk500boot.c  **** 				break;
2182:stk500boot.c  **** 
2183:stk500boot.c  **** 			case 'F':
2184:stk500boot.c  **** 			case 'f':
2185:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2186:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2187:stk500boot.c  **** 				gFlashIndex	+=	256;
2188:stk500boot.c  **** 				break;
2189:stk500boot.c  **** 
2190:stk500boot.c  **** 			case 'H':
2191:stk500boot.c  **** 			case 'h':
2192:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2193:stk500boot.c  **** 				PrintHelp();
2194:stk500boot.c  **** 				break;
2195:stk500boot.c  **** 
2196:stk500boot.c  **** 			case 'L':
2197:stk500boot.c  **** 			case 'l':
2198:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
2199:stk500boot.c  **** 				ListAvailablePorts();
2200:stk500boot.c  **** 				break;
2201:stk500boot.c  **** 
2202:stk500boot.c  **** 			case 'Q':
2203:stk500boot.c  **** 			case 'q':
2204:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2205:stk500boot.c  **** 				keepGoing	=	false;
2206:stk500boot.c  **** 				break;
2207:stk500boot.c  **** 
2208:stk500boot.c  **** 			case 'R':
2209:stk500boot.c  **** 			case 'r':
2210:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
2211:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
2212:stk500boot.c  **** 				gRamIndex	+=	256;
2213:stk500boot.c  **** 				break;
2214:stk500boot.c  **** 
2215:stk500boot.c  **** 			case 'V':
2216:stk500boot.c  **** 			case 'v':
2217:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
2218:stk500boot.c  **** 				VectorDisplay();
2219:stk500boot.c  **** 				break;
2220:stk500boot.c  **** 
2221:stk500boot.c  **** 			case 'Y':
2222:stk500boot.c  **** 			case 'y':
2223:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
2224:stk500boot.c  **** 				AVR_PortOutput();
2225:stk500boot.c  **** 				break;
2226:stk500boot.c  **** 
2227:stk500boot.c  **** 			default:
2228:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 1791               	.LM219:
 1792 0722 80E0      		ldi r24,lo8(gTextMsg_HUH)
 1793 0724 90E0      		ldi r25,hi8(gTextMsg_HUH)
 1794 0726 60E0      		ldi r22,lo8(0)
 1795 0728 0E94 0000 		call PrintFromPROGMEMln
 1796 072c 00C0      		rjmp .L298
 1797               	.L313:
 1798               	.LBE391:
 1799               	.LBE524:
 843:stk500boot.c  **** 						if ( c == checksum )
 1801               	.LM220:
 1802 072e 2C15      		cp r18,r12
 1803 0730 01F4      		brne .+2
 1804 0732 00C0      		rjmp .L230
 1805               	.L228:
 829:stk500boot.c  **** 							msgParseState	=	ST_START;
 1807               	.LM221:
 1808 0734 AA24      		clr r10
 1809 0736 00C0      		rjmp .L173
 1810               	.L168:
 821:stk500boot.c  **** 						if ( c == TOKEN )
 1812               	.LM222:
 1813 0738 2E30      		cpi r18,lo8(14)
 1814 073a 01F4      		brne .L228
 824:stk500boot.c  **** 							checksum		^=	c;
 1816               	.LM223:
 1817 073c C226      		eor r12,r18
 825:stk500boot.c  **** 							ii				=	0;
 1819               	.LM224:
 1820 073e E0E0      		ldi r30,lo8(0)
 1821 0740 F0E0      		ldi r31,hi8(0)
 823:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 1823               	.LM225:
 1824 0742 A5E0      		ldi r26,lo8(5)
 1825 0744 AA2E      		mov r10,r26
 1826 0746 00C0      		rjmp .L173
 1827               	.L169:
 834:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 1829               	.LM226:
 1830 0748 A1E0      		ldi r26,lo8(1)
 1831 074a B0E0      		ldi r27,hi8(1)
 1832 074c AC0F      		add r26,r28
 1833 074e BD1F      		adc r27,r29
 1834 0750 AE0F      		add r26,r30
 1835 0752 BF1F      		adc r27,r31
 1836 0754 2C93      		st X,r18
 1837 0756 3196      		adiw r30,1
 835:stk500boot.c  **** 						checksum		^=	c;
 1839               	.LM227:
 1840 0758 C226      		eor r12,r18
 836:stk500boot.c  **** 						if (ii == msgLength )
 1842               	.LM228:
 1843 075a E617      		cp r30,r22
 1844 075c F707      		cpc r31,r23
 1845 075e 01F0      		breq .+2
 1846 0760 00C0      		rjmp .L173
 838:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 1848               	.LM229:
 1849 0762 36E0      		ldi r19,lo8(6)
 1850 0764 A32E      		mov r10,r19
 1851 0766 00C0      		rjmp .L173
 1852               	.L312:
 782:stk500boot.c  **** 						if ( c == MESSAGE_START )
 1854               	.LM230:
 1855 0768 2B31      		cpi r18,lo8(27)
 1856 076a 01F0      		breq .+2
 1857 076c 00C0      		rjmp .L173
 785:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 1859               	.LM231:
 1860 076e ABE1      		ldi r26,lo8(27)
 1861 0770 CA2E      		mov r12,r26
 784:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 1863               	.LM232:
 1864 0772 AA24      		clr r10
 1865 0774 A394      		inc r10
 1866 0776 00C0      		rjmp .L173
 1867               	.L165:
 793:stk500boot.c  **** 						checksum		^=	c;
 1869               	.LM233:
 1870 0778 C226      		eor r12,r18
 806:stk500boot.c  **** 						break;
 1872               	.LM234:
 1873 077a 922E      		mov r9,r18
 792:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 1875               	.LM235:
 1876 077c 92E0      		ldi r25,lo8(2)
 1877 077e A92E      		mov r10,r25
 806:stk500boot.c  **** 						break;
 1879               	.LM236:
 1880 0780 00C0      		rjmp .L173
 1881               	.L167:
 815:stk500boot.c  **** 						msgLength		|=	c;
 1883               	.LM237:
 1884 0782 822F      		mov r24,r18
 1885 0784 90E0      		ldi r25,lo8(0)
 1886 0786 682B      		or r22,r24
 1887 0788 792B      		or r23,r25
 817:stk500boot.c  **** 						checksum		^=	c;
 1889               	.LM238:
 1890 078a C226      		eor r12,r18
 816:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 1892               	.LM239:
 1893 078c B4E0      		ldi r27,lo8(4)
 1894 078e AB2E      		mov r10,r27
 818:stk500boot.c  **** 						break;
 1896               	.LM240:
 1897 0790 00C0      		rjmp .L173
 1898               	.L104:
 1899               	.LBB525:
 1900               	.LBB518:
2148:stk500boot.c  **** 		switch(theChar)
 1902               	.LM241:
 1903 0792 8235      		cpi r24,lo8(82)
 1904 0794 01F4      		brne .+2
 1905 0796 00C0      		rjmp .L101
 1906 0798 8335      		cpi r24,lo8(83)
 1907 079a 00F0      		brlo .+2
 1908 079c 00C0      		rjmp .L106
 1909 079e 8C34      		cpi r24,lo8(76)
 1910 07a0 01F4      		brne .+2
 1911 07a2 00C0      		rjmp .L99
 1912 07a4 8135      		cpi r24,lo8(81)
 1913 07a6 01F0      		breq .+2
 1914 07a8 00C0      		rjmp .L91
 1915 07aa C35C      		subi r28,lo8(-317)
 1916 07ac DE4F      		sbci r29,hi8(-317)
 1917 07ae E880      		ld r14,Y
 1918 07b0 F980      		ldd r15,Y+1
 1919 07b2 CD53      		subi r28,lo8(317)
 1920 07b4 D140      		sbci r29,hi8(317)
 1921 07b6 C15C      		subi r28,lo8(-319)
 1922 07b8 DE4F      		sbci r29,hi8(-319)
 1923 07ba 0881      		ld r16,Y
 1924 07bc 1981      		ldd r17,Y+1
 1925 07be CF53      		subi r28,lo8(319)
 1926 07c0 D140      		sbci r29,hi8(319)
2204:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
 1928               	.LM242:
 1929 07c2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1930 07c4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1931 07c6 62E0      		ldi r22,lo8(2)
 1932 07c8 0E94 0000 		call PrintFromPROGMEMln
 767:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we don't get in an endless loop
 1934               	.LM243:
 1935 07cc 40E0      		ldi r20,lo8(0)
 1936 07ce 50E0      		ldi r21,hi8(0)
 768:stk500boot.c  **** 						isLeave			=	1;
 1938               	.LM244:
 1939 07d0 9924      		clr r9
 1940 07d2 9394      		inc r9
 1941 07d4 00C0      		rjmp .L123
 1942               	.L188:
 1943               	.LBE518:
 1944               	.LBE525:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 1946               	.LM245:
 1947 07d6 E831      		cpi r30,lo8(24)
 1948 07d8 01F4      		brne .+2
 1949 07da 00C0      		rjmp .L183
 1950 07dc E931      		cpi r30,lo8(25)
 1951 07de 00F0      		brlo .+2
 1952 07e0 00C0      		rjmp .L190
 1953 07e2 E531      		cpi r30,lo8(21)
 1954 07e4 01F4      		brne .+2
 1955 07e6 00C0      		rjmp .L181
 1956 07e8 E531      		cpi r30,lo8(21)
 1957 07ea 00F0      		brlo .L182
 1958 07ec E631      		cpi r30,lo8(22)
 1959 07ee 01F0      		breq .+2
 1960 07f0 00C0      		rjmp .L174
 1961               	.L182:
 1962               	.LBB526:
1137:stk500boot.c  **** 						uint16_t	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 1964               	.LM246:
 1965 07f2 7A80      		ldd r7,Y+2
 1966 07f4 C55C      		subi r28,lo8(-315)
 1967 07f6 DE4F      		sbci r29,hi8(-315)
 1968 07f8 7882      		st Y,r7
 1969 07fa CB53      		subi r28,lo8(315)
 1970 07fc D140      		sbci r29,hi8(315)
 1971 07fe C65C      		subi r28,lo8(-314)
 1972 0800 DE4F      		sbci r29,hi8(-314)
 1973 0802 1882      		st Y,__zero_reg__
 1974 0804 CA53      		subi r28,lo8(314)
 1975 0806 D140      		sbci r29,hi8(314)
 1976 0808 6B81      		ldd r22,Y+3
 1977 080a 70E0      		ldi r23,lo8(0)
 1978 080c C65C      		subi r28,lo8(-314)
 1979 080e DE4F      		sbci r29,hi8(-314)
 1980 0810 A881      		ld r26,Y
 1981 0812 B981      		ldd r27,Y+1
 1982 0814 CA53      		subi r28,lo8(314)
 1983 0816 D140      		sbci r29,hi8(314)
 1984 0818 6A2B      		or r22,r26
 1985 081a 7B2B      		or r23,r27
1139:stk500boot.c  **** 						msgLength				=	size+3;
 1987               	.LM247:
 1988 081c CB01      		movw r24,r22
 1989 081e 0396      		adiw r24,3
1141:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 1991               	.LM248:
 1992 0820 1A82      		std Y+2,__zero_reg__
1142:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 1994               	.LM249:
 1995 0822 E431      		cpi r30,lo8(20)
 1996 0824 01F4      		brne .+2
 1997 0826 00C0      		rjmp .L316
 1998               	.LBB527:
1141:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 2000               	.LM250:
 2001 0828 FE01      		movw r30,r28
 2002 082a 3396      		adiw r30,3
 571:stk500boot.c  **** int main(void)
 2004               	.LM251:
 2005 082c DB01      		movw r26,r22
 2006 082e 1197      		sbiw r26,1
 2007 0830 2D01      		movw r4,r26
 2008 0832 6624      		clr r6
 2009 0834 7724      		clr r7
 2010 0836 0894      		sec
 2011 0838 411C      		adc r4,__zero_reg__
 2012 083a 511C      		adc r5,__zero_reg__
 2013 083c 611C      		adc r6,__zero_reg__
 2014 083e 711C      		adc r7,__zero_reg__
 2015 0840 CA5D      		subi r28,lo8(-294)
 2016 0842 DE4F      		sbci r29,hi8(-294)
 2017 0844 A880      		ld r10,Y
 2018 0846 B980      		ldd r11,Y+1
 2019 0848 CA80      		ldd r12,Y+2
 2020 084a DB80      		ldd r13,Y+3
 2021 084c C652      		subi r28,lo8(294)
 2022 084e D140      		sbci r29,hi8(294)
 2023 0850 4A0C      		add r4,r10
 2024 0852 5B1C      		adc r5,r11
 2025 0854 6C1C      		adc r6,r12
 2026 0856 7D1C      		adc r7,r13
 2027 0858 9C01      		movw r18,r24
 2028               	.L212:
 2029               	.LBE527:
1164:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
 2031               	.LM252:
 2032 085a A1BC      		out 65-32,r10
1165:stk500boot.c  **** 								EEARH	=	((address >> 8));
 2034               	.LM253:
 2035 085c BB27      		clr r27
 2036 085e AD2D      		mov r26,r13
 2037 0860 9C2D      		mov r25,r12
 2038 0862 8B2D      		mov r24,r11
 2039 0864 82BD      		out 66-32,r24
1166:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 2041               	.LM254:
 2042 0866 0894      		sec
 2043 0868 A11C      		adc r10,__zero_reg__
 2044 086a B11C      		adc r11,__zero_reg__
 2045 086c C11C      		adc r12,__zero_reg__
 2046 086e D11C      		adc r13,__zero_reg__
1167:stk500boot.c  **** 								EECR	|=	_BV(EERE);			// Read EEPROM
 2048               	.LM255:
 2049 0870 F89A      		sbi 63-32,0
1168:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 2051               	.LM256:
 2052 0872 80B5      		in r24,64-32
 2053 0874 8193      		st Z+,r24
 2054 0876 DF01      		movw r26,r30
1170:stk500boot.c  **** 							} while (size);
 2056               	.LM257:
 2057 0878 A414      		cp r10,r4
 2058 087a B504      		cpc r11,r5
 2059 087c C604      		cpc r12,r6
 2060 087e D704      		cpc r13,r7
 2061 0880 01F4      		brne .L212
 2062               	.L306:
 2063 0882 CA5D      		subi r28,lo8(-294)
 2064 0884 DE4F      		sbci r29,hi8(-294)
 2065 0886 A882      		st Y,r10
 2066 0888 B982      		std Y+1,r11
 2067 088a CA82      		std Y+2,r12
 2068 088c DB82      		std Y+3,r13
 2069 088e C652      		subi r28,lo8(294)
 2070 0890 D140      		sbci r29,hi8(294)
 2071 0892 C901      		movw r24,r18
1172:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 2073               	.LM258:
 2074 0894 1C92      		st X,__zero_reg__
 2075               	.LBE526:
1174:stk500boot.c  **** 					break;
 2077               	.LM259:
 2078 0896 00C0      		rjmp .L194
 2079               	.L178:
1065:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 2081               	.LM260:
 2082 0898 8A81      		ldd r24,Y+2
 2083 089a 90E0      		ldi r25,lo8(0)
 2084 089c A0E0      		ldi r26,lo8(0)
 2085 089e B0E0      		ldi r27,hi8(0)
 2086 08a0 782E      		mov r7,r24
 2087 08a2 6624      		clr r6
 2088 08a4 5524      		clr r5
 2089 08a6 4424      		clr r4
 2090 08a8 8B81      		ldd r24,Y+3
 2091 08aa 90E0      		ldi r25,lo8(0)
 2092 08ac A0E0      		ldi r26,lo8(0)
 2093 08ae B0E0      		ldi r27,hi8(0)
 2094 08b0 DC01      		movw r26,r24
 2095 08b2 9927      		clr r25
 2096 08b4 8827      		clr r24
 2097 08b6 482A      		or r4,r24
 2098 08b8 592A      		or r5,r25
 2099 08ba 6A2A      		or r6,r26
 2100 08bc 7B2A      		or r7,r27
 2101 08be 8D81      		ldd r24,Y+5
 2102 08c0 90E0      		ldi r25,lo8(0)
 2103 08c2 A0E0      		ldi r26,lo8(0)
 2104 08c4 B0E0      		ldi r27,hi8(0)
 2105 08c6 482A      		or r4,r24
 2106 08c8 592A      		or r5,r25
 2107 08ca 6A2A      		or r6,r26
 2108 08cc 7B2A      		or r7,r27
 2109 08ce 8C81      		ldd r24,Y+4
 2110 08d0 90E0      		ldi r25,lo8(0)
 2111 08d2 A0E0      		ldi r26,lo8(0)
 2112 08d4 B0E0      		ldi r27,hi8(0)
 2113 08d6 BA2F      		mov r27,r26
 2114 08d8 A92F      		mov r26,r25
 2115 08da 982F      		mov r25,r24
 2116 08dc 8827      		clr r24
 2117 08de 482A      		or r4,r24
 2118 08e0 592A      		or r5,r25
 2119 08e2 6A2A      		or r6,r26
 2120 08e4 7B2A      		or r7,r27
 2121 08e6 440C      		lsl r4
 2122 08e8 551C      		rol r5
 2123 08ea 661C      		rol r6
 2124 08ec 771C      		rol r7
 2125               	.L308:
 2126 08ee CA5D      		subi r28,lo8(-294)
 2127 08f0 DE4F      		sbci r29,hi8(-294)
 2128 08f2 4882      		st Y,r4
 2129 08f4 5982      		std Y+1,r5
 2130 08f6 6A82      		std Y+2,r6
 2131 08f8 7B82      		std Y+3,r7
 2132 08fa C652      		subi r28,lo8(294)
 2133 08fc D140      		sbci r29,hi8(294)
 2134               	.L307:
1070:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 2136               	.LM261:
 2137 08fe 1A82      		std Y+2,__zero_reg__
1069:stk500boot.c  **** 					msgLength		=	2;
 2139               	.LM262:
 2140 0900 82E0      		ldi r24,lo8(2)
 2141 0902 90E0      		ldi r25,hi8(2)
 2142               	.L194:
 2143               	.LBB530:
 2144               	.LBB531:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2146               	.LM263:
 2147 0904 3BE1      		ldi r19,lo8(27)
 2148 0906 3093 C600 		sts 198,r19
 2149               	.L213:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2151               	.LM264:
 2152 090a C090 C000 		lds r12,192
 2153 090e C6FE      		sbrs r12,6
 2154 0910 00C0      		rjmp .L213
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2156               	.LM265:
 2157 0912 6091 C000 		lds r22,192
 2158 0916 6064      		ori r22,lo8(64)
 2159 0918 6093 C000 		sts 192,r22
 2160               	.LBE531:
 2161               	.LBE530:
 2162               	.LBB532:
 2163               	.LBB533:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2165               	.LM266:
 2166 091c C25D      		subi r28,lo8(-302)
 2167 091e DE4F      		sbci r29,hi8(-302)
 2168 0920 B880      		ld r11,Y
 2169 0922 CE52      		subi r28,lo8(302)
 2170 0924 D140      		sbci r29,hi8(302)
 2171 0926 B092 C600 		sts 198,r11
 2172               	.L214:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2174               	.LM267:
 2175 092a D090 C000 		lds r13,192
 2176 092e D6FE      		sbrs r13,6
 2177 0930 00C0      		rjmp .L214
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2179               	.LM268:
 2180 0932 7091 C000 		lds r23,192
 2181 0936 7064      		ori r23,lo8(64)
 2182 0938 7093 C000 		sts 192,r23
 2183               	.LBE533:
 2184               	.LBE532:
1201:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
 2186               	.LM269:
 2187 093c 392F      		mov r19,r25
 2188               	.LBB534:
 2189               	.LBB535:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2191               	.LM270:
 2192 093e 9093 C600 		sts 198,r25
 2193               	.L215:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2195               	.LM271:
 2196 0942 B091 C000 		lds r27,192
 2197 0946 B6FF      		sbrs r27,6
 2198 0948 00C0      		rjmp .L215
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2200               	.LM272:
 2201 094a E091 C000 		lds r30,192
 2202 094e E064      		ori r30,lo8(64)
 2203 0950 E093 C000 		sts 192,r30
 2204               	.LBE535:
 2205               	.LBE534:
1205:stk500boot.c  **** 			c			=	msgLength&0x00FF;
 2207               	.LM273:
 2208 0954 682F      		mov r22,r24
 2209               	.LBB536:
 2210               	.LBB537:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2212               	.LM274:
 2213 0956 8093 C600 		sts 198,r24
 2214               	.L216:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2216               	.LM275:
 2217 095a 2091 C000 		lds r18,192
 2218 095e 26FF      		sbrs r18,6
 2219 0960 00C0      		rjmp .L216
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2221               	.LM276:
 2222 0962 A091 C000 		lds r26,192
 2223 0966 A064      		ori r26,lo8(64)
 2224 0968 A093 C000 		sts 192,r26
 2225               	.LBE537:
 2226               	.LBE536:
 2227               	.LBB538:
 2228               	.LBB539:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2230               	.LM277:
 2231 096c FEE0      		ldi r31,lo8(14)
 2232 096e F093 C600 		sts 198,r31
 2233               	.L217:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2235               	.LM278:
 2236 0972 C090 C000 		lds r12,192
 2237 0976 C6FE      		sbrs r12,6
 2238 0978 00C0      		rjmp .L217
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2240               	.LM279:
 2241 097a 7091 C000 		lds r23,192
 2242 097e 7064      		ori r23,lo8(64)
 2243 0980 7093 C000 		sts 192,r23
 2244               	.LBE539:
 2245               	.LBE538:
1203:stk500boot.c  **** 			checksum	^=	c;
 2247               	.LM280:
 2248 0984 B5E1      		ldi r27,lo8(21)
 2249 0986 CB2E      		mov r12,r27
 2250 0988 C25D      		subi r28,lo8(-302)
 2251 098a DE4F      		sbci r29,hi8(-302)
 2252 098c D880      		ld r13,Y
 2253 098e CE52      		subi r28,lo8(302)
 2254 0990 D140      		sbci r29,hi8(302)
 2255 0992 CD24      		eor r12,r13
1207:stk500boot.c  **** 			checksum ^= c;
 2257               	.LM281:
 2258 0994 C626      		eor r12,r22
1210:stk500boot.c  **** 			checksum ^= TOKEN;
 2260               	.LM282:
 2261 0996 C326      		eor r12,r19
1213:stk500boot.c  **** 			while ( msgLength )
 2263               	.LM283:
 2264 0998 0097      		sbiw r24,0
 2265 099a 01F0      		breq .L218
 2266 099c FE01      		movw r30,r28
 2267 099e 3196      		adiw r30,1
 2268               	.L220:
1215:stk500boot.c  **** 				c	=	*p++;
 2270               	.LM284:
 2271 09a0 3191      		ld r19,Z+
 2272               	.LBB540:
 2273               	.LBB541:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2275               	.LM285:
 2276 09a2 3093 C600 		sts 198,r19
 2277               	.L219:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2279               	.LM286:
 2280 09a6 6091 C000 		lds r22,192
 2281 09aa 66FF      		sbrs r22,6
 2282 09ac 00C0      		rjmp .L219
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2284               	.LM287:
 2285 09ae B091 C000 		lds r27,192
 2286 09b2 B064      		ori r27,lo8(64)
 2287 09b4 B093 C000 		sts 192,r27
 2288               	.LBE541:
 2289               	.LBE540:
1217:stk500boot.c  **** 				checksum ^=c;
 2291               	.LM288:
 2292 09b8 C326      		eor r12,r19
1218:stk500boot.c  **** 				msgLength--;
 2294               	.LM289:
 2295 09ba 0197      		sbiw r24,1
1213:stk500boot.c  **** 			while ( msgLength )
 2297               	.LM290:
 2298 09bc 01F4      		brne .L220
 2299               	.L218:
 2300               	.LBB542:
 2301               	.LBB543:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2303               	.LM291:
 2304 09be C092 C600 		sts 198,r12
 2305               	.L221:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2307               	.LM292:
 2308 09c2 9091 C000 		lds r25,192
 2309 09c6 96FF      		sbrs r25,6
 2310 09c8 00C0      		rjmp .L221
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2312               	.LM293:
 2313 09ca 3091 C000 		lds r19,192
 2314 09ce 3064      		ori r19,lo8(64)
 2315 09d0 3093 C000 		sts 192,r19
 2316               	.LBE543:
 2317               	.LBE542:
1225:stk500boot.c  **** 			PROGLED_PORT	^=	_BV(PROGLED_PIN);	// active high LED ON
 2319               	.LM294:
 2320 09d4 85B1      		in r24,37-32
 2321 09d6 8058      		subi r24,lo8(-(-128))
 2322 09d8 85B9      		out 37-32,r24
 731:stk500boot.c  **** 		while (!isLeave)
 2324               	.LM295:
 2325 09da 9920      		tst r9
 2326 09dc 01F0      		breq .+2
 2327 09de 00C0      		rjmp .L73
1221:stk500boot.c  **** 			seqNum++;
 2329               	.LM296:
 2330 09e0 C25D      		subi r28,lo8(-302)
 2331 09e2 DE4F      		sbci r29,hi8(-302)
 2332 09e4 E881      		ld r30,Y
 2333 09e6 CE52      		subi r28,lo8(302)
 2334 09e8 D140      		sbci r29,hi8(302)
 2335 09ea EF5F      		subi r30,lo8(-(1))
 2336 09ec C25D      		subi r28,lo8(-302)
 2337 09ee DE4F      		sbci r29,hi8(-302)
 2338 09f0 E883      		st Y,r30
 2339 09f2 CE52      		subi r28,lo8(302)
 2340 09f4 D140      		sbci r29,hi8(302)
 2341 09f6 20E0      		ldi r18,lo8(0)
 2342 09f8 30E0      		ldi r19,hi8(0)
 2343 09fa 00C0      		rjmp .L74
 2344               	.L189:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 2346               	.LM297:
 2347 09fc E131      		cpi r30,lo8(17)
 2348 09fe 01F4      		brne .+2
 2349 0a00 00C0      		rjmp .L231
 2350 0a02 E231      		cpi r30,lo8(18)
 2351 0a04 00F4      		brsh .+2
 2352 0a06 00C0      		rjmp .L317
1060:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	issue 543, return FAILED instead of OK
 2354               	.LM298:
 2355 0a08 E0EC      		ldi r30,lo8(-64)
 2356 0a0a EA83      		std Y+2,r30
1058:stk500boot.c  **** 					msgLength		=	2;
 2358               	.LM299:
 2359 0a0c 82E0      		ldi r24,lo8(2)
 2360 0a0e 90E0      		ldi r25,hi8(2)
1057:stk500boot.c  **** 					eraseAddress	=	0;
 2362               	.LM300:
 2363 0a10 CF5C      		subi r28,lo8(-305)
 2364 0a12 DE4F      		sbci r29,hi8(-305)
 2365 0a14 1882      		st Y,__zero_reg__
 2366 0a16 1982      		std Y+1,__zero_reg__
 2367 0a18 1A82      		std Y+2,__zero_reg__
 2368 0a1a 1B82      		std Y+3,__zero_reg__
 2369 0a1c C153      		subi r28,lo8(305)
 2370 0a1e D140      		sbci r29,hi8(305)
1061:stk500boot.c  **** 					break;
 2372               	.LM301:
 2373 0a20 00C0      		rjmp .L194
 2374               	.L106:
 2375               	.LBB544:
 2376               	.LBB390:
2148:stk500boot.c  **** 		switch(theChar)
 2378               	.LM302:
 2379 0a22 8635      		cpi r24,lo8(86)
 2380 0a24 01F4      		brne .+2
 2381 0a26 00C0      		rjmp .L102
 2382 0a28 8935      		cpi r24,lo8(89)
 2383 0a2a 01F0      		breq .+2
 2384 0a2c 00C0      		rjmp .L91
2223:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2386               	.LM303:
 2387 0a2e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2388 0a30 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2389 0a32 62E0      		ldi r22,lo8(2)
 2390 0a34 0E94 0000 		call PrintFromPROGMEMln
 2391               	.LBB395:
 2392               	.LBB398:
1904:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
 2394               	.LM304:
 2395 0a38 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2396 0a3a 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2397 0a3c 60E0      		ldi r22,lo8(0)
 2398 0a3e 0E94 0000 		call PrintFromPROGMEM
 2399               	.L143:
 2400               	.LBB406:
 2401               	.LBB407:
 524:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 2403               	.LM305:
 2404 0a42 B090 C000 		lds r11,192
 2405 0a46 B7FE      		sbrs r11,7
 2406 0a48 00C0      		rjmp .L143
 528:stk500boot.c  **** 	return UART_DATA_REG;
 2408               	.LM306:
 2409 0a4a 0091 C600 		lds r16,198
 2410               	.LBE407:
 2411               	.LBE406:
1907:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2413               	.LM307:
 2414 0a4e 0F75      		andi r16,lo8(95)
 2415               	.LBB408:
 2416               	.LBB409:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2418               	.LM308:
 2419 0a50 0093 C600 		sts 198,r16
 2420               	.L144:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2422               	.LM309:
 2423 0a54 9090 C000 		lds r9,192
 2424 0a58 96FE      		sbrs r9,6
 2425 0a5a 00C0      		rjmp .L144
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2427               	.LM310:
 2428 0a5c 2091 C000 		lds r18,192
 2429 0a60 2064      		ori r18,lo8(64)
 2430 0a62 2093 C000 		sts 192,r18
 2431               	.LBE409:
 2432               	.LBE408:
1909:stk500boot.c  **** 	PrintNewLine();
 2434               	.LM311:
 2435 0a66 0E94 0000 		call PrintNewLine
1911:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
 2437               	.LM312:
 2438 0a6a 802F      		mov r24,r16
 2439 0a6c 8154      		subi r24,lo8(-(-65))
 2440 0a6e 8A31      		cpi r24,lo8(26)
 2441 0a70 00F0      		brlo .+2
 2442 0a72 00C0      		rjmp .L145
1914:stk500boot.c  **** 		switch(portLetter)
 2444               	.LM313:
 2445 0a74 0234      		cpi r16,lo8(66)
 2446 0a76 01F4      		brne .+2
 2447 0a78 00C0      		rjmp .L148
 2448 0a7a 0334      		cpi r16,lo8(67)
 2449 0a7c 00F0      		brlo .+2
 2450 0a7e 00C0      		rjmp .L151
 2451 0a80 0134      		cpi r16,lo8(65)
 2452 0a82 01F4      		brne .+2
 2453 0a84 00C0      		rjmp .L318
 2454               	.L146:
2061:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
 2456               	.LM314:
 2457 0a86 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2458 0a88 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2459 0a8a 60E0      		ldi r22,lo8(0)
 2460 0a8c 0E94 0000 		call PrintFromPROGMEMln
 2461 0a90 00C0      		rjmp .L298
 2462               	.L105:
 2463               	.LBE398:
 2464               	.LBE395:
2148:stk500boot.c  **** 		switch(theChar)
 2466               	.LM315:
 2467 0a92 8534      		cpi r24,lo8(69)
 2468 0a94 01F4      		brne .+2
 2469 0a96 00C0      		rjmp .L96
 2470 0a98 8634      		cpi r24,lo8(70)
 2471 0a9a 01F0      		breq .+2
 2472 0a9c 00C0      		rjmp .L91
2185:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
 2474               	.LM316:
 2475 0a9e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 2476 0aa0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 2477 0aa2 62E0      		ldi r22,lo8(2)
 2478 0aa4 0E94 0000 		call PrintFromPROGMEMln
2186:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 2480               	.LM317:
 2481 0aa8 4091 0000 		lds r20,gFlashIndex
 2482 0aac 5091 0000 		lds r21,gFlashIndex+1
 2483 0ab0 6091 0000 		lds r22,gFlashIndex+2
 2484 0ab4 7091 0000 		lds r23,gFlashIndex+3
 2485 0ab8 80E0      		ldi r24,lo8(0)
 2486 0aba 0E94 0000 		call DumpHex.clone.0
2187:stk500boot.c  **** 				gFlashIndex	+=	256;
 2488               	.LM318:
 2489 0abe 8091 0000 		lds r24,gFlashIndex
 2490 0ac2 9091 0000 		lds r25,gFlashIndex+1
 2491 0ac6 A091 0000 		lds r26,gFlashIndex+2
 2492 0aca B091 0000 		lds r27,gFlashIndex+3
 2493 0ace 8050      		subi r24,lo8(-(256))
 2494 0ad0 9F4F      		sbci r25,hi8(-(256))
 2495 0ad2 AF4F      		sbci r26,hlo8(-(256))
 2496 0ad4 BF4F      		sbci r27,hhi8(-(256))
 2497 0ad6 8093 0000 		sts gFlashIndex,r24
 2498 0ada 9093 0000 		sts gFlashIndex+1,r25
 2499 0ade A093 0000 		sts gFlashIndex+2,r26
 2500 0ae2 B093 0000 		sts gFlashIndex+3,r27
 2501 0ae6 00C0      		rjmp .L298
 2502               	.L190:
 2503               	.LBE390:
 2504               	.LBE544:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 2506               	.LM319:
 2507 0ae8 EA31      		cpi r30,lo8(26)
 2508 0aea 01F4      		brne .+2
 2509 0aec 00C0      		rjmp .L185
 2510 0aee EA31      		cpi r30,lo8(26)
 2511 0af0 00F4      		brsh .L319
 2512               	.LBB545:
1046:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 2514               	.LM320:
 2515 0af2 7D81      		ldd r23,Y+5
 2516               	.LBB546:
1047:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 2518               	.LM321:
 2519 0af4 736C      		ori r23,lo8(-61)
 2520 0af6 B9E0      		ldi r27,lo8(9)
 2521               	/* #APP */
 2522               	 ;  1047 "stk500boot.c" 1
 2523 0af8 E1E0      		ldi r30, 1
 2524 0afa F0E0      		ldi r31, 0
 2525 0afc 072E      		mov r0, r23
 2526 0afe B093 5700 		sts 87, r27
 2527 0b02 E895      		spm
 2528               		
 2529               	 ;  0 "" 2
 2530               	/* #NOAPP */
 2531               	.L200:
 2532               	.LBE546:
1048:stk500boot.c  **** 						boot_spm_busy_wait();
 2534               	.LM322:
 2535 0b04 07B6      		in __tmp_reg__,87-32
 2536 0b06 00FC      		sbrc __tmp_reg__,0
 2537 0b08 00C0      		rjmp .L200
1051:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 2539               	.LM323:
 2540 0b0a 1A82      		std Y+2,__zero_reg__
1052:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 2542               	.LM324:
 2543 0b0c 1B82      		std Y+3,__zero_reg__
 2544               	.LBE545:
1050:stk500boot.c  **** 						msgLength		=	3;
 2546               	.LM325:
 2547 0b0e 83E0      		ldi r24,lo8(3)
 2548 0b10 90E0      		ldi r25,hi8(3)
1054:stk500boot.c  **** 					break;
 2550               	.LM326:
 2551 0b12 00C0      		rjmp .L194
 2552               	.L319:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 2554               	.LM327:
 2555 0b14 EB31      		cpi r30,lo8(27)
 2556 0b16 01F4      		brne .+2
 2557 0b18 00C0      		rjmp .L186
 2558 0b1a ED31      		cpi r30,lo8(29)
 2559 0b1c 01F0      		breq .+2
 2560 0b1e 00C0      		rjmp .L174
 2561               	.LBB547:
 884:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 2563               	.LM328:
 2564 0b20 8D81      		ldd r24,Y+5
 2565 0b22 8033      		cpi r24,lo8(48)
 2566 0b24 01F4      		brne .+2
 2567 0b26 00C0      		rjmp .L320
 901:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 2569               	.LM329:
 2570 0b28 E82F      		mov r30,r24
 2571 0b2a E075      		andi r30,lo8(80)
 2572 0b2c 01F0      		breq .L235
 908:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 2574               	.LM330:
 2575 0b2e 8035      		cpi r24,lo8(80)
 2576 0b30 01F4      		brne .+2
 2577 0b32 00C0      		rjmp .L321
 912:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 2579               	.LM331:
 2580 0b34 8835      		cpi r24,lo8(88)
 2581 0b36 01F4      		brne .+2
 2582 0b38 00C0      		rjmp .L322
 2583               	.L235:
 918:stk500boot.c  **** 								answerByte	=	0;
 2585               	.LM332:
 2586 0b3a 90E0      		ldi r25,lo8(0)
 2587               	.L192:
 928:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 2589               	.LM333:
 2590 0b3c 1A82      		std Y+2,__zero_reg__
 929:stk500boot.c  **** 							msgBuffer[2]	=	0;
 2592               	.LM334:
 2593 0b3e 1B82      		std Y+3,__zero_reg__
 930:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 2595               	.LM335:
 2596 0b40 8C83      		std Y+4,r24
 931:stk500boot.c  **** 							msgBuffer[4]	=	0;
 2598               	.LM336:
 2599 0b42 1D82      		std Y+5,__zero_reg__
 932:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 2601               	.LM337:
 2602 0b44 9E83      		std Y+6,r25
 933:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 2604               	.LM338:
 2605 0b46 1F82      		std Y+7,__zero_reg__
 927:stk500boot.c  **** 							msgLength		=	7;
 2607               	.LM339:
 2608 0b48 87E0      		ldi r24,lo8(7)
 2609 0b4a 90E0      		ldi r25,hi8(7)
 2610 0b4c 00C0      		rjmp .L194
 2611               	.L317:
 2612               	.LBE547:
 872:stk500boot.c  **** 			switch (msgBuffer[0])
 2614               	.LM340:
 2615 0b4e E031      		cpi r30,lo8(16)
 2616 0b50 01F0      		breq .+2
 2617 0b52 00C0      		rjmp .L174
 2618 0b54 00C0      		rjmp .L307
 2619               	.L177:
 2620               	.LBB553:
 956:stk500boot.c  **** 						switch(msgBuffer[1])
 2622               	.LM341:
 2623 0b56 EA81      		ldd r30,Y+2
 2624 0b58 E058      		subi r30,lo8(-(-128))
 2625 0b5a E331      		cpi r30,lo8(19)
 2626 0b5c 00F0      		brlo .+2
 2627 0b5e 00C0      		rjmp .L236
 2628 0b60 F0E0      		ldi r31,lo8(0)
 2629 0b62 E050      		subi r30,lo8(-(CSWTCH.29))
 2630 0b64 F040      		sbci r31,hi8(-(CSWTCH.29))
 2631 0b66 8081      		ld r24,Z
 2632               	.L195:
 978:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 2634               	.LM342:
 2635 0b68 1A82      		std Y+2,__zero_reg__
 979:stk500boot.c  **** 						msgBuffer[2]	=	value;
 2637               	.LM343:
 2638 0b6a 8B83      		std Y+3,r24
 2639               	.LBE553:
 977:stk500boot.c  **** 						msgLength		=	3;
 2641               	.LM344:
 2642 0b6c 83E0      		ldi r24,lo8(3)
 2643 0b6e 90E0      		ldi r25,hi8(3)
 981:stk500boot.c  **** 					break;
 2645               	.LM345:
 2646 0b70 00C0      		rjmp .L194
 2647               	.L101:
 2648               	.LBB554:
 2649               	.LBB519:
2210:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 2651               	.LM346:
 2652 0b72 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 2653 0b74 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 2654 0b76 62E0      		ldi r22,lo8(2)
 2655 0b78 0E94 0000 		call PrintFromPROGMEMln
2211:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 2657               	.LM347:
 2658 0b7c 4091 0000 		lds r20,gRamIndex
 2659 0b80 5091 0000 		lds r21,gRamIndex+1
 2660 0b84 6091 0000 		lds r22,gRamIndex+2
 2661 0b88 7091 0000 		lds r23,gRamIndex+3
 2662 0b8c 82E0      		ldi r24,lo8(2)
 2663 0b8e 0E94 0000 		call DumpHex.clone.0
2212:stk500boot.c  **** 				gRamIndex	+=	256;
 2665               	.LM348:
 2666 0b92 8091 0000 		lds r24,gRamIndex
 2667 0b96 9091 0000 		lds r25,gRamIndex+1
 2668 0b9a A091 0000 		lds r26,gRamIndex+2
 2669 0b9e B091 0000 		lds r27,gRamIndex+3
 2670 0ba2 8050      		subi r24,lo8(-(256))
 2671 0ba4 9F4F      		sbci r25,hi8(-(256))
 2672 0ba6 AF4F      		sbci r26,hlo8(-(256))
 2673 0ba8 BF4F      		sbci r27,hhi8(-(256))
 2674 0baa 8093 0000 		sts gRamIndex,r24
 2675 0bae 9093 0000 		sts gRamIndex+1,r25
 2676 0bb2 A093 0000 		sts gRamIndex+2,r26
 2677 0bb6 B093 0000 		sts gRamIndex+3,r27
 2678 0bba 00C0      		rjmp .L298
 2679               	.L99:
2198:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 2681               	.LM349:
 2682 0bbc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 2683 0bbe 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 2684 0bc0 62E0      		ldi r22,lo8(2)
 2685 0bc2 0E94 0000 		call PrintFromPROGMEMln
 2686               	.LBB450:
 2687               	.LBB451:
1849:stk500boot.c  **** 	PrintAvailablePort('A');
 2689               	.LM350:
 2690 0bc6 81E4      		ldi r24,lo8(65)
 2691 0bc8 0E94 0000 		call PrintAvailablePort
1853:stk500boot.c  **** 	PrintAvailablePort('B');
 2693               	.LM351:
 2694 0bcc 82E4      		ldi r24,lo8(66)
 2695 0bce 0E94 0000 		call PrintAvailablePort
1857:stk500boot.c  **** 	PrintAvailablePort('C');
 2697               	.LM352:
 2698 0bd2 83E4      		ldi r24,lo8(67)
 2699 0bd4 0E94 0000 		call PrintAvailablePort
1861:stk500boot.c  **** 	PrintAvailablePort('D');
 2701               	.LM353:
 2702 0bd8 84E4      		ldi r24,lo8(68)
 2703 0bda 0E94 0000 		call PrintAvailablePort
 2704 0bde 00C0      		rjmp .L298
 2705               	.L96:
 2706               	.LBE451:
 2707               	.LBE450:
2175:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 2709               	.LM354:
 2710 0be0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 2711 0be2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 2712 0be4 62E0      		ldi r22,lo8(2)
 2713 0be6 0E94 0000 		call PrintFromPROGMEMln
2176:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 2715               	.LM355:
 2716 0bea 4091 0000 		lds r20,gEepromIndex
 2717 0bee 5091 0000 		lds r21,gEepromIndex+1
 2718 0bf2 6091 0000 		lds r22,gEepromIndex+2
 2719 0bf6 7091 0000 		lds r23,gEepromIndex+3
 2720 0bfa 81E0      		ldi r24,lo8(1)
 2721 0bfc 0E94 0000 		call DumpHex.clone.0
2177:stk500boot.c  **** 				gEepromIndex	+=	256;
 2723               	.LM356:
 2724 0c00 8091 0000 		lds r24,gEepromIndex
 2725 0c04 9091 0000 		lds r25,gEepromIndex+1
 2726 0c08 A091 0000 		lds r26,gEepromIndex+2
 2727 0c0c B091 0000 		lds r27,gEepromIndex+3
 2728 0c10 8050      		subi r24,lo8(-(256))
 2729 0c12 9F4F      		sbci r25,hi8(-(256))
 2730 0c14 AF4F      		sbci r26,hlo8(-(256))
 2731 0c16 BF4F      		sbci r27,hhi8(-(256))
 2732 0c18 8093 0000 		sts gEepromIndex,r24
 2733 0c1c 9093 0000 		sts gEepromIndex+1,r25
 2734 0c20 A093 0000 		sts gEepromIndex+2,r26
 2735 0c24 B093 0000 		sts gEepromIndex+3,r27
2178:stk500boot.c  **** 				if (gEepromIndex > E2END)
 2737               	.LM357:
 2738 0c28 8030      		cpi r24,lo8(4096)
 2739 0c2a 30E1      		ldi r19,hi8(4096)
 2740 0c2c 9307      		cpc r25,r19
 2741 0c2e 30E0      		ldi r19,hlo8(4096)
 2742 0c30 A307      		cpc r26,r19
 2743 0c32 30E0      		ldi r19,hhi8(4096)
 2744 0c34 B307      		cpc r27,r19
 2745 0c36 00F4      		brsh .+2
 2746 0c38 00C0      		rjmp .L298
2179:stk500boot.c  **** 					gEepromIndex	=	0;
 2748               	.LM358:
 2749 0c3a 1092 0000 		sts gEepromIndex,__zero_reg__
 2750 0c3e 1092 0000 		sts gEepromIndex+1,__zero_reg__
 2751 0c42 1092 0000 		sts gEepromIndex+2,__zero_reg__
 2752 0c46 1092 0000 		sts gEepromIndex+3,__zero_reg__
 2753 0c4a 00C0      		rjmp .L298
 2754               	.L102:
2217:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 2756               	.LM359:
 2757 0c4c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 2758 0c4e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 2759 0c50 62E0      		ldi r22,lo8(2)
 2760 0c52 0E94 0000 		call PrintFromPROGMEMln
 2761               	.LBB452:
 2762               	.LBB453:
1735:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 2764               	.LM360:
 2765 0c56 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 2766 0c58 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 2767 0c5a 60E0      		ldi r22,lo8(0)
 2768 0c5c 0E94 0000 		call PrintFromPROGMEMln
1736:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 2770               	.LM361:
 2771 0c60 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 2772 0c62 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 2773 0c64 60E0      		ldi r22,lo8(0)
 2774 0c66 0E94 0000 		call PrintFromPROGMEMln
1734:stk500boot.c  **** 	vectorIndex		=	0;
 2776               	.LM362:
 2777 0c6a 2224      		clr r2
 2778 0c6c 3324      		clr r3
1733:stk500boot.c  **** 	myMemoryPtr		=	0;
 2780               	.LM363:
 2781 0c6e AA24      		clr r10
 2782 0c70 BB24      		clr r11
 2783 0c72 6501      		movw r12,r10
 2784               	.LBB480:
 2785               	.LBB481:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2787               	.LM364:
 2788 0c74 00E2      		ldi r16,lo8(32)
 2789 0c76 902E      		mov r9,r16
 2790               	.L142:
 2791               	.LBE481:
 2792               	.LBE480:
1741:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
 2794               	.LM365:
 2795 0c78 D601      		movw r26,r12
 2796 0c7a C501      		movw r24,r10
 2797 0c7c B695      		lsr r27
 2798 0c7e A795      		ror r26
 2799 0c80 9795      		ror r25
 2800 0c82 8795      		ror r24
 2801 0c84 C25E      		subi r28,lo8(-286)
 2802 0c86 DE4F      		sbci r29,hi8(-286)
 2803 0c88 8883      		st Y,r24
 2804 0c8a 9983      		std Y+1,r25
 2805 0c8c AA83      		std Y+2,r26
 2806 0c8e BB83      		std Y+3,r27
 2807 0c90 CE51      		subi r28,lo8(286)
 2808 0c92 D140      		sbci r29,hi8(286)
1743:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
 2810               	.LM366:
 2811 0c94 3101      		movw r6,r2
 2812 0c96 0894      		sec
 2813 0c98 611C      		adc r6,__zero_reg__
 2814 0c9a 711C      		adc r7,__zero_reg__
 2815 0c9c C301      		movw r24,r6
 2816 0c9e 62E0      		ldi r22,lo8(2)
 2817 0ca0 70E0      		ldi r23,hi8(2)
 2818 0ca2 0E94 0000 		call PrintDecInt
 2819               	.LBB479:
 2820               	.LBB482:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2822               	.LM367:
 2823 0ca6 9092 C600 		sts 198,r9
 2824               	.L124:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2826               	.LM368:
 2827 0caa 4090 C000 		lds r4,192
 2828 0cae 46FE      		sbrs r4,6
 2829 0cb0 00C0      		rjmp .L124
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2831               	.LM369:
 2832 0cb2 2091 C000 		lds r18,192
 2833 0cb6 2064      		ori r18,lo8(64)
 2834 0cb8 2093 C000 		sts 192,r18
 2835               	.LBE482:
 2836               	.LBE479:
 2837               	.LBB477:
 2838               	.LBB478:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2840               	.LM370:
 2841 0cbc 1DE2      		ldi r17,lo8(45)
 2842 0cbe 1093 C600 		sts 198,r17
 2843               	.L125:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2845               	.LM371:
 2846 0cc2 5090 C000 		lds r5,192
 2847 0cc6 56FE      		sbrs r5,6
 2848 0cc8 00C0      		rjmp .L125
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2850               	.LM372:
 2851 0cca 3091 C000 		lds r19,192
 2852 0cce 3064      		ori r19,lo8(64)
 2853 0cd0 3093 C000 		sts 192,r19
 2854               	.LBE478:
 2855               	.LBE477:
 2856               	.LBB475:
 2857               	.LBB476:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2859               	.LM373:
 2860 0cd4 9092 C600 		sts 198,r9
 2861               	.L126:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2863               	.LM374:
 2864 0cd8 8090 C000 		lds r8,192
 2865 0cdc 86FE      		sbrs r8,6
 2866 0cde 00C0      		rjmp .L126
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2868               	.LM375:
 2869 0ce0 4091 C000 		lds r20,192
 2870 0ce4 4064      		ori r20,lo8(64)
 2871 0ce6 4093 C000 		sts 192,r20
 2872               	.LBE476:
 2873               	.LBE475:
1747:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2875               	.LM376:
 2876 0cea C15E      		subi r28,lo8(-287)
 2877 0cec DE4F      		sbci r29,hi8(-287)
 2878 0cee 8881      		ld r24,Y
 2879 0cf0 CF51      		subi r28,lo8(287)
 2880 0cf2 D140      		sbci r29,hi8(287)
 2881 0cf4 0E94 0000 		call PrintHexByte
1748:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2883               	.LM377:
 2884 0cf8 C25E      		subi r28,lo8(-286)
 2885 0cfa DE4F      		sbci r29,hi8(-286)
 2886 0cfc 8881      		ld r24,Y
 2887 0cfe CE51      		subi r28,lo8(286)
 2888 0d00 D140      		sbci r29,hi8(286)
 2889 0d02 0E94 0000 		call PrintHexByte
 2890               	.LBB473:
 2891               	.LBB474:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2893               	.LM378:
 2894 0d06 9092 C600 		sts 198,r9
 2895               	.L127:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2897               	.LM379:
 2898 0d0a A091 C000 		lds r26,192
 2899 0d0e A6FF      		sbrs r26,6
 2900 0d10 00C0      		rjmp .L127
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2902               	.LM380:
 2903 0d12 6091 C000 		lds r22,192
 2904 0d16 6064      		ori r22,lo8(64)
 2905 0d18 6093 C000 		sts 192,r22
 2906               	.LBE474:
 2907               	.LBE473:
 2908               	.LBB471:
 2909               	.LBB472:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2911               	.LM381:
 2912 0d1c 5DE3      		ldi r21,lo8(61)
 2913 0d1e 5093 C600 		sts 198,r21
 2914               	.L128:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2916               	.LM382:
 2917 0d22 7091 C000 		lds r23,192
 2918 0d26 76FF      		sbrs r23,6
 2919 0d28 00C0      		rjmp .L128
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2921               	.LM383:
 2922 0d2a B091 C000 		lds r27,192
 2923 0d2e B064      		ori r27,lo8(64)
 2924 0d30 B093 C000 		sts 192,r27
 2925               	.LBE472:
 2926               	.LBE471:
 2927               	.LBB469:
 2928               	.LBB470:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 2930               	.LM384:
 2931 0d34 9092 C600 		sts 198,r9
 2932               	.L129:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 2934               	.LM385:
 2935 0d38 E090 C000 		lds r14,192
 2936 0d3c E6FE      		sbrs r14,6
 2937 0d3e 00C0      		rjmp .L129
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 2939               	.LM386:
 2940 0d40 8091 C000 		lds r24,192
 2941 0d44 8064      		ori r24,lo8(64)
 2942 0d46 8093 C000 		sts 192,r24
 2943               	.LBE470:
 2944               	.LBE469:
 2945               	.LBB468:
1756:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
 2947               	.LM387:
 2948               	/* #APP */
 2949               	 ;  1756 "stk500boot.c" 1
 2950 0d4a CBBE      		out 59, r12
 2951 0d4c F501      		movw r30, r10
 2952 0d4e 8790      		elpm r8, Z+
 2953               		
 2954               	 ;  0 "" 2
 2955               	/* #NOAPP */
 2956               	.LBE468:
 2957 0d50 282D      		mov r18,r8
 2958 0d52 30E0      		ldi r19,lo8(0)
 2959 0d54 40E0      		ldi r20,lo8(0)
 2960 0d56 50E0      		ldi r21,hi8(0)
 2961 0d58 CE5D      		subi r28,lo8(-290)
 2962 0d5a DE4F      		sbci r29,hi8(-290)
 2963 0d5c 2883      		st Y,r18
 2964 0d5e 3983      		std Y+1,r19
 2965 0d60 4A83      		std Y+2,r20
 2966 0d62 5B83      		std Y+3,r21
 2967 0d64 C252      		subi r28,lo8(290)
 2968 0d66 D140      		sbci r29,hi8(290)
 2969               	.LBB467:
1757:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2971               	.LM388:
 2972 0d68 D601      		movw r26,r12
 2973 0d6a C501      		movw r24,r10
 2974 0d6c 0196      		adiw r24,1
 2975 0d6e A11D      		adc r26,__zero_reg__
 2976 0d70 B11D      		adc r27,__zero_reg__
 2977               	/* #APP */
 2978               	 ;  1757 "stk500boot.c" 1
 2979 0d72 ABBF      		out 59, r26
 2980 0d74 FC01      		movw r30, r24
 2981 0d76 8791      		elpm r24, Z+
 2982               		
 2983               	 ;  0 "" 2
 2984               	/* #NOAPP */
 2985               	.LBE467:
 2986 0d78 282F      		mov r18,r24
 2987 0d7a 30E0      		ldi r19,lo8(0)
 2988 0d7c 40E0      		ldi r20,lo8(0)
 2989 0d7e 50E0      		ldi r21,hi8(0)
 2990 0d80 C65D      		subi r28,lo8(-298)
 2991 0d82 DE4F      		sbci r29,hi8(-298)
 2992 0d84 2883      		st Y,r18
 2993 0d86 3983      		std Y+1,r19
 2994 0d88 4A83      		std Y+2,r20
 2995 0d8a 5B83      		std Y+3,r21
 2996 0d8c CA52      		subi r28,lo8(298)
 2997 0d8e D140      		sbci r29,hi8(298)
 2998               	.LBB466:
1758:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 3000               	.LM389:
 3001 0d90 A601      		movw r20,r12
 3002 0d92 9501      		movw r18,r10
 3003 0d94 2E5F      		subi r18,lo8(-(2))
 3004 0d96 3F4F      		sbci r19,hi8(-(2))
 3005 0d98 4F4F      		sbci r20,hlo8(-(2))
 3006 0d9a 5F4F      		sbci r21,hhi8(-(2))
 3007               	/* #APP */
 3008               	 ;  1758 "stk500boot.c" 1
 3009 0d9c 4BBF      		out 59, r20
 3010 0d9e F901      		movw r30, r18
 3011 0da0 5790      		elpm r5, Z+
 3012               		
 3013               	 ;  0 "" 2
 3014               	/* #NOAPP */
 3015               	.LBE466:
 3016               	.LBB465:
1759:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 3018               	.LM390:
 3019 0da2 A601      		movw r20,r12
 3020 0da4 9501      		movw r18,r10
 3021 0da6 2D5F      		subi r18,lo8(-(3))
 3022 0da8 3F4F      		sbci r19,hi8(-(3))
 3023 0daa 4F4F      		sbci r20,hlo8(-(3))
 3024 0dac 5F4F      		sbci r21,hhi8(-(3))
 3025               	/* #APP */
 3026               	 ;  1759 "stk500boot.c" 1
 3027 0dae 4BBF      		out 59, r20
 3028 0db0 F901      		movw r30, r18
 3029 0db2 4790      		elpm r4, Z+
 3030               		
 3031               	 ;  0 "" 2
 3032               	/* #NOAPP */
 3033               	.LBE465:
1766:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
 3035               	.LM391:
 3036 0db4 C65D      		subi r28,lo8(-298)
 3037 0db6 DE4F      		sbci r29,hi8(-298)
 3038 0db8 2881      		ld r18,Y
 3039 0dba 3981      		ldd r19,Y+1
 3040 0dbc 4A81      		ldd r20,Y+2
 3041 0dbe 5B81      		ldd r21,Y+3
 3042 0dc0 CA52      		subi r28,lo8(298)
 3043 0dc2 D140      		sbci r29,hi8(298)
 3044 0dc4 EE24      		clr r14
 3045 0dc6 F22E      		mov r15,r18
 3046 0dc8 032F      		mov r16,r19
 3047 0dca 142F      		mov r17,r20
 3048 0dcc CE5D      		subi r28,lo8(-290)
 3049 0dce DE4F      		sbci r29,hi8(-290)
 3050 0dd0 2881      		ld r18,Y
 3051 0dd2 3981      		ldd r19,Y+1
 3052 0dd4 4A81      		ldd r20,Y+2
 3053 0dd6 5B81      		ldd r21,Y+3
 3054 0dd8 C252      		subi r28,lo8(290)
 3055 0dda D140      		sbci r29,hi8(290)
 3056 0ddc E20E      		add r14,r18
 3057 0dde F31E      		adc r15,r19
 3058 0de0 041F      		adc r16,r20
 3059 0de2 151F      		adc r17,r21
1770:stk500boot.c  **** 		PrintHexByte(byte2);
 3061               	.LM392:
 3062 0de4 0E94 0000 		call PrintHexByte
 3063               	.LBB463:
 3064               	.LBB464:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3066               	.LM393:
 3067 0de8 9092 C600 		sts 198,r9
 3068               	.L130:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3070               	.LM394:
 3071 0dec E091 C000 		lds r30,192
 3072 0df0 E6FF      		sbrs r30,6
 3073 0df2 00C0      		rjmp .L130
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3075               	.LM395:
 3076 0df4 F091 C000 		lds r31,192
 3077 0df8 F064      		ori r31,lo8(64)
 3078 0dfa F093 C000 		sts 192,r31
 3079               	.LBE464:
 3080               	.LBE463:
1772:stk500boot.c  **** 		PrintHexByte(byte1);
 3082               	.LM396:
 3083 0dfe 882D      		mov r24,r8
 3084 0e00 0E94 0000 		call PrintHexByte
 3085               	.LBB461:
 3086               	.LBB462:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3088               	.LM397:
 3089 0e04 9092 C600 		sts 198,r9
 3090               	.L131:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3092               	.LM398:
 3093 0e08 9091 C000 		lds r25,192
 3094 0e0c 96FF      		sbrs r25,6
 3095 0e0e 00C0      		rjmp .L131
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3097               	.LM399:
 3098 0e10 8091 C000 		lds r24,192
 3099 0e14 8064      		ori r24,lo8(64)
 3100 0e16 8093 C000 		sts 192,r24
 3101               	.LBE462:
 3102               	.LBE461:
1774:stk500boot.c  **** 		PrintHexByte(byte4);
 3104               	.LM400:
 3105 0e1a 842D      		mov r24,r4
 3106 0e1c 0E94 0000 		call PrintHexByte
 3107               	.LBB459:
 3108               	.LBB460:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3110               	.LM401:
 3111 0e20 9092 C600 		sts 198,r9
 3112               	.L132:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3114               	.LM402:
 3115 0e24 2091 C000 		lds r18,192
 3116 0e28 26FF      		sbrs r18,6
 3117 0e2a 00C0      		rjmp .L132
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3119               	.LM403:
 3120 0e2c 3091 C000 		lds r19,192
 3121 0e30 3064      		ori r19,lo8(64)
 3122 0e32 3093 C000 		sts 192,r19
 3123               	.LBE460:
 3124               	.LBE459:
1776:stk500boot.c  **** 		PrintHexByte(byte3);
 3126               	.LM404:
 3127 0e36 852D      		mov r24,r5
 3128 0e38 0E94 0000 		call PrintHexByte
 3129               	.LBB457:
 3130               	.LBB458:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3132               	.LM405:
 3133 0e3c 9092 C600 		sts 198,r9
 3134               	.L133:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3136               	.LM406:
 3137 0e40 4091 C000 		lds r20,192
 3138 0e44 46FF      		sbrs r20,6
 3139 0e46 00C0      		rjmp .L133
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3141               	.LM407:
 3142 0e48 A091 C000 		lds r26,192
 3143 0e4c A064      		ori r26,lo8(64)
 3144 0e4e A093 C000 		sts 192,r26
 3145               	.LBE458:
 3146               	.LBE457:
1779:stk500boot.c  **** 		if (word1 == 0xffff)
 3148               	.LM408:
 3149 0e52 3FEF      		ldi r19,lo8(65535)
 3150 0e54 E316      		cp r14,r19
 3151 0e56 3FEF      		ldi r19,hi8(65535)
 3152 0e58 F306      		cpc r15,r19
 3153 0e5a 30E0      		ldi r19,hlo8(65535)
 3154 0e5c 0307      		cpc r16,r19
 3155 0e5e 30E0      		ldi r19,hhi8(65535)
 3156 0e60 1307      		cpc r17,r19
 3157 0e62 01F4      		brne .+2
 3158 0e64 00C0      		rjmp .L323
1783:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
 3160               	.LM409:
 3161 0e66 D801      		movw r26,r16
 3162 0e68 C701      		movw r24,r14
 3163 0e6a 8070      		andi r24,lo8(49152)
 3164 0e6c 907C      		andi r25,hi8(49152)
 3165 0e6e A070      		andi r26,hlo8(49152)
 3166 0e70 B070      		andi r27,hhi8(49152)
 3167 0e72 8030      		cpi r24,lo8(49152)
 3168 0e74 40EC      		ldi r20,hi8(49152)
 3169 0e76 9407      		cpc r25,r20
 3170 0e78 40E0      		ldi r20,hlo8(49152)
 3171 0e7a A407      		cpc r26,r20
 3172 0e7c 40E0      		ldi r20,hhi8(49152)
 3173 0e7e B407      		cpc r27,r20
 3174 0e80 01F4      		brne .+2
 3175 0e82 00C0      		rjmp .L324
1800:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
 3177               	.LM410:
 3178 0e84 D801      		movw r26,r16
 3179 0e86 C701      		movw r24,r14
 3180 0e88 8E70      		andi r24,lo8(65038)
 3181 0e8a 9E7F      		andi r25,hi8(65038)
 3182 0e8c A070      		andi r26,hlo8(65038)
 3183 0e8e B070      		andi r27,hhi8(65038)
 3184 0e90 8C30      		cpi r24,lo8(37900)
 3185 0e92 44E9      		ldi r20,hi8(37900)
 3186 0e94 9407      		cpc r25,r20
 3187 0e96 40E0      		ldi r20,hlo8(37900)
 3188 0e98 A407      		cpc r26,r20
 3189 0e9a 40E0      		ldi r20,hhi8(37900)
 3190 0e9c B407      		cpc r27,r20
 3191 0e9e 01F4      		brne .+2
 3192 0ea0 00C0      		rjmp .L325
 3193               	.L135:
 3194               	.LBB455:
 3195               	.LBB456:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3197               	.LM411:
 3198 0ea2 9092 C600 		sts 198,r9
 3199               	.L141:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3201               	.LM412:
 3202 0ea6 E090 C000 		lds r14,192
 3203 0eaa E6FE      		sbrs r14,6
 3204 0eac 00C0      		rjmp .L141
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3206               	.LM413:
 3207 0eae 8091 C000 		lds r24,192
 3208 0eb2 8064      		ori r24,lo8(64)
 3209 0eb4 8093 C000 		sts 192,r24
 3210               	.LBE456:
 3211               	.LBE455:
 3212               	.LBB454:
1824:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
 3214               	.LM414:
 3215 0eb8 C101      		movw r24,r2
 3216 0eba 880F      		lsl r24
 3217 0ebc 991F      		rol r25
 3218 0ebe 8050      		subi r24,lo8(-(gInterruptNameTable))
 3219 0ec0 9040      		sbci r25,hi8(-(gInterruptNameTable))
 3220 0ec2 AA27      		clr r26
 3221 0ec4 97FD      		sbrc r25,7
 3222 0ec6 A095      		com r26
 3223 0ec8 BA2F      		mov r27,r26
 3224               	/* #APP */
 3225               	 ;  1824 "stk500boot.c" 1
 3226 0eca ABBF      		out 59, r26
 3227 0ecc FC01      		movw r30, r24
 3228 0ece 2791      		elpm r18, Z+
 3229 0ed0 3691      		elpm r19, Z
 3230               		
 3231               	 ;  0 "" 2
 3232               	/* #NOAPP */
 3233               	.LBE454:
1828:stk500boot.c  **** 		PrintFromPROGMEM((void *)stringPointer, 0);
 3235               	.LM415:
 3236 0ed2 C901      		movw r24,r18
 3237 0ed4 60E0      		ldi r22,lo8(0)
 3238 0ed6 0E94 0000 		call PrintFromPROGMEM
1830:stk500boot.c  **** 		PrintNewLine();
 3240               	.LM416:
 3241 0eda 0E94 0000 		call PrintNewLine
1739:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
 3243               	.LM417:
 3244 0ede A3E2      		ldi r26,lo8(35)
 3245 0ee0 6A16      		cp r6,r26
 3246 0ee2 7104      		cpc r7,__zero_reg__
 3247 0ee4 01F4      		brne .+2
 3248 0ee6 00C0      		rjmp .L298
 3249 0ee8 24E0      		ldi r18,lo8(4)
 3250 0eea 30E0      		ldi r19,hi8(4)
 3251 0eec 40E0      		ldi r20,hlo8(4)
 3252 0eee 50E0      		ldi r21,hhi8(4)
 3253 0ef0 A20E      		add r10,r18
 3254 0ef2 B31E      		adc r11,r19
 3255 0ef4 C41E      		adc r12,r20
 3256 0ef6 D51E      		adc r13,r21
 3257               	.LBE453:
 3258               	.LBE452:
 3259               	.LBB492:
 3260               	.LBB448:
1832:stk500boot.c  **** 		vectorIndex++;
 3262               	.LM418:
 3263 0ef8 1301      		movw r2,r6
 3264 0efa 00C0      		rjmp .L142
 3265               	.L323:
 3266               	.LBE448:
 3267               	.LBE492:
 3268               	.LBB493:
 3269               	.LBB491:
1781:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
 3271               	.LM419:
 3272 0efc 80E0      		ldi r24,lo8(gTextMsg_noVector)
 3273 0efe 90E0      		ldi r25,hi8(gTextMsg_noVector)
 3274 0f00 60E0      		ldi r22,lo8(0)
 3275 0f02 0E94 0000 		call PrintFromPROGMEM
 3276 0f06 00C0      		rjmp .L135
 3277               	.L324:
1786:stk500boot.c  **** 			relativeAddr	=	word1 & 0x3FFF;
 3279               	.LM420:
 3280 0f08 D801      		movw r26,r16
 3281 0f0a C701      		movw r24,r14
 3282 0f0c 9F73      		andi r25,hi8(16383)
 3283 0f0e A070      		andi r26,hlo8(16383)
 3284 0f10 B070      		andi r27,hhi8(16383)
 3285 0f12 CE5D      		subi r28,lo8(-290)
 3286 0f14 DE4F      		sbci r29,hi8(-290)
 3287 0f16 8883      		st Y,r24
 3288 0f18 9983      		std Y+1,r25
 3289 0f1a AA83      		std Y+2,r26
 3290 0f1c BB83      		std Y+3,r27
 3291 0f1e C252      		subi r28,lo8(290)
 3292 0f20 D140      		sbci r29,hi8(290)
1787:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + relativeAddr;	//*	add the offset to the current address
 3294               	.LM421:
 3295 0f22 7C01      		movw r14,r24
 3296 0f24 8D01      		movw r16,r26
 3297 0f26 C25E      		subi r28,lo8(-286)
 3298 0f28 DE4F      		sbci r29,hi8(-286)
 3299 0f2a 2881      		ld r18,Y
 3300 0f2c 3981      		ldd r19,Y+1
 3301 0f2e 4A81      		ldd r20,Y+2
 3302 0f30 5B81      		ldd r21,Y+3
 3303 0f32 CE51      		subi r28,lo8(286)
 3304 0f34 D140      		sbci r29,hi8(286)
 3305 0f36 E20E      		add r14,r18
 3306 0f38 F31E      		adc r15,r19
 3307 0f3a 041F      		adc r16,r20
 3308 0f3c 151F      		adc r17,r21
1788:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 3310               	.LM422:
 3311 0f3e EE0C      		lsl r14
 3312 0f40 FF1C      		rol r15
 3313 0f42 001F      		rol r16
 3314 0f44 111F      		rol r17
1790:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
 3316               	.LM423:
 3317 0f46 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 3318 0f48 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 3319 0f4a 60E0      		ldi r22,lo8(0)
 3320 0f4c 0E94 0000 		call PrintFromPROGMEM
1791:stk500boot.c  **** 			PrintHexByte((relativeAddr >> 8) & 0x00ff);
 3322               	.LM424:
 3323 0f50 CD5D      		subi r28,lo8(-291)
 3324 0f52 DE4F      		sbci r29,hi8(-291)
 3325 0f54 8881      		ld r24,Y
 3326 0f56 C352      		subi r28,lo8(291)
 3327 0f58 D140      		sbci r29,hi8(291)
 3328 0f5a 0E94 0000 		call PrintHexByte
1792:stk500boot.c  **** 			PrintHexByte((relativeAddr) & 0x00ff);
 3330               	.LM425:
 3331 0f5e CE5D      		subi r28,lo8(-290)
 3332 0f60 DE4F      		sbci r29,hi8(-290)
 3333 0f62 8881      		ld r24,Y
 3334 0f64 C252      		subi r28,lo8(290)
 3335 0f66 D140      		sbci r29,hi8(290)
 3336 0f68 0E94 0000 		call PrintHexByte
 3337               	.LBB483:
 3338               	.LBB484:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3340               	.LM426:
 3341 0f6c 9092 C600 		sts 198,r9
 3342               	.L137:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3344               	.LM427:
 3345 0f70 1091 C000 		lds r17,192
 3346 0f74 16FF      		sbrs r17,6
 3347 0f76 00C0      		rjmp .L137
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3349               	.LM428:
 3350 0f78 6091 C000 		lds r22,192
 3351 0f7c 6064      		ori r22,lo8(64)
 3352 0f7e 6093 C000 		sts 192,r22
 3353               	.LBE484:
 3354               	.LBE483:
 3355               	.LBB485:
 3356               	.LBB486:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3358               	.LM429:
 3359 0f82 5EE3      		ldi r21,lo8(62)
 3360 0f84 5093 C600 		sts 198,r21
 3361               	.L138:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3363               	.LM430:
 3364 0f88 7091 C000 		lds r23,192
 3365 0f8c 76FF      		sbrs r23,6
 3366 0f8e 00C0      		rjmp .L138
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3368               	.LM431:
 3369 0f90 B091 C000 		lds r27,192
 3370 0f94 B064      		ori r27,lo8(64)
 3371 0f96 B093 C000 		sts 192,r27
 3372               	.LBE486:
 3373               	.LBE485:
1795:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 3375               	.LM432:
 3376 0f9a 802F      		mov r24,r16
 3377 0f9c 0E94 0000 		call PrintHexByte
1796:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 3379               	.LM433:
 3380 0fa0 8F2D      		mov r24,r15
 3381 0fa2 0E94 0000 		call PrintHexByte
1797:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 3383               	.LM434:
 3384 0fa6 8E2D      		mov r24,r14
 3385 0fa8 0E94 0000 		call PrintHexByte
 3386 0fac 00C0      		rjmp .L135
 3387               	.L325:
1759:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 3389               	.LM435:
 3390 0fae 842D      		mov r24,r4
 3391 0fb0 90E0      		ldi r25,lo8(0)
 3392 0fb2 A0E0      		ldi r26,lo8(0)
 3393 0fb4 B0E0      		ldi r27,hi8(0)
1767:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 3395               	.LM436:
 3396 0fb6 EE24      		clr r14
 3397 0fb8 F82E      		mov r15,r24
 3398 0fba 092F      		mov r16,r25
 3399 0fbc 1A2F      		mov r17,r26
 3400 0fbe E50C      		add r14,r5
 3401 0fc0 F11C      		adc r15,__zero_reg__
 3402 0fc2 011D      		adc r16,__zero_reg__
 3403 0fc4 111D      		adc r17,__zero_reg__
1803:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 3405               	.LM437:
 3406 0fc6 CE5D      		subi r28,lo8(-290)
 3407 0fc8 DE4F      		sbci r29,hi8(-290)
 3408 0fca 8881      		ld r24,Y
 3409 0fcc 9981      		ldd r25,Y+1
 3410 0fce AA81      		ldd r26,Y+2
 3411 0fd0 BB81      		ldd r27,Y+3
 3412 0fd2 C252      		subi r28,lo8(290)
 3413 0fd4 D140      		sbci r29,hi8(290)
 3414 0fd6 8170      		andi r24,lo8(1)
 3415 0fd8 9070      		andi r25,hi8(1)
 3416 0fda A070      		andi r26,hlo8(1)
 3417 0fdc B070      		andi r27,hhi8(1)
 3418 0fde DC01      		movw r26,r24
 3419 0fe0 9927      		clr r25
 3420 0fe2 8827      		clr r24
1804:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 3422               	.LM438:
 3423 0fe4 E80E      		add r14,r24
 3424 0fe6 F91E      		adc r15,r25
 3425 0fe8 0A1F      		adc r16,r26
 3426 0fea 1B1F      		adc r17,r27
 3427 0fec CE5D      		subi r28,lo8(-290)
 3428 0fee DE4F      		sbci r29,hi8(-290)
 3429 0ff0 8881      		ld r24,Y
 3430 0ff2 9981      		ldd r25,Y+1
 3431 0ff4 AA81      		ldd r26,Y+2
 3432 0ff6 BB81      		ldd r27,Y+3
 3433 0ff8 C252      		subi r28,lo8(290)
 3434 0ffa D140      		sbci r29,hi8(290)
 3435 0ffc 807F      		andi r24,lo8(240)
 3436 0ffe 9070      		andi r25,hi8(240)
 3437 1000 A070      		andi r26,hlo8(240)
 3438 1002 B070      		andi r27,hhi8(240)
 3439 1004 51E1      		ldi r21,17
 3440 1006 880F      	1:	lsl r24
 3441 1008 991F      		rol r25
 3442 100a AA1F      		rol r26
 3443 100c BB1F      		rol r27
 3444 100e 5A95      		dec r21
 3445 1010 01F4      		brne 1b
1803:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 3447               	.LM439:
 3448 1012 E80E      		add r14,r24
 3449 1014 F91E      		adc r15,r25
 3450 1016 0A1F      		adc r16,r26
 3451 1018 1B1F      		adc r17,r27
1805:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 3453               	.LM440:
 3454 101a C65D      		subi r28,lo8(-298)
 3455 101c DE4F      		sbci r29,hi8(-298)
 3456 101e 8881      		ld r24,Y
 3457 1020 9981      		ldd r25,Y+1
 3458 1022 AA81      		ldd r26,Y+2
 3459 1024 BB81      		ldd r27,Y+3
 3460 1026 CA52      		subi r28,lo8(298)
 3461 1028 D140      		sbci r29,hi8(298)
 3462 102a 8170      		andi r24,lo8(1)
 3463 102c 9070      		andi r25,hi8(1)
 3464 102e A070      		andi r26,hlo8(1)
 3465 1030 B070      		andi r27,hhi8(1)
 3466 1032 45E1      		ldi r20,21
 3467 1034 880F      	1:	lsl r24
 3468 1036 991F      		rol r25
 3469 1038 AA1F      		rol r26
 3470 103a BB1F      		rol r27
 3471 103c 4A95      		dec r20
 3472 103e 01F4      		brne 1b
1803:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 3474               	.LM441:
 3475 1040 E80E      		add r14,r24
 3476 1042 F91E      		adc r15,r25
 3477 1044 0A1F      		adc r16,r26
 3478 1046 1B1F      		adc r17,r27
1808:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
 3480               	.LM442:
 3481 1048 D801      		movw r26,r16
 3482 104a C701      		movw r24,r14
 3483 104c 880F      		lsl r24
 3484 104e 991F      		rol r25
 3485 1050 AA1F      		rol r26
 3486 1052 BB1F      		rol r27
 3487 1054 C25E      		subi r28,lo8(-286)
 3488 1056 DE4F      		sbci r29,hi8(-286)
 3489 1058 8883      		st Y,r24
 3490 105a 9983      		std Y+1,r25
 3491 105c AA83      		std Y+2,r26
 3492 105e BB83      		std Y+3,r27
 3493 1060 CE51      		subi r28,lo8(286)
 3494 1062 D140      		sbci r29,hi8(286)
1810:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
 3496               	.LM443:
 3497 1064 80E0      		ldi r24,lo8(gTextMsg_jmp)
 3498 1066 90E0      		ldi r25,hi8(gTextMsg_jmp)
 3499 1068 60E0      		ldi r22,lo8(0)
 3500 106a 0E94 0000 		call PrintFromPROGMEM
1811:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 3502               	.LM444:
 3503 106e 802F      		mov r24,r16
 3504 1070 0E94 0000 		call PrintHexByte
1812:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 3506               	.LM445:
 3507 1074 8F2D      		mov r24,r15
 3508 1076 0E94 0000 		call PrintHexByte
1813:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 3510               	.LM446:
 3511 107a 8E2D      		mov r24,r14
 3512 107c 0E94 0000 		call PrintHexByte
 3513               	.LBB487:
 3514               	.LBB488:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3516               	.LM447:
 3517 1080 9092 C600 		sts 198,r9
 3518               	.L139:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3520               	.LM448:
 3521 1084 0091 C000 		lds r16,192
 3522 1088 06FF      		sbrs r16,6
 3523 108a 00C0      		rjmp .L139
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3525               	.LM449:
 3526 108c F091 C000 		lds r31,192
 3527 1090 F064      		ori r31,lo8(64)
 3528 1092 F093 C000 		sts 192,r31
 3529               	.LBE488:
 3530               	.LBE487:
 3531               	.LBB489:
 3532               	.LBB490:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3534               	.LM450:
 3535 1096 EEE3      		ldi r30,lo8(62)
 3536 1098 E093 C600 		sts 198,r30
 3537               	.L140:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3539               	.LM451:
 3540 109c F090 C000 		lds r15,192
 3541 10a0 F6FE      		sbrs r15,6
 3542 10a2 00C0      		rjmp .L140
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3544               	.LM452:
 3545 10a4 9091 C000 		lds r25,192
 3546 10a8 9064      		ori r25,lo8(64)
 3547 10aa 9093 C000 		sts 192,r25
 3548               	.LBE490:
 3549               	.LBE489:
1816:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 3551               	.LM453:
 3552 10ae C05E      		subi r28,lo8(-288)
 3553 10b0 DE4F      		sbci r29,hi8(-288)
 3554 10b2 8881      		ld r24,Y
 3555 10b4 C052      		subi r28,lo8(288)
 3556 10b6 D140      		sbci r29,hi8(288)
 3557 10b8 0E94 0000 		call PrintHexByte
1817:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 3559               	.LM454:
 3560 10bc C15E      		subi r28,lo8(-287)
 3561 10be DE4F      		sbci r29,hi8(-287)
 3562 10c0 8881      		ld r24,Y
 3563 10c2 CF51      		subi r28,lo8(287)
 3564 10c4 D140      		sbci r29,hi8(287)
 3565 10c6 0E94 0000 		call PrintHexByte
1818:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 3567               	.LM455:
 3568 10ca C25E      		subi r28,lo8(-286)
 3569 10cc DE4F      		sbci r29,hi8(-286)
 3570 10ce 8881      		ld r24,Y
 3571 10d0 CE51      		subi r28,lo8(286)
 3572 10d2 D140      		sbci r29,hi8(286)
 3573 10d4 0E94 0000 		call PrintHexByte
 3574 10d8 00C0      		rjmp .L135
 3575               	.L315:
 3576               	.LBE491:
 3577               	.LBE493:
2163:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
 3579               	.LM456:
 3580 10da 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 3581 10dc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 3582 10de 62E0      		ldi r22,lo8(2)
 3583 10e0 0E94 0000 		call PrintFromPROGMEMln
 3584               	.LBB494:
 3585               	.LBB436:
1642:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
 3587               	.LM457:
 3588 10e4 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 3589 10e6 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 3590 10e8 60E0      		ldi r22,lo8(0)
 3591 10ea 0E94 0000 		call PrintFromPROGMEMln
1643:stk500boot.c  **** 	PrintNewLine();
 3593               	.LM458:
 3594 10ee 0E94 0000 		call PrintNewLine
 3595               	.LBB445:
1646:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 3597               	.LM459:
 3598 10f2 CB5C      		subi r28,lo8(-309)
 3599 10f4 DE4F      		sbci r29,hi8(-309)
 3600 10f6 E880      		ld r14,Y
 3601 10f8 C553      		subi r28,lo8(309)
 3602 10fa D140      		sbci r29,hi8(309)
 3603               	.LBE445:
 3604 10fc EE2D      		mov r30,r14
 3605 10fe EA32      		cpi r30,lo8(42)
 3606 1100 01F0      		breq .L108
 3607 1102 00E0      		ldi r16,lo8(0)
 3608 1104 10E0      		ldi r17,hi8(0)
 3609               	.L297:
1651:stk500boot.c  **** 		eeprom_busy_wait();
 3611               	.LM460:
 3612 1106 F999      		sbic 63-32,1
 3613 1108 00C0      		rjmp .L297
1652:stk500boot.c  **** 		eeprom_update_byte((uint8_t *)ii, theChar);
 3615               	.LM461:
 3616 110a C801      		movw r24,r16
 3617 110c 6E2D      		mov r22,r14
 3618 110e 0E94 0000 		call __eeupd_byte_m1284p
1653:stk500boot.c  **** 		if (theChar == 0)
 3620               	.LM462:
 3621 1112 EE20      		tst r14
 3622 1114 01F4      		brne .+2
 3623 1116 00C0      		rjmp .L326
 3624               	.LBB443:
 3625               	.LBB444:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3627               	.LM463:
 3628 1118 E092 C600 		sts 198,r14
 3629               	.L112:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3631               	.LM464:
 3632 111c A090 C000 		lds r10,192
 3633 1120 A6FE      		sbrs r10,6
 3634 1122 00C0      		rjmp .L112
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3636               	.LM465:
 3637 1124 F091 C000 		lds r31,192
 3638 1128 F064      		ori r31,lo8(64)
 3639 112a F093 C000 		sts 192,r31
 3640               	.L111:
 3641               	.LBE444:
 3642               	.LBE443:
1661:stk500boot.c  **** 		ii++;
 3644               	.LM466:
 3645 112e 0F5F      		subi r16,lo8(-(1))
 3646 1130 1F4F      		sbci r17,hi8(-(1))
 3647               	.LBB442:
1646:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 3649               	.LM467:
 3650 1132 C801      		movw r24,r16
 3651 1134 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 3652 1136 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 3653 1138 AA27      		clr r26
 3654 113a 97FD      		sbrc r25,7
 3655 113c A095      		com r26
 3656 113e BA2F      		mov r27,r26
 3657               	/* #APP */
 3658               	 ;  1646 "stk500boot.c" 1
 3659 1140 ABBF      		out 59, r26
 3660 1142 FC01      		movw r30, r24
 3661 1144 E790      		elpm r14, Z+
 3662               		
 3663               	 ;  0 "" 2
 3664               	/* #NOAPP */
 3665               	.LBE442:
 3666 1146 EE2D      		mov r30,r14
 3667 1148 EA32      		cpi r30,lo8(42)
 3668 114a 01F0      		breq .L108
 3669 114c F2E0      		ldi r31,hi8(512)
 3670 114e 0030      		cpi r16,lo8(512)
 3671 1150 1F07      		cpc r17,r31
 3672 1152 01F4      		brne .L297
 3673               	.L108:
1665:stk500boot.c  **** 	PrintNewLine();
 3675               	.LM468:
 3676 1154 0E94 0000 		call PrintNewLine
1666:stk500boot.c  **** 	PrintNewLine();
 3678               	.LM469:
 3679 1158 0E94 0000 		call PrintNewLine
1667:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 3681               	.LM470:
 3682 115c 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 3683 115e 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 3684 1160 60E0      		ldi r22,lo8(0)
 3685 1162 0E94 0000 		call PrintFromPROGMEMln
1668:stk500boot.c  **** 	PrintNewLine();
 3687               	.LM471:
 3688 1166 0E94 0000 		call PrintNewLine
 3689               	.LBB441:
1672:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 3691               	.LM472:
 3692 116a C45C      		subi r28,lo8(-316)
 3693 116c DE4F      		sbci r29,hi8(-316)
 3694 116e A880      		ld r10,Y
 3695 1170 CC53      		subi r28,lo8(316)
 3696 1172 D140      		sbci r29,hi8(316)
 3697               	.LBE441:
 3698 1174 0A2D      		mov r16,r10
 3699 1176 0A32      		cpi r16,lo8(42)
 3700 1178 01F4      		brne .+2
 3701 117a 00C0      		rjmp .L226
 3702 117c EE24      		clr r14
 3703 117e FF24      		clr r15
 3704 1180 00E0      		ldi r16,lo8(0)
 3705 1182 10E0      		ldi r17,hi8(0)
 3706               	.L119:
1677:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((const uint8_t *)ii);
 3708               	.LM473:
 3709 1184 C801      		movw r24,r16
 3710 1186 0E94 0000 		call __eerd_byte_m1284p
 3711 118a C82E      		mov r12,r24
1678:stk500boot.c  **** 		if (theEEPROMchar == 0)
 3713               	.LM474:
 3714 118c 8823      		tst r24
 3715 118e 01F4      		brne .+2
 3716 1190 00C0      		rjmp .L327
 3717               	.LBB439:
 3718               	.LBB440:
 492:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
 3720               	.LM475:
 3721 1192 8093 C600 		sts 198,r24
 3722               	.L117:
 493:stk500boot.c  **** 	while ( !(UART_STATUS_REG & _BV(UART_TRANSMIT_COMPLETE) ));	// wait until byte sent
 3724               	.LM476:
 3725 1196 9091 C000 		lds r25,192
 3726 119a 96FF      		sbrs r25,6
 3727 119c 00C0      		rjmp .L117
 494:stk500boot.c  **** 	UART_STATUS_REG |= _BV(UART_TRANSMIT_COMPLETE);				// delete TXCflag
 3729               	.LM477:
 3730 119e 8091 C000 		lds r24,192
 3731 11a2 8064      		ori r24,lo8(64)
 3732 11a4 8093 C000 		sts 192,r24
 3733               	.L116:
 3734               	.LBE440:
 3735               	.LBE439:
1686:stk500boot.c  **** 		if (theEEPROMchar != theChar)
 3737               	.LM478:
 3738 11a8 CA14      		cp r12,r10
 3739 11aa 01F0      		breq .L118
1688:stk500boot.c  **** 			errorCount++;
 3741               	.LM479:
 3742 11ac 0894      		sec
 3743 11ae E11C      		adc r14,__zero_reg__
 3744 11b0 F11C      		adc r15,__zero_reg__
 3745               	.L118:
1690:stk500boot.c  **** 		ii++;
 3747               	.LM480:
 3748 11b2 0F5F      		subi r16,lo8(-(1))
 3749 11b4 1F4F      		sbci r17,hi8(-(1))
 3750               	.LBB438:
1672:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint32_t)(gTextMsg_Explorer + ii))) != '*') && (ii < 512))
 3752               	.LM481:
 3753 11b6 C801      		movw r24,r16
 3754 11b8 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 3755 11ba 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 3756 11bc AA27      		clr r26
 3757 11be 97FD      		sbrc r25,7
 3758 11c0 A095      		com r26
 3759 11c2 BA2F      		mov r27,r26
 3760               	/* #APP */
 3761               	 ;  1672 "stk500boot.c" 1
 3762 11c4 ABBF      		out 59, r26
 3763 11c6 FC01      		movw r30, r24
 3764 11c8 A790      		elpm r10, Z+
 3765               		
 3766               	 ;  0 "" 2
 3767               	/* #NOAPP */
 3768               	.LBE438:
 3769 11ca 3A2D      		mov r19,r10
 3770 11cc 3A32      		cpi r19,lo8(42)
 3771 11ce 01F0      		breq .L114
 3772 11d0 42E0      		ldi r20,hi8(512)
 3773 11d2 0030      		cpi r16,lo8(512)
 3774 11d4 1407      		cpc r17,r20
 3775 11d6 01F4      		brne .L119
 3776               	.L114:
1692:stk500boot.c  **** 	PrintNewLine();
 3778               	.LM482:
 3779 11d8 0E94 0000 		call PrintNewLine
1693:stk500boot.c  **** 	PrintNewLine();
 3781               	.LM483:
 3782 11dc 0E94 0000 		call PrintNewLine
1694:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 3784               	.LM484:
 3785 11e0 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 3786 11e2 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 3787 11e4 60E0      		ldi r22,lo8(0)
 3788 11e6 0E94 0000 		call PrintFromPROGMEM
1695:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 3790               	.LM485:
 3791 11ea C701      		movw r24,r14
 3792 11ec 61E0      		ldi r22,lo8(1)
 3793 11ee 70E0      		ldi r23,hi8(1)
 3794 11f0 0E94 0000 		call PrintDecInt
1696:stk500boot.c  **** 	PrintNewLine();
 3796               	.LM486:
 3797 11f4 0E94 0000 		call PrintNewLine
1697:stk500boot.c  **** 	PrintNewLine();
 3799               	.LM487:
 3800 11f8 0E94 0000 		call PrintNewLine
1699:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
 3802               	.LM488:
 3803 11fc 1092 0000 		sts gEepromIndex,__zero_reg__
 3804 1200 1092 0000 		sts gEepromIndex+1,__zero_reg__
 3805 1204 1092 0000 		sts gEepromIndex+2,__zero_reg__
 3806 1208 1092 0000 		sts gEepromIndex+3,__zero_reg__
 3807 120c 00C0      		rjmp .L298
 3808               	.L327:
1680:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 3810               	.LM489:
 3811 120e 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 3812 1210 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 3813 1212 60E0      		ldi r22,lo8(0)
 3814 1214 0E94 0000 		call PrintFromPROGMEM
 3815 1218 00C0      		rjmp .L116
 3816               	.L326:
1655:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 3818               	.LM490:
 3819 121a 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 3820 121c 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 3821 121e 60E0      		ldi r22,lo8(0)
 3822 1220 0E94 0000 		call PrintFromPROGMEM
 3823 1224 00C0      		rjmp .L111
 3824               	.L93:
 3825               	.LBE436:
 3826               	.LBE494:
2158:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 3828               	.LM491:
 3829 1226 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 3830 1228 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 3831 122a 62E0      		ldi r22,lo8(2)
 3832 122c 0E94 0000 		call PrintFromPROGMEMln
 3833               	.LBB495:
 3834               	.LBB496:
1486:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 3836               	.LM492:
 3837 1230 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 3838 1232 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 3839 1234 60E0      		ldi r22,lo8(0)
 3840 1236 0E94 0000 		call PrintFromPROGMEMln
1488:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
 3842               	.LM493:
 3843 123a 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 3844 123c 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 3845 123e 60E0      		ldi r22,lo8(0)
 3846 1240 0E94 0000 		call PrintFromPROGMEM
1489:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 3848               	.LM494:
 3849 1244 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 3850 1246 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 3851 1248 60E0      		ldi r22,lo8(0)
 3852 124a 0E94 0000 		call PrintFromPROGMEMln
1491:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
 3854               	.LM495:
 3855 124e 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 3856 1250 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 3857 1252 60E0      		ldi r22,lo8(0)
 3858 1254 0E94 0000 		call PrintFromPROGMEM
1492:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 3860               	.LM496:
 3861 1258 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 3862 125a 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 3863 125c 60E0      		ldi r22,lo8(0)
 3864 125e 0E94 0000 		call PrintFromPROGMEMln
1494:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
 3866               	.LM497:
 3867 1262 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 3868 1264 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 3869 1266 60E0      		ldi r22,lo8(0)
 3870 1268 0E94 0000 		call PrintFromPROGMEM
1495:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 3872               	.LM498:
 3873 126c 83E3      		ldi r24,lo8(51)
 3874 126e 90E0      		ldi r25,hi8(51)
 3875 1270 61E0      		ldi r22,lo8(1)
 3876 1272 70E0      		ldi r23,hi8(1)
 3877 1274 0E94 0000 		call PrintDecInt
1496:stk500boot.c  **** 	PrintNewLine();
 3879               	.LM499:
 3880 1278 0E94 0000 		call PrintNewLine
1498:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
 3882               	.LM500:
 3883 127c 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 3884 127e 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 3885 1280 60E0      		ldi r22,lo8(0)
 3886 1282 0E94 0000 		call PrintFromPROGMEM
1499:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 3888               	.LM501:
 3889 1286 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 3890 1288 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 3891 128a 60E0      		ldi r22,lo8(0)
 3892 128c 0E94 0000 		call PrintFromPROGMEMln
1502:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
 3894               	.LM502:
 3895 1290 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 3896 1292 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 3897 1294 60E0      		ldi r22,lo8(0)
 3898 1296 0E94 0000 		call PrintFromPROGMEM
1503:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 3900               	.LM503:
 3901 129a 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 3902 129c 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 3903 129e 60E0      		ldi r22,lo8(0)
 3904 12a0 0E94 0000 		call PrintFromPROGMEMln
1506:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
 3906               	.LM504:
 3907 12a4 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 3908 12a6 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 3909 12a8 60E0      		ldi r22,lo8(0)
 3910 12aa 0E94 0000 		call PrintFromPROGMEM
1508:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
 3912               	.LM505:
 3913 12ae 8EE1      		ldi r24,lo8(30)
 3914 12b0 0E94 0000 		call PrintHexByte
1509:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 3916               	.LM506:
 3917 12b4 87E9      		ldi r24,lo8(-105)
 3918 12b6 0E94 0000 		call PrintHexByte
1510:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 3920               	.LM507:
 3921 12ba 85E0      		ldi r24,lo8(5)
 3922 12bc 0E94 0000 		call PrintHexByte
1511:stk500boot.c  **** 	PrintNewLine();
 3924               	.LM508:
 3925 12c0 0E94 0000 		call PrintNewLine
1517:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
 3927               	.LM509:
 3928 12c4 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 3929 12c6 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 3930 12c8 60E0      		ldi r22,lo8(0)
 3931 12ca 0E94 0000 		call PrintFromPROGMEM
 3932               	.LBB497:
1518:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 3934               	.LM510:
 3935 12ce 09E0      		ldi r16,lo8(9)
 3936 12d0 E0E0      		ldi r30,lo8(0)
 3937 12d2 F0E0      		ldi r31,hi8(0)
 3938               	/* #APP */
 3939               	 ;  1518 "stk500boot.c" 1
 3940 12d4 0093 5700 		sts 87, r16
 3941 12d8 8491      		lpm r24, Z
 3942               		
 3943               	 ;  0 "" 2
 3944               	/* #NOAPP */
 3945               	.LBE497:
1519:stk500boot.c  **** 	PrintHexByte(fuseByte);
 3947               	.LM511:
 3948 12da 0E94 0000 		call PrintHexByte
1520:stk500boot.c  **** 	PrintNewLine();
 3950               	.LM512:
 3951 12de 0E94 0000 		call PrintNewLine
1522:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
 3953               	.LM513:
 3954 12e2 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 3955 12e4 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 3956 12e6 60E0      		ldi r22,lo8(0)
 3957 12e8 0E94 0000 		call PrintFromPROGMEM
 3958               	.LBB498:
1523:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 3960               	.LM514:
 3961 12ec E3E0      		ldi r30,lo8(3)
 3962 12ee F0E0      		ldi r31,hi8(3)
 3963               	/* #APP */
 3964               	 ;  1523 "stk500boot.c" 1
 3965 12f0 0093 5700 		sts 87, r16
 3966 12f4 8491      		lpm r24, Z
 3967               		
 3968               	 ;  0 "" 2
 3969               	/* #NOAPP */
 3970               	.LBE498:
1524:stk500boot.c  **** 	PrintHexByte(fuseByte);
 3972               	.LM515:
 3973 12f6 0E94 0000 		call PrintHexByte
1525:stk500boot.c  **** 	PrintNewLine();
 3975               	.LM516:
 3976 12fa 0E94 0000 		call PrintNewLine
1527:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
 3978               	.LM517:
 3979 12fe 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 3980 1300 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 3981 1302 60E0      		ldi r22,lo8(0)
 3982 1304 0E94 0000 		call PrintFromPROGMEM
 3983               	.LBB499:
1528:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 3985               	.LM518:
 3986 1308 E2E0      		ldi r30,lo8(2)
 3987 130a F0E0      		ldi r31,hi8(2)
 3988               	/* #APP */
 3989               	 ;  1528 "stk500boot.c" 1
 3990 130c 0093 5700 		sts 87, r16
 3991 1310 8491      		lpm r24, Z
 3992               		
 3993               	 ;  0 "" 2
 3994               	/* #NOAPP */
 3995               	.LBE499:
1529:stk500boot.c  **** 	PrintHexByte(fuseByte);
 3997               	.LM519:
 3998 1312 0E94 0000 		call PrintHexByte
1530:stk500boot.c  **** 	PrintNewLine();
 4000               	.LM520:
 4001 1316 0E94 0000 		call PrintNewLine
1532:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
 4003               	.LM521:
 4004 131a 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 4005 131c 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 4006 131e 60E0      		ldi r22,lo8(0)
 4007 1320 0E94 0000 		call PrintFromPROGMEM
 4008               	.LBB500:
1533:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 4010               	.LM522:
 4011 1324 E1E0      		ldi r30,lo8(1)
 4012 1326 F0E0      		ldi r31,hi8(1)
 4013               	/* #APP */
 4014               	 ;  1533 "stk500boot.c" 1
 4015 1328 0093 5700 		sts 87, r16
 4016 132c 8491      		lpm r24, Z
 4017               		
 4018               	 ;  0 "" 2
 4019               	/* #NOAPP */
 4020               	.LBE500:
1534:stk500boot.c  **** 	PrintHexByte(fuseByte);
 4022               	.LM523:
 4023 132e 0E94 0000 		call PrintHexByte
1535:stk500boot.c  **** 	PrintNewLine();
 4025               	.LM524:
 4026 1332 0E94 0000 		call PrintNewLine
 4027 1336 00C0      		rjmp .L298
 4028               	.L92:
 4029               	.LBE496:
 4030               	.LBE495:
2151:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
 4032               	.LM525:
 4033 1338 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 4034 133a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 4035 133c 62E0      		ldi r22,lo8(2)
 4036 133e 0E94 0000 		call PrintFromPROGMEMln
2152:stk500boot.c  **** 				gFlashIndex		=	0;
 4038               	.LM526:
 4039 1342 1092 0000 		sts gFlashIndex,__zero_reg__
 4040 1346 1092 0000 		sts gFlashIndex+1,__zero_reg__
 4041 134a 1092 0000 		sts gFlashIndex+2,__zero_reg__
 4042 134e 1092 0000 		sts gFlashIndex+3,__zero_reg__
2153:stk500boot.c  **** 				gRamIndex		=	0;
 4044               	.LM527:
 4045 1352 1092 0000 		sts gRamIndex,__zero_reg__
 4046 1356 1092 0000 		sts gRamIndex+1,__zero_reg__
 4047 135a 1092 0000 		sts gRamIndex+2,__zero_reg__
 4048 135e 1092 0000 		sts gRamIndex+3,__zero_reg__
2154:stk500boot.c  **** 				gEepromIndex	=	0;
 4050               	.LM528:
 4051 1362 1092 0000 		sts gEepromIndex,__zero_reg__
 4052 1366 1092 0000 		sts gEepromIndex+1,__zero_reg__
 4053 136a 1092 0000 		sts gEepromIndex+2,__zero_reg__
 4054 136e 1092 0000 		sts gEepromIndex+3,__zero_reg__
 4055 1372 00C0      		rjmp .L298
 4056               	.L95:
2169:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
 4058               	.LM529:
 4059 1374 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 4060 1376 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 4061 1378 62E0      		ldi r22,lo8(2)
 4062 137a 0E94 0000 		call PrintFromPROGMEMln
 4063               	.LBB501:
 4064               	.LBB502:
1545:stk500boot.c  **** 	PROGLED_DDR		|=	_BV(PROGLED_PIN);
 4066               	.LM530:
 4067 137e 279A      		sbi 36-32,7
1546:stk500boot.c  **** 	PROGLED_PORT	|=	_BV(PROGLED_PIN);	// active high LED ON
 4069               	.LM531:
 4070 1380 2F9A      		sbi 37-32,7
 4071               	.LBB503:
 4072               	.LBB504:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 4074               	.LM532:
 4075 1382 8091 C000 		lds r24,192
 4076               	.LBE504:
 4077               	.LBE503:
1548:stk500boot.c  **** 	while (!Serial_Available())
 4079               	.LM533:
 4080 1386 87FD      		sbrc r24,7
 4081 1388 00C0      		rjmp .L244
 4082               	.L245:
1550:stk500boot.c  **** 		PROGLED_PORT	&=	~_BV(PROGLED_PIN);	// turn LED off
 4084               	.LM534:
 4085 138a 2F98      		cbi 37-32,7
 4086               	.LBB506:
 4087               	.LBB507:
 4089               	.Ltext5:
 4091               	.LM535:
 4092 138c 8FEF      		 ldi r24,lo8(319999)
 4093 138e 91EE      	    ldi r25,hi8(319999)
 4094 1390 A4E0      	    ldi r26,hlo8(319999)
 4095 1392 8150      	    1:subi r24,1
 4096 1394 9040      	    sbci r25,0
 4097 1396 A040      	    sbci r26,0
 4098 1398 01F4      	    brne 1b
 4099 139a 00C0      		rjmp .
 4100 139c 0000      		nop
 4101               	.LBE507:
 4102               	.LBE506:
 4104               	.Ltext6:
1552:stk500boot.c  **** 		PROGLED_PORT	|=	_BV(PROGLED_PIN);	// turn LED on
 4106               	.LM536:
 4107 139e 2F9A      		sbi 37-32,7
 4108               	.LBB508:
 4109               	.LBB509:
 4111               	.Ltext7:
 4113               	.LM537:
 4114 13a0 2FEF      		 ldi r18,lo8(319999)
 4115 13a2 31EE      	    ldi r19,hi8(319999)
 4116 13a4 44E0      	    ldi r20,hlo8(319999)
 4117 13a6 2150      	    1:subi r18,1
 4118 13a8 3040      	    sbci r19,0
 4119 13aa 4040      	    sbci r20,0
 4120 13ac 01F4      	    brne 1b
 4121 13ae 00C0      		rjmp .
 4122 13b0 0000      		nop
 4123               	.LBE509:
 4124               	.LBE508:
 4125               	.LBB510:
 4126               	.LBB505:
 4128               	.Ltext8:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 4130               	.LM538:
 4131 13b2 8091 C000 		lds r24,192
 4132               	.LBE505:
 4133               	.LBE510:
1548:stk500boot.c  **** 	while (!Serial_Available())
 4135               	.LM539:
 4136 13b6 87FF      		sbrs r24,7
 4137 13b8 00C0      		rjmp .L245
 4138               	.L244:
 4139               	.LBB511:
 4140               	.LBB512:
 524:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 4142               	.LM540:
 4143 13ba F090 C000 		lds r15,192
 4144 13be F7FE      		sbrs r15,7
 4145 13c0 00C0      		rjmp .L244
 4146               	.L305:
 4147               	.LBE512:
 4148               	.LBE511:
 4149               	.LBE502:
 4150               	.LBE501:
 4151               	.LBB513:
 4152               	.LBB397:
 4153               	.LBB403:
 4154               	.LBB404:
 528:stk500boot.c  **** 	return UART_DATA_REG;
 4156               	.LM541:
 4157 13c2 8091 C600 		lds r24,198
 4158 13c6 00C0      		rjmp .L298
 4159               	.L98:
 4160               	.LBE404:
 4161               	.LBE403:
 4162               	.LBE397:
 4163               	.LBE513:
2192:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
 4165               	.LM542:
 4166 13c8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 4167 13ca 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 4168 13cc 62E0      		ldi r22,lo8(2)
 4169 13ce 0E94 0000 		call PrintFromPROGMEMln
 4170               	.LBB514:
 4171               	.LBB515:
2080:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
 4173               	.LM543:
 4174 13d2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 4175 13d4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 4176 13d6 60E0      		ldi r22,lo8(0)
 4177 13d8 0E94 0000 		call PrintFromPROGMEMln
2081:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 4179               	.LM544:
 4180 13dc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 4181 13de 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 4182 13e0 60E0      		ldi r22,lo8(0)
 4183 13e2 0E94 0000 		call PrintFromPROGMEMln
2082:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 4185               	.LM545:
 4186 13e6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 4187 13e8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 4188 13ea 60E0      		ldi r22,lo8(0)
 4189 13ec 0E94 0000 		call PrintFromPROGMEMln
2083:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 4191               	.LM546:
 4192 13f0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 4193 13f2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 4194 13f4 60E0      		ldi r22,lo8(0)
 4195 13f6 0E94 0000 		call PrintFromPROGMEMln
2084:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 4197               	.LM547:
 4198 13fa 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 4199 13fc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 4200 13fe 60E0      		ldi r22,lo8(0)
 4201 1400 0E94 0000 		call PrintFromPROGMEMln
2085:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 4203               	.LM548:
 4204 1404 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 4205 1406 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 4206 1408 60E0      		ldi r22,lo8(0)
 4207 140a 0E94 0000 		call PrintFromPROGMEMln
2086:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 4209               	.LM549:
 4210 140e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 4211 1410 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 4212 1412 60E0      		ldi r22,lo8(0)
 4213 1414 0E94 0000 		call PrintFromPROGMEMln
2088:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
 4215               	.LM550:
 4216 1418 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 4217 141a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 4218 141c 60E0      		ldi r22,lo8(0)
 4219 141e 0E94 0000 		call PrintFromPROGMEMln
2089:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 4221               	.LM551:
 4222 1422 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 4223 1424 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 4224 1426 60E0      		ldi r22,lo8(0)
 4225 1428 0E94 0000 		call PrintFromPROGMEMln
2090:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 4227               	.LM552:
 4228 142c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 4229 142e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 4230 1430 60E0      		ldi r22,lo8(0)
 4231 1432 0E94 0000 		call PrintFromPROGMEMln
2091:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 4233               	.LM553:
 4234 1436 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 4235 1438 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 4236 143a 60E0      		ldi r22,lo8(0)
 4237 143c 0E94 0000 		call PrintFromPROGMEMln
2092:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 4239               	.LM554:
 4240 1440 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 4241 1442 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 4242 1444 60E0      		ldi r22,lo8(0)
 4243 1446 0E94 0000 		call PrintFromPROGMEMln
 4244 144a 00C0      		rjmp .L298
 4245               	.L185:
 4246               	.LBE515:
 4247               	.LBE514:
 4248               	.LBE519:
 4249               	.LBE554:
1014:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 4251               	.LM555:
 4252 144c 1A82      		std Y+2,__zero_reg__
 4253               	.LBB555:
1015:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 4255               	.LM556:
 4256 144e E1E0      		ldi r30,lo8(1)
 4257 1450 F0E0      		ldi r31,hi8(1)
 4258 1452 29E0      		ldi r18,lo8(9)
 4259               	/* #APP */
 4260               	 ;  1015 "stk500boot.c" 1
 4261 1454 2093 5700 		sts 87, r18
 4262 1458 B490      		lpm r11, Z
 4263               		
 4264               	 ;  0 "" 2
 4265               	/* #NOAPP */
 4266               	.LBE555:
 4267 145a BB82      		std Y+3,r11
1016:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 4269               	.LM557:
 4270 145c 1C82      		std Y+4,__zero_reg__
1013:stk500boot.c  **** 					msgLength		=	4;
 4272               	.LM558:
 4273 145e 84E0      		ldi r24,lo8(4)
 4274 1460 90E0      		ldi r25,hi8(4)
1017:stk500boot.c  **** 					break;
 4276               	.LM559:
 4277 1462 00C0      		rjmp .L194
 4278               	.L181:
 4279               	.LBB556:
1076:stk500boot.c  **** 						uint16_t	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 4281               	.LM560:
 4282 1464 6A80      		ldd r6,Y+2
 4283 1466 C95C      		subi r28,lo8(-311)
 4284 1468 DE4F      		sbci r29,hi8(-311)
 4285 146a 6882      		st Y,r6
 4286 146c C753      		subi r28,lo8(311)
 4287 146e D140      		sbci r29,hi8(311)
 4288 1470 CA5C      		subi r28,lo8(-310)
 4289 1472 DE4F      		sbci r29,hi8(-310)
 4290 1474 1882      		st Y,__zero_reg__
 4291 1476 C653      		subi r28,lo8(310)
 4292 1478 D140      		sbci r29,hi8(310)
 4293 147a 2B81      		ldd r18,Y+3
 4294 147c 30E0      		ldi r19,lo8(0)
 4295 147e CA5C      		subi r28,lo8(-310)
 4296 1480 DE4F      		sbci r29,hi8(-310)
 4297 1482 6880      		ld r6,Y
 4298 1484 7980      		ldd r7,Y+1
 4299 1486 C653      		subi r28,lo8(310)
 4300 1488 D140      		sbci r29,hi8(310)
 4301 148a 2629      		or r18,r6
 4302 148c 3729      		or r19,r7
1083:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 4304               	.LM561:
 4305 148e E331      		cpi r30,lo8(19)
 4306 1490 01F4      		brne .+2
 4307 1492 00C0      		rjmp .L328
 571:stk500boot.c  **** int main(void)
 4309               	.LM562:
 4310 1494 5901      		movw r10,r18
 4311 1496 0894      		sec
 4312 1498 A108      		sbc r10,__zero_reg__
 4313 149a B108      		sbc r11,__zero_reg__
 4314 149c CC24      		clr r12
 4315 149e DD24      		clr r13
 4316 14a0 0894      		sec
 4317 14a2 A11C      		adc r10,__zero_reg__
 4318 14a4 B11C      		adc r11,__zero_reg__
 4319 14a6 C11C      		adc r12,__zero_reg__
 4320 14a8 D11C      		adc r13,__zero_reg__
 4321 14aa CA5D      		subi r28,lo8(-294)
 4322 14ac DE4F      		sbci r29,hi8(-294)
 4323 14ae 8881      		ld r24,Y
 4324 14b0 9981      		ldd r25,Y+1
 4325 14b2 AA81      		ldd r26,Y+2
 4326 14b4 BB81      		ldd r27,Y+3
 4327 14b6 C652      		subi r28,lo8(294)
 4328 14b8 D140      		sbci r29,hi8(294)
 4329 14ba A80E      		add r10,r24
 4330 14bc B91E      		adc r11,r25
 4331 14be CA1E      		adc r12,r26
 4332 14c0 DB1E      		adc r13,r27
 4333               	.LBE556:
 4334               	.LBB557:
 4335               	.LBB560:
1077:stk500boot.c  **** 						uint8_t	*p	=	msgBuffer+10;
 4337               	.LM563:
 4338 14c2 FE01      		movw r30,r28
 4339 14c4 3B96      		adiw r30,11
 4340 14c6 2C01      		movw r4,r24
 4341 14c8 3D01      		movw r6,r26
 4342               	.L208:
 4343               	.LBE560:
 4344               	.LBE557:
 4345               	.LBB563:
1116:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
 4347               	.LM564:
 4348 14ca 41BC      		out 65-32,r4
1117:stk500boot.c  **** 								EEARH	=	(address >> 8);
 4350               	.LM565:
 4351 14cc BB27      		clr r27
 4352 14ce A72D      		mov r26,r7
 4353 14d0 962D      		mov r25,r6
 4354 14d2 852D      		mov r24,r5
 4355 14d4 82BD      		out 66-32,r24
1118:stk500boot.c  **** 								address++;						// Select next EEPROM byte
 4357               	.LM566:
 4358 14d6 0894      		sec
 4359 14d8 411C      		adc r4,__zero_reg__
 4360 14da 511C      		adc r5,__zero_reg__
 4361 14dc 611C      		adc r6,__zero_reg__
 4362 14de 711C      		adc r7,__zero_reg__
1120:stk500boot.c  **** 								EEDR	=	*p++;				// get byte from buffer
 4364               	.LM567:
 4365 14e0 8191      		ld r24,Z+
 4366 14e2 80BD      		out 64-32,r24
1121:stk500boot.c  **** 								EECR	|=	_BV(EEMWE);			// Write data into EEPROM
 4368               	.LM568:
 4369 14e4 FA9A      		sbi 63-32,2
1122:stk500boot.c  **** 								EECR	|=	_BV(EEWE);
 4371               	.LM569:
 4372 14e6 F99A      		sbi 63-32,1
 4373               	.L207:
1124:stk500boot.c  **** 								while (EECR & _BV(EEWE));	// Wait for write operation to finish
 4375               	.LM570:
 4376 14e8 F999      		sbic 63-32,1
 4377 14ea 00C0      		rjmp .L207
1126:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 4379               	.LM571:
 4380 14ec 4A14      		cp r4,r10
 4381 14ee 5B04      		cpc r5,r11
 4382 14f0 6C04      		cpc r6,r12
 4383 14f2 7D04      		cpc r7,r13
 4384 14f4 01F4      		brne .L208
 4385 14f6 00C0      		rjmp .L308
 4386               	.L314:
 4387               	.LBE563:
 940:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 4389               	.LM572:
 4390 14f8 1A82      		std Y+2,__zero_reg__
 941:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 4392               	.LM573:
 4393 14fa 98E0      		ldi r25,lo8(8)
 4394 14fc 9B83      		std Y+3,r25
 942:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 4396               	.LM574:
 4397 14fe E1E4      		ldi r30,lo8(65)
 4398 1500 EC83      		std Y+4,r30
 943:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 4400               	.LM575:
 4401 1502 B6E5      		ldi r27,lo8(86)
 4402 1504 BD83      		std Y+5,r27
 944:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 4404               	.LM576:
 4405 1506 72E5      		ldi r23,lo8(82)
 4406 1508 7E83      		std Y+6,r23
 945:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 4408               	.LM577:
 4409 150a 69E4      		ldi r22,lo8(73)
 4410 150c 6F83      		std Y+7,r22
 946:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 4412               	.LM578:
 4413 150e A3E5      		ldi r26,lo8(83)
 4414 1510 A887      		std Y+8,r26
 947:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 4416               	.LM579:
 4417 1512 30E5      		ldi r19,lo8(80)
 4418 1514 3987      		std Y+9,r19
 948:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 4420               	.LM580:
 4421 1516 8FE5      		ldi r24,lo8(95)
 4422 1518 8A87      		std Y+10,r24
 949:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 4424               	.LM581:
 4425 151a F2E3      		ldi r31,lo8(50)
 4426 151c FB87      		std Y+11,r31
 939:stk500boot.c  **** 					msgLength		=	11;
 4428               	.LM582:
 4429 151e 8BE0      		ldi r24,lo8(11)
 4430 1520 90E0      		ldi r25,hi8(11)
 950:stk500boot.c  **** 					break;
 4432               	.LM583:
 4433 1522 00C0      		rjmp .L194
 4434               	.L231:
 984:stk500boot.c  **** 					isLeave	=	1;
 4436               	.LM584:
 4437 1524 9924      		clr r9
 4438 1526 9394      		inc r9
 4439 1528 00C0      		rjmp .L307
 4440               	.L183:
 4441               	.LBB564:
1023:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 4443               	.LM585:
 4444 152a FB81      		ldd r31,Y+3
 4445 152c F035      		cpi r31,lo8(80)
 4446 152e 01F4      		brne .+2
 4447 1530 00C0      		rjmp .L329
 4448               	.LBB559:
1032:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 4450               	.LM586:
 4451 1532 E3E0      		ldi r30,lo8(3)
 4452 1534 F0E0      		ldi r31,hi8(3)
 4453 1536 69E0      		ldi r22,lo8(9)
 4454               	/* #APP */
 4455               	 ;  1032 "stk500boot.c" 1
 4456 1538 6093 5700 		sts 87, r22
 4457 153c 8491      		lpm r24, Z
 4458               		
 4459               	 ;  0 "" 2
 4460               	/* #NOAPP */
 4461               	.L199:
 4462               	.LBE559:
1035:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 4464               	.LM587:
 4465 153e 1A82      		std Y+2,__zero_reg__
1036:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 4467               	.LM588:
 4468 1540 8B83      		std Y+3,r24
1037:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 4470               	.LM589:
 4471 1542 1C82      		std Y+4,__zero_reg__
 4472               	.LBE564:
1034:stk500boot.c  **** 						msgLength		=	4;
 4474               	.LM590:
 4475 1544 84E0      		ldi r24,lo8(4)
 4476 1546 90E0      		ldi r25,hi8(4)
1039:stk500boot.c  **** 					break;
 4478               	.LM591:
 4479 1548 00C0      		rjmp .L194
 4480               	.L186:
 4481               	.LBB565:
 995:stk500boot.c  **** 						uint8_t signatureIndex	=	msgBuffer[4];
 4483               	.LM592:
 4484 154a 8D81      		ldd r24,Y+5
 998:stk500boot.c  **** 						if ( signatureIndex == 0 )
 4486               	.LM593:
 4487 154c 8823      		tst r24
 4488 154e 01F4      		brne .+2
 4489 1550 00C0      		rjmp .L237
1000:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 4491               	.LM594:
 4492 1552 8130      		cpi r24,lo8(1)
 4493 1554 01F4      		brne .+2
 4494 1556 00C0      		rjmp .L330
1003:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 4496               	.LM595:
 4497 1558 85E0      		ldi r24,lo8(5)
 4498 155a 00C0      		rjmp .L199
 4499               	.L320:
 4500               	.LBE565:
 4501               	.LBB566:
 4502               	.LBB549:
 886:stk500boot.c  **** 							uint8_t signatureIndex	=	msgBuffer[6];
 4504               	.LM596:
 4505 155c 9F81      		ldd r25,Y+7
 888:stk500boot.c  **** 							if ( signatureIndex == 0 )
 4507               	.LM597:
 4508 155e 9923      		tst r25
 4509 1560 01F4      		brne .+2
 4510 1562 00C0      		rjmp .L232
 892:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 4512               	.LM598:
 4513 1564 9130      		cpi r25,lo8(1)
 4514 1566 01F4      		brne .+2
 4515 1568 00C0      		rjmp .L331
 898:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 4517               	.LM599:
 4518 156a 95E0      		ldi r25,lo8(5)
 4519 156c 00C0      		rjmp .L192
 4520               	.L328:
 4521               	.LBE549:
 4522               	.LBE566:
 4523               	.LBB567:
1086:stk500boot.c  **** 							if (eraseAddress < APP_END )
 4525               	.LM600:
 4526 156e CF5C      		subi r28,lo8(-305)
 4527 1570 DE4F      		sbci r29,hi8(-305)
 4528 1572 8881      		ld r24,Y
 4529 1574 9981      		ldd r25,Y+1
 4530 1576 AA81      		ldd r26,Y+2
 4531 1578 BB81      		ldd r27,Y+3
 4532 157a C153      		subi r28,lo8(305)
 4533 157c D140      		sbci r29,hi8(305)
 4534 157e 8030      		cpi r24,lo8(114688)
 4535 1580 E0EC      		ldi r30,hi8(114688)
 4536 1582 9E07      		cpc r25,r30
 4537 1584 E1E0      		ldi r30,hlo8(114688)
 4538 1586 AE07      		cpc r26,r30
 4539 1588 E0E0      		ldi r30,hhi8(114688)
 4540 158a BE07      		cpc r27,r30
 4541 158c 00F4      		brsh .L202
1088:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
 4543               	.LM601:
 4544 158e 93E0      		ldi r25,lo8(3)
 4545 1590 CF5C      		subi r28,lo8(-305)
 4546 1592 DE4F      		sbci r29,hi8(-305)
 4547 1594 4880      		ld r4,Y
 4548 1596 5980      		ldd r5,Y+1
 4549 1598 6A80      		ldd r6,Y+2
 4550 159a 7B80      		ldd r7,Y+3
 4551 159c C153      		subi r28,lo8(305)
 4552 159e D140      		sbci r29,hi8(305)
 4553               	/* #APP */
 4554               	 ;  1088 "stk500boot.c" 1
 4555 15a0 F201      		movw r30, r4
 4556 15a2 6092 5B00 		sts  91, r6
 4557 15a6 9093 5700 		sts 87, r25
 4558 15aa E895      		spm
 4559               		
 4560               	 ;  0 "" 2
 4561               	/* #NOAPP */
 4562               	.L203:
1089:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 4564               	.LM602:
 4565 15ac 07B6      		in __tmp_reg__,87-32
 4566 15ae 00FC      		sbrc __tmp_reg__,0
 4567 15b0 00C0      		rjmp .L203
1090:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 4569               	.LM603:
 4570 15b2 CF5C      		subi r28,lo8(-305)
 4571 15b4 DE4F      		sbci r29,hi8(-305)
 4572 15b6 8881      		ld r24,Y
 4573 15b8 9981      		ldd r25,Y+1
 4574 15ba AA81      		ldd r26,Y+2
 4575 15bc BB81      		ldd r27,Y+3
 4576 15be C153      		subi r28,lo8(305)
 4577 15c0 D140      		sbci r29,hi8(305)
 4578 15c2 8050      		subi r24,lo8(-(256))
 4579 15c4 9F4F      		sbci r25,hi8(-(256))
 4580 15c6 AF4F      		sbci r26,hlo8(-(256))
 4581 15c8 BF4F      		sbci r27,hhi8(-(256))
 4582 15ca CF5C      		subi r28,lo8(-305)
 4583 15cc DE4F      		sbci r29,hi8(-305)
 4584 15ce 8883      		st Y,r24
 4585 15d0 9983      		std Y+1,r25
 4586 15d2 AA83      		std Y+2,r26
 4587 15d4 BB83      		std Y+3,r27
 4588 15d6 C153      		subi r28,lo8(305)
 4589 15d8 D140      		sbci r29,hi8(305)
 4590               	.L202:
 4591               	.LBE567:
 4592               	.LBB568:
 4593               	.LBB561:
1026:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 4595               	.LM604:
 4596 15da CA5D      		subi r28,lo8(-294)
 4597 15dc DE4F      		sbci r29,hi8(-294)
 4598 15de A880      		ld r10,Y
 4599 15e0 B980      		ldd r11,Y+1
 4600 15e2 CA80      		ldd r12,Y+2
 4601 15e4 DB80      		ldd r13,Y+3
 4602 15e6 C652      		subi r28,lo8(294)
 4603 15e8 D140      		sbci r29,hi8(294)
1077:stk500boot.c  **** 						uint8_t	*p	=	msgBuffer+10;
 4605               	.LM605:
 4606 15ea DE01      		movw r26,r28
 4607 15ec 1B96      		adiw r26,11
 4608               	.LBE561:
 4609               	.LBE568:
 4610               	.LBB569:
1099:stk500boot.c  **** 								boot_page_fill(address,data);
 4612               	.LM606:
 4613 15ee 61E0      		ldi r22,lo8(1)
 4614 15f0 FD01      		movw r30,r26
 4615 15f2 D601      		movw r26,r12
 4616 15f4 C501      		movw r24,r10
 4617 15f6 5A01      		movw r10,r20
 4618 15f8 6701      		movw r12,r14
 4619 15fa 7801      		movw r14,r16
 4620 15fc AF01      		movw r20,r30
 4621               	.L204:
1095:stk500boot.c  **** 								lowByte		=	*p++;
 4623               	.LM607:
 4624 15fe FA01      		movw r30,r20
 4625 1600 0081      		ld r16,Z
1096:stk500boot.c  **** 								highByte 	=	*p++;
 4627               	.LM608:
 4628 1602 7181      		ldd r23,Z+1
 571:stk500boot.c  **** int main(void)
 4630               	.LM609:
 4631 1604 4E5F      		subi r20,lo8(-(2))
 4632 1606 5F4F      		sbci r21,hi8(-(2))
1098:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
 4634               	.LM610:
 4635 1608 C75C      		subi r28,lo8(-313)
 4636 160a DE4F      		sbci r29,hi8(-313)
 4637 160c 7883      		st Y,r23
 4638 160e C953      		subi r28,lo8(313)
 4639 1610 D140      		sbci r29,hi8(313)
 4640 1612 C85C      		subi r28,lo8(-312)
 4641 1614 DE4F      		sbci r29,hi8(-312)
 4642 1616 1882      		st Y,__zero_reg__
 4643 1618 C853      		subi r28,lo8(312)
 4644 161a D140      		sbci r29,hi8(312)
 4645 161c 10E0      		ldi r17,lo8(0)
 4646 161e C85C      		subi r28,lo8(-312)
 4647 1620 DE4F      		sbci r29,hi8(-312)
 4648 1622 4880      		ld r4,Y
 4649 1624 5980      		ldd r5,Y+1
 4650 1626 C853      		subi r28,lo8(312)
 4651 1628 D140      		sbci r29,hi8(312)
 4652 162a 0429      		or r16,r4
 4653 162c 1529      		or r17,r5
1099:stk500boot.c  **** 								boot_page_fill(address,data);
 4655               	.LM611:
 4656               	/* #APP */
 4657               	 ;  1099 "stk500boot.c" 1
 4658 162e 0801      		movw  r0, r16
 4659 1630 FC01      		movw r30, r24
 4660 1632 A093 5B00 		sts 91, r26
 4661 1636 6093 5700 		sts 87, r22
 4662 163a E895      		spm
 4663 163c 1124      		clr  r1
 4664               		
 4665               	 ;  0 "" 2
1101:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
 4667               	.LM612:
 4668               	/* #NOAPP */
 4669 163e 0296      		adiw r24,2
 4670 1640 A11D      		adc r26,__zero_reg__
 4671 1642 B11D      		adc r27,__zero_reg__
1102:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 4673               	.LM613:
 4674 1644 2250      		subi r18,lo8(-(-2))
 4675 1646 3040      		sbci r19,hi8(-(-2))
1103:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 4677               	.LM614:
 4678 1648 01F4      		brne .L204
 4679 164a A501      		movw r20,r10
 4680 164c 8701      		movw r16,r14
 4681 164e 7601      		movw r14,r12
 4682 1650 5C01      		movw r10,r24
 4683 1652 6D01      		movw r12,r26
1105:stk500boot.c  **** 							boot_page_write(tempaddress);
 4685               	.LM615:
 4686 1654 25E0      		ldi r18,lo8(5)
 4687 1656 CA5D      		subi r28,lo8(-294)
 4688 1658 DE4F      		sbci r29,hi8(-294)
 4689 165a 4880      		ld r4,Y
 4690 165c 5980      		ldd r5,Y+1
 4691 165e 6A80      		ldd r6,Y+2
 4692 1660 7B80      		ldd r7,Y+3
 4693 1662 C652      		subi r28,lo8(294)
 4694 1664 D140      		sbci r29,hi8(294)
 4695               	/* #APP */
 4696               	 ;  1105 "stk500boot.c" 1
 4697 1666 F201      		movw r30, r4
 4698 1668 6092 5B00 		sts 91, r6
 4699 166c 2093 5700 		sts 87, r18
 4700 1670 E895      		spm
 4701               		
 4702               	 ;  0 "" 2
 4703               	/* #NOAPP */
 4704               	.L205:
1106:stk500boot.c  **** 							boot_spm_busy_wait();
 4706               	.LM616:
 4707 1672 07B6      		in __tmp_reg__,87-32
 4708 1674 00FC      		sbrc __tmp_reg__,0
 4709 1676 00C0      		rjmp .L205
1107:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 4711               	.LM617:
 4712 1678 F1E1      		ldi r31,lo8(17)
 4713               	/* #APP */
 4714               	 ;  1107 "stk500boot.c" 1
 4715 167a F093 5700 		sts 87, r31
 4716 167e E895      		spm
 4717               		
 4718               	 ;  0 "" 2
1101:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
 4720               	.LM618:
 4721               	/* #NOAPP */
 4722 1680 CA5D      		subi r28,lo8(-294)
 4723 1682 DE4F      		sbci r29,hi8(-294)
 4724 1684 A882      		st Y,r10
 4725 1686 B982      		std Y+1,r11
 4726 1688 CA82      		std Y+2,r12
 4727 168a DB82      		std Y+3,r13
 4728 168c C652      		subi r28,lo8(294)
 4729 168e D140      		sbci r29,hi8(294)
 4730 1690 00C0      		rjmp .L307
 4731               	.L145:
 4732               	.LBE569:
 4733               	.LBB570:
 4734               	.LBB389:
 4735               	.LBB394:
 4736               	.LBB423:
2072:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
 4738               	.LM619:
 4739 1692 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 4740 1694 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 4741 1696 60E0      		ldi r22,lo8(0)
 4742 1698 0E94 0000 		call PrintFromPROGMEMln
 4743 169c 0C94 0000 		jmp .L298
 4744               	.L329:
 4745               	.LBE423:
 4746               	.LBE394:
 4747               	.LBE389:
 4748               	.LBE570:
 4749               	.LBB571:
1025:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 4751               	.LM620:
 4752 16a0 8C81      		ldd r24,Y+4
 4753 16a2 8830      		cpi r24,lo8(8)
 4754 16a4 01F4      		brne .+2
 4755 16a6 00C0      		rjmp .L332
 4756               	.LBB558:
1028:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 4758               	.LM621:
 4759 16a8 E0E0      		ldi r30,lo8(0)
 4760 16aa F0E0      		ldi r31,hi8(0)
 4761 16ac A9E0      		ldi r26,lo8(9)
 4762               	/* #APP */
 4763               	 ;  1028 "stk500boot.c" 1
 4764 16ae A093 5700 		sts 87, r26
 4765 16b2 8491      		lpm r24, Z
 4766               		
 4767               	 ;  0 "" 2
 4768               	/* #NOAPP */
 4769 16b4 00C0      		rjmp .L199
 4770               	.L237:
 4771               	.LBE558:
 4772               	.LBE571:
 4773               	.LBB572:
 999:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 4775               	.LM622:
 4776 16b6 8EE1      		ldi r24,lo8(30)
 4777 16b8 00C0      		rjmp .L199
 4778               	.L316:
 4779               	.LBE572:
 4780               	.LBB573:
1141:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 4782               	.LM623:
 4783 16ba DE01      		movw r26,r28
 4784 16bc 1396      		adiw r26,3
 4785 16be CA5D      		subi r28,lo8(-294)
 4786 16c0 DE4F      		sbci r29,hi8(-294)
 4787 16c2 A880      		ld r10,Y
 4788 16c4 B980      		ldd r11,Y+1
 4789 16c6 CA80      		ldd r12,Y+2
 4790 16c8 DB80      		ldd r13,Y+3
 4791 16ca C652      		subi r28,lo8(294)
 4792 16cc D140      		sbci r29,hi8(294)
 4793 16ce 9C01      		movw r18,r24
 4794               	.L210:
 4795               	.LBB529:
 4796               	.LBB528:
1150:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
 4798               	.LM624:
 4799               	/* #APP */
 4800               	 ;  1150 "stk500boot.c" 1
 4801 16d0 CBBE      		out 59, r12
 4802 16d2 F501      		movw r30, r10
 4803 16d4 8791      		elpm r24, Z+
 4804 16d6 9691      		elpm r25, Z
 4805               		
 4806               	 ;  0 "" 2
 4807               	/* #NOAPP */
 4808               	.LBE528:
1154:stk500boot.c  **** 								*p++	=	(uint8_t)data;		//LSB
 4810               	.LM625:
 4811 16d8 8C93      		st X,r24
1155:stk500boot.c  **** 								*p++	=	(uint8_t)(data >> 8);	//MSB
 4813               	.LM626:
 4814 16da 1196      		adiw r26,1
 4815 16dc 9C93      		st X,r25
 4816 16de 1197      		sbiw r26,1
 571:stk500boot.c  **** int main(void)
 4818               	.LM627:
 4819 16e0 1296      		adiw r26,2
1156:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 4821               	.LM628:
 4822 16e2 92E0      		ldi r25,lo8(2)
 4823 16e4 492E      		mov r4,r25
 4824 16e6 512C      		mov r5,__zero_reg__
 4825 16e8 612C      		mov r6,__zero_reg__
 4826 16ea 712C      		mov r7,__zero_reg__
 4827 16ec A40C      		add r10,r4
 4828 16ee B51C      		adc r11,r5
 4829 16f0 C61C      		adc r12,r6
 4830 16f2 D71C      		adc r13,r7
1157:stk500boot.c  **** 								size	-=	2;
 4832               	.LM629:
 4833 16f4 6250      		subi r22,lo8(-(-2))
 4834 16f6 7040      		sbci r23,hi8(-(-2))
1158:stk500boot.c  **** 							}while (size);
 4836               	.LM630:
 4837 16f8 01F4      		brne .L210
 4838 16fa 00C0      		rjmp .L306
 4839               	.L236:
 4840               	.LBE529:
 4841               	.LBE573:
 4842               	.LBB574:
 956:stk500boot.c  **** 						switch(msgBuffer[1])
 4844               	.LM631:
 4845 16fc 80E0      		ldi r24,lo8(0)
 4846 16fe 00C0      		rjmp .L195
 4847               	.L151:
 4848               	.LBE574:
 4849               	.LBB575:
 4850               	.LBB520:
 4851               	.LBB516:
 4852               	.LBB396:
1914:stk500boot.c  **** 		switch(portLetter)
 4854               	.LM632:
 4855 1700 0334      		cpi r16,lo8(67)
 4856 1702 01F4      		brne .+2
 4857 1704 00C0      		rjmp .L149
 4858 1706 0434      		cpi r16,lo8(68)
 4859 1708 01F0      		breq .+2
 4860 170a 00C0      		rjmp .L146
1954:stk500boot.c  **** 				DDRD	=	0xff;
 4862               	.LM633:
 4863 170c 5FEF      		ldi r21,lo8(-1)
 4864 170e 5AB9      		out 42-32,r21
 4865               	.L159:
 4866               	.LBB401:
 4867               	.LBB402:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 4869               	.LM634:
 4870 1710 6091 C000 		lds r22,192
 4871               	.LBE402:
 4872               	.LBE401:
1955:stk500boot.c  **** 				while (!Serial_Available())
 4874               	.LM635:
 4875 1714 67FD      		sbrc r22,7
 4876 1716 00C0      		rjmp .L333
1957:stk500boot.c  **** 					PORTD	^=	0xff;
 4878               	.LM636:
 4879 1718 8BB1      		in r24,43-32
 4880 171a 8095      		com r24
 4881 171c 8BB9      		out 43-32,r24
 4882               	.LBB399:
 4883               	.LBB400:
 4885               	.Ltext9:
 4887               	.LM637:
 4888 171e 2FEF      		 ldi r18,lo8(319999)
 4889 1720 31EE      	    ldi r19,hi8(319999)
 4890 1722 44E0      	    ldi r20,hlo8(319999)
 4891 1724 2150      	    1:subi r18,1
 4892 1726 3040      	    sbci r19,0
 4893 1728 4040      	    sbci r20,0
 4894 172a 01F4      	    brne 1b
 4895 172c 00C0      		rjmp .
 4896 172e 0000      		nop
 4897 1730 00C0      		rjmp .L159
 4898               	.L232:
 4899               	.LBE400:
 4900               	.LBE399:
 4901               	.LBE396:
 4902               	.LBE516:
 4903               	.LBE520:
 4904               	.LBE575:
 4905               	.LBB576:
 4906               	.LBB550:
 4908               	.Ltext10:
 890:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 4910               	.LM638:
 4911 1732 9EE1      		ldi r25,lo8(30)
 4912 1734 00C0      		rjmp .L192
 4913               	.L318:
 4914               	.LBE550:
 4915               	.LBE576:
 4916               	.LBB577:
 4917               	.LBB388:
 4918               	.LBB393:
 4919               	.LBB424:
1918:stk500boot.c  **** 				DDRA	=	0xff;
 4921               	.LM639:
 4922 1736 3FEF      		ldi r19,lo8(-1)
 4923 1738 31B9      		out 33-32,r19
 4924               	.L152:
 4925               	.LBB410:
 4926               	.LBB411:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 4928               	.LM640:
 4929 173a C090 C000 		lds r12,192
 4930               	.LBE411:
 4931               	.LBE410:
1919:stk500boot.c  **** 				while (!Serial_Available())
 4933               	.LM641:
 4934 173e C7FC      		sbrc r12,7
 4935 1740 00C0      		rjmp .L334
1921:stk500boot.c  **** 					PORTA	^=	0xff;
 4937               	.LM642:
 4938 1742 82B1      		in r24,34-32
 4939 1744 8095      		com r24
 4940 1746 82B9      		out 34-32,r24
 4941               	.LBB412:
 4942               	.LBB413:
 4944               	.Ltext11:
 4946               	.LM643:
 4947 1748 8FEF      		 ldi r24,lo8(319999)
 4948 174a 91EE      	    ldi r25,hi8(319999)
 4949 174c A4E0      	    ldi r26,hlo8(319999)
 4950 174e 8150      	    1:subi r24,1
 4951 1750 9040      	    sbci r25,0
 4952 1752 A040      	    sbci r26,0
 4953 1754 01F4      	    brne 1b
 4954 1756 00C0      		rjmp .
 4955 1758 0000      		nop
 4956 175a 00C0      		rjmp .L152
 4957               	.L148:
 4958               	.LBE413:
 4959               	.LBE412:
 4961               	.Ltext12:
1930:stk500boot.c  **** 				DDRB	=	0xff;
 4963               	.LM644:
 4964 175c 4FEF      		ldi r20,lo8(-1)
 4965 175e 44B9      		out 36-32,r20
 4966               	.L155:
 4967               	.LBB414:
 4968               	.LBB415:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 4970               	.LM645:
 4971 1760 D090 C000 		lds r13,192
 4972               	.LBE415:
 4973               	.LBE414:
1931:stk500boot.c  **** 				while (!Serial_Available())
 4975               	.LM646:
 4976 1764 D7FC      		sbrc r13,7
 4977 1766 00C0      		rjmp .L335
1933:stk500boot.c  **** 					PORTB	^=	0xff;
 4979               	.LM647:
 4980 1768 85B1      		in r24,37-32
 4981 176a 8095      		com r24
 4982 176c 85B9      		out 37-32,r24
 4983               	.LBB416:
 4984               	.LBB417:
 4986               	.Ltext13:
 4988               	.LM648:
 4989 176e 2FEF      		 ldi r18,lo8(319999)
 4990 1770 31EE      	    ldi r19,hi8(319999)
 4991 1772 44E0      	    ldi r20,hlo8(319999)
 4992 1774 2150      	    1:subi r18,1
 4993 1776 3040      	    sbci r19,0
 4994 1778 4040      	    sbci r20,0
 4995 177a 01F4      	    brne 1b
 4996 177c 00C0      		rjmp .
 4997 177e 0000      		nop
 4998 1780 00C0      		rjmp .L155
 4999               	.L334:
 5000               	.LBE417:
 5001               	.LBE416:
 5003               	.Ltext14:
1924:stk500boot.c  **** 				PORTA	=	0;
 5005               	.LM649:
 5006 1782 12B8      		out 34-32,__zero_reg__
 5007               	.L243:
 5008               	.LBB418:
 5009               	.LBB405:
 524:stk500boot.c  **** 	while (!(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE)))
 5011               	.LM650:
 5012 1784 7091 C000 		lds r23,192
 5013 1788 77FF      		sbrs r23,7
 5014 178a 00C0      		rjmp .L243
 5015 178c 00C0      		rjmp .L305
 5016               	.L335:
 5017               	.LBE405:
 5018               	.LBE418:
1936:stk500boot.c  **** 				PORTB	=	0;
 5020               	.LM651:
 5021 178e 15B8      		out 37-32,__zero_reg__
 5022 1790 00C0      		rjmp .L243
 5023               	.L149:
1942:stk500boot.c  **** 				DDRC	=	0xff;
 5025               	.LM652:
 5026 1792 AFEF      		ldi r26,lo8(-1)
 5027 1794 A7B9      		out 39-32,r26
 5028               	.L157:
 5029               	.LBB419:
 5030               	.LBB420:
 501:stk500boot.c  **** 	return(UART_STATUS_REG & _BV(UART_RECEIVE_COMPLETE));	// wait for data
 5032               	.LM653:
 5033 1796 1091 C000 		lds r17,192
 5034               	.LBE420:
 5035               	.LBE419:
1943:stk500boot.c  **** 				while (!Serial_Available())
 5037               	.LM654:
 5038 179a 17FD      		sbrc r17,7
 5039 179c 00C0      		rjmp .L336
1945:stk500boot.c  **** 					PORTC	^=	0xff;
 5041               	.LM655:
 5042 179e 88B1      		in r24,40-32
 5043 17a0 8095      		com r24
 5044 17a2 88B9      		out 40-32,r24
 5045               	.LBB421:
 5046               	.LBB422:
 5048               	.Ltext15:
 5050               	.LM656:
 5051 17a4 8FEF      		 ldi r24,lo8(319999)
 5052 17a6 91EE      	    ldi r25,hi8(319999)
 5053 17a8 A4E0      	    ldi r26,hlo8(319999)
 5054 17aa 8150      	    1:subi r24,1
 5055 17ac 9040      	    sbci r25,0
 5056 17ae A040      	    sbci r26,0
 5057 17b0 01F4      	    brne 1b
 5058 17b2 00C0      		rjmp .
 5059 17b4 0000      		nop
 5060 17b6 00C0      		rjmp .L157
 5061               	.L333:
 5062               	.LBE422:
 5063               	.LBE421:
 5065               	.Ltext16:
1960:stk500boot.c  **** 				PORTD	=	0;
 5067               	.LM657:
 5068 17b8 1BB8      		out 43-32,__zero_reg__
 5069 17ba 00C0      		rjmp .L243
 5070               	.L336:
1948:stk500boot.c  **** 				PORTC	=	0;
 5072               	.LM658:
 5073 17bc 18B8      		out 40-32,__zero_reg__
 5074 17be 00C0      		rjmp .L243
 5075               	.L332:
 5076               	.LBE424:
 5077               	.LBE393:
 5078               	.LBE388:
 5079               	.LBE577:
 5080               	.LBB578:
 5081               	.LBB562:
1026:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 5083               	.LM659:
 5084 17c0 E2E0      		ldi r30,lo8(2)
 5085 17c2 F0E0      		ldi r31,hi8(2)
 5086 17c4 39E0      		ldi r19,lo8(9)
 5087               	/* #APP */
 5088               	 ;  1026 "stk500boot.c" 1
 5089 17c6 3093 5700 		sts 87, r19
 5090 17ca 8491      		lpm r24, Z
 5091               		
 5092               	 ;  0 "" 2
 5093               	/* #NOAPP */
 5094 17cc 00C0      		rjmp .L199
 5095               	.L331:
 5096               	.LBE562:
 5097               	.LBE578:
 5098               	.LBB579:
 5099               	.LBB548:
 894:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 5101               	.LM660:
 5102 17ce 97E9      		ldi r25,lo8(-105)
 5103 17d0 00C0      		rjmp .L192
 5104               	.L330:
 5105               	.LBE548:
 5106               	.LBE579:
 5107               	.LBB580:
1001:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 5109               	.LM661:
 5110 17d2 87E9      		ldi r24,lo8(-105)
 5111 17d4 00C0      		rjmp .L199
 5112               	.L322:
 5113               	.LBE580:
 5114               	.LBB581:
 5115               	.LBB551:
 914:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 5117               	.LM662:
 5118 17d6 E3E0      		ldi r30,lo8(3)
 5119 17d8 F0E0      		ldi r31,hi8(3)
 5120 17da 29E0      		ldi r18,lo8(9)
 5121               	/* #APP */
 5122               	 ;  914 "stk500boot.c" 1
 5123 17dc 2093 5700 		sts 87, r18
 5124 17e0 9491      		lpm r25, Z
 5125               		
 5126               	 ;  0 "" 2
 5127               	/* #NOAPP */
 5128 17e2 00C0      		rjmp .L192
 5129               	.L321:
 5130               	.LBE551:
 5131               	.LBB552:
 910:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 5133               	.LM663:
 5134 17e4 E0E0      		ldi r30,lo8(0)
 5135 17e6 F0E0      		ldi r31,hi8(0)
 5136 17e8 99E0      		ldi r25,lo8(9)
 5137               	/* #APP */
 5138               	 ;  910 "stk500boot.c" 1
 5139 17ea 9093 5700 		sts 87, r25
 5140 17ee 9491      		lpm r25, Z
 5141               		
 5142               	 ;  0 "" 2
 5143               	/* #NOAPP */
 5144 17f0 00C0      		rjmp .L192
 5145               	.L226:
 5146               	.LBE552:
 5147               	.LBE581:
 5148               	.LBB582:
 5149               	.LBB521:
 5150               	.LBB517:
 5151               	.LBB449:
1669:stk500boot.c  **** 	errorCount	=	0;
 5153               	.LM664:
 5154 17f2 EE24      		clr r14
 5155 17f4 FF24      		clr r15
 5156 17f6 00C0      		rjmp .L114
 5157               	.LBE449:
 5158               	.LBE517:
 5159               	.LBE521:
 5160               	.LBE582:
 5346               	.Lscope10:
 5347               	.global	gAvrInt_RESET
 5348               		.section	.progmem.data,"a",@progbits
 5351               	gAvrInt_RESET:
 5352 0000 5245 5345 		.string	"RESET"
 5352      5400 
 5353               	.global	gAvrInt_INT0
 5356               	gAvrInt_INT0:
 5357 0006 494E 5430 		.string	"INT0"
 5357      00
 5358               	.global	gAvrInt_INT1
 5361               	gAvrInt_INT1:
 5362 000b 494E 5431 		.string	"INT1"
 5362      00
 5363               	.global	gAvrInt_INT2
 5366               	gAvrInt_INT2:
 5367 0010 494E 5432 		.string	"INT2"
 5367      00
 5368               	.global	gAvrInt_PCINT0
 5371               	gAvrInt_PCINT0:
 5372 0015 5043 494E 		.string	"PCINT0"
 5372      5430 00
 5373               	.global	gAvrInt_PCINT1
 5376               	gAvrInt_PCINT1:
 5377 001c 5043 494E 		.string	"PCINT1"
 5377      5431 00
 5378               	.global	gAvrInt_PCINT2
 5381               	gAvrInt_PCINT2:
 5382 0023 5043 494E 		.string	"PCINT2"
 5382      5432 00
 5383               	.global	gAvrInt_PCINT3
 5386               	gAvrInt_PCINT3:
 5387 002a 5043 494E 		.string	"PCINT3"
 5387      5433 00
 5388               	.global	gAvrInt_WDT
 5391               	gAvrInt_WDT:
 5392 0031 5744 5400 		.string	"WDT"
 5393               	.global	gAvrInt_TIMER0_COMPA
 5396               	gAvrInt_TIMER0_COMPA:
 5397 0035 5449 4D45 		.string	"TIMER0 COMPA"
 5397      5230 2043 
 5397      4F4D 5041 
 5397      00
 5398               	.global	gAvrInt_TIMER0_COMPB
 5401               	gAvrInt_TIMER0_COMPB:
 5402 0042 5449 4D45 		.string	"TIMER0 COMPB"
 5402      5230 2043 
 5402      4F4D 5042 
 5402      00
 5403               	.global	gAvrInt_TIMER0_OVF
 5406               	gAvrInt_TIMER0_OVF:
 5407 004f 5449 4D45 		.string	"TIMER0 OVF"
 5407      5230 204F 
 5407      5646 00
 5408               	.global	gAvrInt_TIMER1_CAPT
 5411               	gAvrInt_TIMER1_CAPT:
 5412 005a 5449 4D45 		.string	"TIMER1 CAPT"
 5412      5231 2043 
 5412      4150 5400 
 5413               	.global	gAvrInt_TIMER1_COMPA
 5416               	gAvrInt_TIMER1_COMPA:
 5417 0066 5449 4D45 		.string	"TIMER1 COMPA"
 5417      5231 2043 
 5417      4F4D 5041 
 5417      00
 5418               	.global	gAvrInt_TIMER1_COMPB
 5421               	gAvrInt_TIMER1_COMPB:
 5422 0073 5449 4D45 		.string	"TIMER1 COMPB"
 5422      5231 2043 
 5422      4F4D 5042 
 5422      00
 5423               	.global	gAvrInt_TIMER1_OVF
 5426               	gAvrInt_TIMER1_OVF:
 5427 0080 5449 4D45 		.string	"TIMER1 OVF"
 5427      5231 204F 
 5427      5646 00
 5428               	.global	gAvrInt_TIMER2_COMPA
 5431               	gAvrInt_TIMER2_COMPA:
 5432 008b 5449 4D45 		.string	"TIMER2 COMPA"
 5432      5232 2043 
 5432      4F4D 5041 
 5432      00
 5433               	.global	gAvrInt_TIMER2_COMPB
 5436               	gAvrInt_TIMER2_COMPB:
 5437 0098 5449 4D45 		.string	"TIMER2 COMPB"
 5437      5232 2043 
 5437      4F4D 5042 
 5437      00
 5438               	.global	gAvrInt_TIMER2_OVF
 5441               	gAvrInt_TIMER2_OVF:
 5442 00a5 5449 4D45 		.string	"TIMER2 OVF"
 5442      5232 204F 
 5442      5646 00
 5443               	.global	gAvrInt_TIMER3_CAPT
 5446               	gAvrInt_TIMER3_CAPT:
 5447 00b0 5449 4D45 		.string	"TIMER3 CAPT"
 5447      5233 2043 
 5447      4150 5400 
 5448               	.global	gAvrInt_TIMER3_COMPA
 5451               	gAvrInt_TIMER3_COMPA:
 5452 00bc 5449 4D45 		.string	"TIMER3 COMPA"
 5452      5233 2043 
 5452      4F4D 5041 
 5452      00
 5453               	.global	gAvrInt_TIMER3_COMPB
 5456               	gAvrInt_TIMER3_COMPB:
 5457 00c9 5449 4D45 		.string	"TIMER3 COMPB"
 5457      5233 2043 
 5457      4F4D 5042 
 5457      00
 5458               	.global	gAvrInt_TIMER3_OVF
 5461               	gAvrInt_TIMER3_OVF:
 5462 00d6 5449 4D45 		.string	"TIMER3 OVF"
 5462      5233 204F 
 5462      5646 00
 5463               	.global	gAvrInt_USART0_RX
 5466               	gAvrInt_USART0_RX:
 5467 00e1 5553 4152 		.string	"USART0 RX"
 5467      5430 2052 
 5467      5800 
 5468               	.global	gAvrInt_USART0_UDRE
 5471               	gAvrInt_USART0_UDRE:
 5472 00eb 5553 4152 		.string	"USART0 UDRE"
 5472      5430 2055 
 5472      4452 4500 
 5473               	.global	gAvrInt_USART0_TX
 5476               	gAvrInt_USART0_TX:
 5477 00f7 5553 4152 		.string	"USART0 TX"
 5477      5430 2054 
 5477      5800 
 5478               	.global	gAvrInt_USART1_RX
 5481               	gAvrInt_USART1_RX:
 5482 0101 5553 4152 		.string	"USART1 RX"
 5482      5431 2052 
 5482      5800 
 5483               	.global	gAvrInt_USART1_UDRE
 5486               	gAvrInt_USART1_UDRE:
 5487 010b 5553 4152 		.string	"USART1 UDRE"
 5487      5431 2055 
 5487      4452 4500 
 5488               	.global	gAvrInt_USART1_TX
 5491               	gAvrInt_USART1_TX:
 5492 0117 5553 4152 		.string	"USART1 TX"
 5492      5431 2054 
 5492      5800 
 5493               	.global	gAvrInt_SPI_STC
 5496               	gAvrInt_SPI_STC:
 5497 0121 5350 4920 		.string	"SPI STC"
 5497      5354 4300 
 5498               	.global	gAvrInt_ADC
 5501               	gAvrInt_ADC:
 5502 0129 4144 4300 		.string	"ADC"
 5503               	.global	gAvrInt_ANALOG_COMP
 5506               	gAvrInt_ANALOG_COMP:
 5507 012d 414E 414C 		.string	"ANALOG COMP"
 5507      4F47 2043 
 5507      4F4D 5000 
 5508               	.global	gAvrInt_EE_READY
 5511               	gAvrInt_EE_READY:
 5512 0139 4545 2052 		.string	"EE READY"
 5512      4541 4459 
 5512      00
 5513               	.global	gAvrInt_TWI
 5516               	gAvrInt_TWI:
 5517 0142 5457 4900 		.string	"TWI"
 5518               	.global	gAvrInt_SPM_READY
 5521               	gAvrInt_SPM_READY:
 5522 0146 5350 4D20 		.string	"SPM READY"
 5522      5245 4144 
 5522      5900 
 5523               	.global	gAvrInt_END
 5526               	gAvrInt_END:
 5527 0150 2A00      		.string	"*"
 5528               	.global	gInterruptNameTable
 5531               	gInterruptNameTable:
 5532 0152 0000      		.word	gAvrInt_RESET
 5533 0154 0000      		.word	gAvrInt_INT0
 5534 0156 0000      		.word	gAvrInt_INT1
 5535 0158 0000      		.word	gAvrInt_INT2
 5536 015a 0000      		.word	gAvrInt_PCINT0
 5537 015c 0000      		.word	gAvrInt_PCINT1
 5538 015e 0000      		.word	gAvrInt_PCINT2
 5539 0160 0000      		.word	gAvrInt_PCINT3
 5540 0162 0000      		.word	gAvrInt_WDT
 5541 0164 0000      		.word	gAvrInt_TIMER2_COMPA
 5542 0166 0000      		.word	gAvrInt_TIMER2_COMPB
 5543 0168 0000      		.word	gAvrInt_TIMER2_OVF
 5544 016a 0000      		.word	gAvrInt_TIMER1_CAPT
 5545 016c 0000      		.word	gAvrInt_TIMER1_COMPA
 5546 016e 0000      		.word	gAvrInt_TIMER1_COMPB
 5547 0170 0000      		.word	gAvrInt_TIMER1_OVF
 5548 0172 0000      		.word	gAvrInt_TIMER0_COMPA
 5549 0174 0000      		.word	gAvrInt_TIMER0_COMPB
 5550 0176 0000      		.word	gAvrInt_TIMER0_OVF
 5551 0178 0000      		.word	gAvrInt_SPI_STC
 5552 017a 0000      		.word	gAvrInt_USART0_RX
 5553 017c 0000      		.word	gAvrInt_USART0_UDRE
 5554 017e 0000      		.word	gAvrInt_USART0_TX
 5555 0180 0000      		.word	gAvrInt_ANALOG_COMP
 5556 0182 0000      		.word	gAvrInt_ADC
 5557 0184 0000      		.word	gAvrInt_EE_READY
 5558 0186 0000      		.word	gAvrInt_TWI
 5559 0188 0000      		.word	gAvrInt_SPM_READY
 5560 018a 0000      		.word	gAvrInt_USART1_RX
 5561 018c 0000      		.word	gAvrInt_USART1_UDRE
 5562 018e 0000      		.word	gAvrInt_USART1_TX
 5563 0190 0000      		.word	gAvrInt_TIMER3_CAPT
 5564 0192 0000      		.word	gAvrInt_TIMER3_COMPA
 5565 0194 0000      		.word	gAvrInt_TIMER3_COMPB
 5566 0196 0000      		.word	gAvrInt_TIMER3_OVF
 5567               	.global	app_start
 5568               	.global	app_start
 5569               		.section .bss
 5572               	app_start:
 5573 0000 0000      		.skip 2,0
 5574               	.global	gTextMsg_CPU_Name
 5575               		.section	.progmem.data
 5578               	gTextMsg_CPU_Name:
 5579 0198 4154 6D65 		.string	"ATmega1284P"
 5579      6761 3132 
 5579      3834 5000 
 5580               	.global	gTextMsg_Explorer
 5583               	gTextMsg_Explorer:
 5584 01a4 5769 6C64 		.string	"Wildfire explorer stk500v2"
 5584      6669 7265 
 5584      2065 7870 
 5584      6C6F 7265 
 5584      7220 7374 
 5585               	.global	gTextMsg_Prompt
 5588               	gTextMsg_Prompt:
 5589 01bf 426F 6F74 		.string	"Bootloader>"
 5589      6C6F 6164 
 5589      6572 3E00 
 5590               	.global	gTextMsg_HUH
 5593               	gTextMsg_HUH:
 5594 01cb 4875 683F 		.string	"Huh?"
 5594      00
 5595               	.global	gTextMsg_COMPILED_ON
 5598               	gTextMsg_COMPILED_ON:
 5599 01d0 436F 6D70 		.string	"Compiled on = "
 5599      696C 6564 
 5599      206F 6E20 
 5599      3D20 00
 5600               	.global	gTextMsg_CPU_Type
 5603               	gTextMsg_CPU_Type:
 5604 01df 4350 5520 		.string	"CPU Type    = "
 5604      5479 7065 
 5604      2020 2020 
 5604      3D20 00
 5605               	.global	gTextMsg_AVR_ARCH
 5608               	gTextMsg_AVR_ARCH:
 5609 01ee 5F5F 4156 		.string	"__AVR_ARCH__= "
 5609      525F 4152 
 5609      4348 5F5F 
 5609      3D20 00
 5610               	.global	gTextMsg_AVR_LIBC
 5613               	gTextMsg_AVR_LIBC:
 5614 01fd 4156 5220 		.string	"AVR LibC Ver= "
 5614      4C69 6243 
 5614      2056 6572 
 5614      3D20 00
 5615               	.global	gTextMsg_GCC_VERSION
 5618               	gTextMsg_GCC_VERSION:
 5619 020c 4743 4320 		.string	"GCC Version = "
 5619      5665 7273 
 5619      696F 6E20 
 5619      3D20 00
 5620               	.global	gTextMsg_CPU_SIGNATURE
 5623               	gTextMsg_CPU_SIGNATURE:
 5624 021b 4350 5520 		.string	"CPU ID      = "
 5624      4944 2020 
 5624      2020 2020 
 5624      3D20 00
 5625               	.global	gTextMsg_FUSE_BYTE_LOW
 5628               	gTextMsg_FUSE_BYTE_LOW:
 5629 022a 4C6F 7720 		.string	"Low fuse    = "
 5629      6675 7365 
 5629      2020 2020 
 5629      3D20 00
 5630               	.global	gTextMsg_FUSE_BYTE_HIGH
 5633               	gTextMsg_FUSE_BYTE_HIGH:
 5634 0239 4869 6768 		.string	"High fuse   = "
 5634      2066 7573 
 5634      6520 2020 
 5634      3D20 00
 5635               	.global	gTextMsg_FUSE_BYTE_EXT
 5638               	gTextMsg_FUSE_BYTE_EXT:
 5639 0248 4578 7420 		.string	"Ext fuse    = "
 5639      6675 7365 
 5639      2020 2020 
 5639      3D20 00
 5640               	.global	gTextMsg_FUSE_BYTE_LOCK
 5643               	gTextMsg_FUSE_BYTE_LOCK:
 5644 0257 4C6F 636B 		.string	"Lock fuse   = "
 5644      2066 7573 
 5644      6520 2020 
 5644      3D20 00
 5645               	.global	gTextMsg_GCC_DATE_STR
 5648               	gTextMsg_GCC_DATE_STR:
 5649 0266 5365 7020 		.string	"Sep 25 2013"
 5649      3235 2032 
 5649      3031 3300 
 5650               	.global	gTextMsg_AVR_LIBC_VER_STR
 5653               	gTextMsg_AVR_LIBC_VER_STR:
 5654 0272 312E 372E 		.string	"1.7.1"
 5654      3100 
 5655               	.global	gTextMsg_GCC_VERSION_STR
 5658               	gTextMsg_GCC_VERSION_STR:
 5659 0278 342E 352E 		.string	"4.5.3"
 5659      3300 
 5660               	.global	gTextMsg_VECTOR_HEADER
 5663               	gTextMsg_VECTOR_HEADER:
 5664 027e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 5664      2041 4444 
 5664      5220 2020 
 5664      6F70 2063 
 5664      6F64 6520 
 5665               	.global	gTextMsg_noVector
 5668               	gTextMsg_noVector:
 5669 02b3 6E6F 2076 		.string	"no vector"
 5669      6563 746F 
 5669      7200 
 5670               	.global	gTextMsg_rjmp
 5673               	gTextMsg_rjmp:
 5674 02bd 726A 6D70 		.string	"rjmp  "
 5674      2020 00
 5675               	.global	gTextMsg_jmp
 5678               	gTextMsg_jmp:
 5679 02c4 6A6D 7020 		.string	"jmp "
 5679      00
 5680               	.global	gTextMsg_WHAT_PORT
 5683               	gTextMsg_WHAT_PORT:
 5684 02c9 5768 6174 		.string	"What port:"
 5684      2070 6F72 
 5684      743A 00
 5685               	.global	gTextMsg_PortNotSupported
 5688               	gTextMsg_PortNotSupported:
 5689 02d4 506F 7274 		.string	"Port not supported"
 5689      206E 6F74 
 5689      2073 7570 
 5689      706F 7274 
 5689      6564 00
 5690               	.global	gTextMsg_MustBeLetter
 5693               	gTextMsg_MustBeLetter:
 5694 02e7 4D75 7374 		.string	"Must be a letter"
 5694      2062 6520 
 5694      6120 6C65 
 5694      7474 6572 
 5694      00
 5695               	.global	gTextMsg_SPACE
 5698               	gTextMsg_SPACE:
 5699 02f8 2000      		.string	" "
 5700               	.global	gTextMsg_WriteToEEprom
 5703               	gTextMsg_WriteToEEprom:
 5704 02fa 5772 6974 		.string	"Writing EE"
 5704      696E 6720 
 5704      4545 00
 5705               	.global	gTextMsg_ReadingEEprom
 5708               	gTextMsg_ReadingEEprom:
 5709 0305 5265 6164 		.string	"Reading EE"
 5709      696E 6720 
 5709      4545 00
 5710               	.global	gTextMsg_EEPROMerrorCnt
 5713               	gTextMsg_EEPROMerrorCnt:
 5714 0310 4545 2065 		.string	"EE err cnt="
 5714      7272 2063 
 5714      6E74 3D00 
 5715               	.global	gTextMsg_PORT
 5718               	gTextMsg_PORT:
 5719 031c 504F 5254 		.string	"PORT"
 5719      00
 5720               	.global	gTextMsg_HELP_MSG_0
 5723               	gTextMsg_HELP_MSG_0:
 5724 0321 303D 5A65 		.string	"0=Zero addr"
 5724      726F 2061 
 5724      6464 7200 
 5725               	.global	gTextMsg_HELP_MSG_QM
 5728               	gTextMsg_HELP_MSG_QM:
 5729 032d 3F3D 4350 		.string	"?=CPU stats"
 5729      5520 7374 
 5729      6174 7300 
 5730               	.global	gTextMsg_HELP_MSG_AT
 5733               	gTextMsg_HELP_MSG_AT:
 5734 0339 403D 4545 		.string	"@=EEPROM test"
 5734      5052 4F4D 
 5734      2074 6573 
 5734      7400 
 5735               	.global	gTextMsg_HELP_MSG_B
 5738               	gTextMsg_HELP_MSG_B:
 5739 0347 423D 426C 		.string	"B=Blink LED"
 5739      696E 6B20 
 5739      4C45 4400 
 5740               	.global	gTextMsg_HELP_MSG_E
 5743               	gTextMsg_HELP_MSG_E:
 5744 0353 453D 4475 		.string	"E=Dump EEPROM"
 5744      6D70 2045 
 5744      4550 524F 
 5744      4D00 
 5745               	.global	gTextMsg_HELP_MSG_F
 5748               	gTextMsg_HELP_MSG_F:
 5749 0361 463D 4475 		.string	"F=Dump FLASH"
 5749      6D70 2046 
 5749      4C41 5348 
 5749      00
 5750               	.global	gTextMsg_HELP_MSG_H
 5753               	gTextMsg_HELP_MSG_H:
 5754 036e 483D 4865 		.string	"H=Help"
 5754      6C70 00
 5755               	.global	gTextMsg_HELP_MSG_L
 5758               	gTextMsg_HELP_MSG_L:
 5759 0375 4C3D 4C69 		.string	"L=List I/O Ports"
 5759      7374 2049 
 5759      2F4F 2050 
 5759      6F72 7473 
 5759      00
 5760               	.global	gTextMsg_HELP_MSG_Q
 5763               	gTextMsg_HELP_MSG_Q:
 5764 0386 513D 5175 		.string	"Q=Quit"
 5764      6974 00
 5765               	.global	gTextMsg_HELP_MSG_R
 5768               	gTextMsg_HELP_MSG_R:
 5769 038d 523D 4475 		.string	"R=Dump RAM"
 5769      6D70 2052 
 5769      414D 00
 5770               	.global	gTextMsg_HELP_MSG_V
 5773               	gTextMsg_HELP_MSG_V:
 5774 0398 563D 7368 		.string	"V=show interrupt Vectors"
 5774      6F77 2069 
 5774      6E74 6572 
 5774      7275 7074 
 5774      2056 6563 
 5775               	.global	gTextMsg_HELP_MSG_Y
 5778               	gTextMsg_HELP_MSG_Y:
 5779 03b1 593D 506F 		.string	"Y=Port blink"
 5779      7274 2062 
 5779      6C69 6E6B 
 5779      00
 5780               	.global	gTextMsg_END
 5783               	gTextMsg_END:
 5784 03be 2A00      		.string	"*"
 5785               		.comm gRamIndex,4,1
 5786               		.comm gFlashIndex,4,1
 5787               		.comm gEepromIndex,4,1
 5788               		.data
 5791               	CSWTCH.29:
 5792 0000 00        		.byte	0
 5793 0001 00        		.byte	0
 5794 0002 00        		.byte	0
 5795 0003 00        		.byte	0
 5796 0004 00        		.byte	0
 5797 0005 00        		.byte	0
 5798 0006 00        		.byte	0
 5799 0007 00        		.byte	0
 5800 0008 00        		.byte	0
 5801 0009 00        		.byte	0
 5802 000a 00        		.byte	0
 5803 000b 00        		.byte	0
 5804 000c 00        		.byte	0
 5805 000d 00        		.byte	0
 5806 000e 00        		.byte	0
 5807 000f 00        		.byte	0
 5808 0010 0F        		.byte	15
 5809 0011 02        		.byte	2
 5810 0012 0A        		.byte	10
 5894               		.text
 5896               	.Letext0:
 5897               	.global __do_copy_data
 5898               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccxD7Ape.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccxD7Ape.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccxD7Ape.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccxD7Ape.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccxD7Ape.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccxD7Ape.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccxD7Ape.s:101    .init9:0000000000000000 __jumpMain
     /tmp/ccxD7Ape.s:113    *ABS*:00000000000040ff __stack
     /tmp/ccxD7Ape.s:986    .text:0000000000000368 main
     /tmp/ccxD7Ape.s:162    .text:0000000000000000 PrintFromPROGMEM
     /tmp/ccxD7Ape.s:258    .text:000000000000004a PrintNewLine
     /tmp/ccxD7Ape.s:313    .text:000000000000007c PrintAvailablePort
     /tmp/ccxD7Ape.s:5718   .progmem.data:000000000000031c gTextMsg_PORT
     /tmp/ccxD7Ape.s:362    .text:00000000000000a8 PrintFromPROGMEMln
     /tmp/ccxD7Ape.s:386    .text:00000000000000b2 PrintString
     /tmp/ccxD7Ape.s:442    .text:00000000000000da PrintHexByte
     /tmp/ccxD7Ape.s:524    .text:0000000000000124 DumpHex.clone.0
     /tmp/ccxD7Ape.s:865    .text:00000000000002dc PrintDecInt
     /tmp/ccxD7Ape.s:5572   .bss:0000000000000000 app_start
     /tmp/ccxD7Ape.s:5583   .progmem.data:00000000000001a4 gTextMsg_Explorer
                            *COM*:0000000000000004 gRamIndex
                            *COM*:0000000000000004 gFlashIndex
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccxD7Ape.s:5588   .progmem.data:00000000000001bf gTextMsg_Prompt
     /tmp/ccxD7Ape.s:5593   .progmem.data:00000000000001cb gTextMsg_HUH
     /tmp/ccxD7Ape.s:5763   .progmem.data:0000000000000386 gTextMsg_HELP_MSG_Q
     /tmp/ccxD7Ape.s:5778   .progmem.data:00000000000003b1 gTextMsg_HELP_MSG_Y
     /tmp/ccxD7Ape.s:5683   .progmem.data:00000000000002c9 gTextMsg_WHAT_PORT
     /tmp/ccxD7Ape.s:5688   .progmem.data:00000000000002d4 gTextMsg_PortNotSupported
     /tmp/ccxD7Ape.s:5748   .progmem.data:0000000000000361 gTextMsg_HELP_MSG_F
     /tmp/ccxD7Ape.s:5791   .data:0000000000000000 CSWTCH.29
     /tmp/ccxD7Ape.s:5768   .progmem.data:000000000000038d gTextMsg_HELP_MSG_R
     /tmp/ccxD7Ape.s:5758   .progmem.data:0000000000000375 gTextMsg_HELP_MSG_L
     /tmp/ccxD7Ape.s:5743   .progmem.data:0000000000000353 gTextMsg_HELP_MSG_E
     /tmp/ccxD7Ape.s:5773   .progmem.data:0000000000000398 gTextMsg_HELP_MSG_V
     /tmp/ccxD7Ape.s:5578   .progmem.data:0000000000000198 gTextMsg_CPU_Name
     /tmp/ccxD7Ape.s:5663   .progmem.data:000000000000027e gTextMsg_VECTOR_HEADER
     /tmp/ccxD7Ape.s:5531   .progmem.data:0000000000000152 gInterruptNameTable
     /tmp/ccxD7Ape.s:5668   .progmem.data:00000000000002b3 gTextMsg_noVector
     /tmp/ccxD7Ape.s:5673   .progmem.data:00000000000002bd gTextMsg_rjmp
     /tmp/ccxD7Ape.s:5678   .progmem.data:00000000000002c4 gTextMsg_jmp
     /tmp/ccxD7Ape.s:5733   .progmem.data:0000000000000339 gTextMsg_HELP_MSG_AT
     /tmp/ccxD7Ape.s:5703   .progmem.data:00000000000002fa gTextMsg_WriteToEEprom
     /tmp/ccxD7Ape.s:5708   .progmem.data:0000000000000305 gTextMsg_ReadingEEprom
     /tmp/ccxD7Ape.s:5713   .progmem.data:0000000000000310 gTextMsg_EEPROMerrorCnt
     /tmp/ccxD7Ape.s:5698   .progmem.data:00000000000002f8 gTextMsg_SPACE
     /tmp/ccxD7Ape.s:5728   .progmem.data:000000000000032d gTextMsg_HELP_MSG_QM
     /tmp/ccxD7Ape.s:5598   .progmem.data:00000000000001d0 gTextMsg_COMPILED_ON
     /tmp/ccxD7Ape.s:5648   .progmem.data:0000000000000266 gTextMsg_GCC_DATE_STR
     /tmp/ccxD7Ape.s:5603   .progmem.data:00000000000001df gTextMsg_CPU_Type
     /tmp/ccxD7Ape.s:5608   .progmem.data:00000000000001ee gTextMsg_AVR_ARCH
     /tmp/ccxD7Ape.s:5618   .progmem.data:000000000000020c gTextMsg_GCC_VERSION
     /tmp/ccxD7Ape.s:5658   .progmem.data:0000000000000278 gTextMsg_GCC_VERSION_STR
     /tmp/ccxD7Ape.s:5613   .progmem.data:00000000000001fd gTextMsg_AVR_LIBC
     /tmp/ccxD7Ape.s:5653   .progmem.data:0000000000000272 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccxD7Ape.s:5623   .progmem.data:000000000000021b gTextMsg_CPU_SIGNATURE
     /tmp/ccxD7Ape.s:5628   .progmem.data:000000000000022a gTextMsg_FUSE_BYTE_LOW
     /tmp/ccxD7Ape.s:5633   .progmem.data:0000000000000239 gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccxD7Ape.s:5638   .progmem.data:0000000000000248 gTextMsg_FUSE_BYTE_EXT
     /tmp/ccxD7Ape.s:5643   .progmem.data:0000000000000257 gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccxD7Ape.s:5723   .progmem.data:0000000000000321 gTextMsg_HELP_MSG_0
     /tmp/ccxD7Ape.s:5738   .progmem.data:0000000000000347 gTextMsg_HELP_MSG_B
     /tmp/ccxD7Ape.s:5753   .progmem.data:000000000000036e gTextMsg_HELP_MSG_H
     /tmp/ccxD7Ape.s:5693   .progmem.data:00000000000002e7 gTextMsg_MustBeLetter
     /tmp/ccxD7Ape.s:5351   .progmem.data:0000000000000000 gAvrInt_RESET
     /tmp/ccxD7Ape.s:5356   .progmem.data:0000000000000006 gAvrInt_INT0
     /tmp/ccxD7Ape.s:5361   .progmem.data:000000000000000b gAvrInt_INT1
     /tmp/ccxD7Ape.s:5366   .progmem.data:0000000000000010 gAvrInt_INT2
     /tmp/ccxD7Ape.s:5371   .progmem.data:0000000000000015 gAvrInt_PCINT0
     /tmp/ccxD7Ape.s:5376   .progmem.data:000000000000001c gAvrInt_PCINT1
     /tmp/ccxD7Ape.s:5381   .progmem.data:0000000000000023 gAvrInt_PCINT2
     /tmp/ccxD7Ape.s:5386   .progmem.data:000000000000002a gAvrInt_PCINT3
     /tmp/ccxD7Ape.s:5391   .progmem.data:0000000000000031 gAvrInt_WDT
     /tmp/ccxD7Ape.s:5396   .progmem.data:0000000000000035 gAvrInt_TIMER0_COMPA
     /tmp/ccxD7Ape.s:5401   .progmem.data:0000000000000042 gAvrInt_TIMER0_COMPB
     /tmp/ccxD7Ape.s:5406   .progmem.data:000000000000004f gAvrInt_TIMER0_OVF
     /tmp/ccxD7Ape.s:5411   .progmem.data:000000000000005a gAvrInt_TIMER1_CAPT
     /tmp/ccxD7Ape.s:5416   .progmem.data:0000000000000066 gAvrInt_TIMER1_COMPA
     /tmp/ccxD7Ape.s:5421   .progmem.data:0000000000000073 gAvrInt_TIMER1_COMPB
     /tmp/ccxD7Ape.s:5426   .progmem.data:0000000000000080 gAvrInt_TIMER1_OVF
     /tmp/ccxD7Ape.s:5431   .progmem.data:000000000000008b gAvrInt_TIMER2_COMPA
     /tmp/ccxD7Ape.s:5436   .progmem.data:0000000000000098 gAvrInt_TIMER2_COMPB
     /tmp/ccxD7Ape.s:5441   .progmem.data:00000000000000a5 gAvrInt_TIMER2_OVF
     /tmp/ccxD7Ape.s:5446   .progmem.data:00000000000000b0 gAvrInt_TIMER3_CAPT
     /tmp/ccxD7Ape.s:5451   .progmem.data:00000000000000bc gAvrInt_TIMER3_COMPA
     /tmp/ccxD7Ape.s:5456   .progmem.data:00000000000000c9 gAvrInt_TIMER3_COMPB
     /tmp/ccxD7Ape.s:5461   .progmem.data:00000000000000d6 gAvrInt_TIMER3_OVF
     /tmp/ccxD7Ape.s:5466   .progmem.data:00000000000000e1 gAvrInt_USART0_RX
     /tmp/ccxD7Ape.s:5471   .progmem.data:00000000000000eb gAvrInt_USART0_UDRE
     /tmp/ccxD7Ape.s:5476   .progmem.data:00000000000000f7 gAvrInt_USART0_TX
     /tmp/ccxD7Ape.s:5481   .progmem.data:0000000000000101 gAvrInt_USART1_RX
     /tmp/ccxD7Ape.s:5486   .progmem.data:000000000000010b gAvrInt_USART1_UDRE
     /tmp/ccxD7Ape.s:5491   .progmem.data:0000000000000117 gAvrInt_USART1_TX
     /tmp/ccxD7Ape.s:5496   .progmem.data:0000000000000121 gAvrInt_SPI_STC
     /tmp/ccxD7Ape.s:5501   .progmem.data:0000000000000129 gAvrInt_ADC
     /tmp/ccxD7Ape.s:5506   .progmem.data:000000000000012d gAvrInt_ANALOG_COMP
     /tmp/ccxD7Ape.s:5511   .progmem.data:0000000000000139 gAvrInt_EE_READY
     /tmp/ccxD7Ape.s:5516   .progmem.data:0000000000000142 gAvrInt_TWI
     /tmp/ccxD7Ape.s:5521   .progmem.data:0000000000000146 gAvrInt_SPM_READY
     /tmp/ccxD7Ape.s:5526   .progmem.data:0000000000000150 gAvrInt_END
     /tmp/ccxD7Ape.s:5783   .progmem.data:00000000000003be gTextMsg_END

UNDEFINED SYMBOLS
__eerd_byte_m1284p
__divmodhi4
__udivmodsi4
__eeupd_byte_m1284p
__do_copy_data
__do_clear_bss
